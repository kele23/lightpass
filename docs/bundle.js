/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/handlebars/dist/cjs/handlebars.runtime.js":
/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars.runtime.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

// istanbul ignore next

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj['default'] = obj;
    return newObj;
  }
}
var _handlebarsBase = __webpack_require__(/*! ./handlebars/base */ "./node_modules/handlebars/dist/cjs/handlebars/base.js");
var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = __webpack_require__(/*! ./handlebars/safe-string */ "./node_modules/handlebars/dist/cjs/handlebars/safe-string.js");
var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
var _handlebarsException = __webpack_require__(/*! ./handlebars/exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
var _handlebarsUtils = __webpack_require__(/*! ./handlebars/utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
var Utils = _interopRequireWildcard(_handlebarsUtils);
var _handlebarsRuntime = __webpack_require__(/*! ./handlebars/runtime */ "./node_modules/handlebars/dist/cjs/handlebars/runtime.js");
var runtime = _interopRequireWildcard(_handlebarsRuntime);
var _handlebarsNoConflict = __webpack_require__(/*! ./handlebars/no-conflict */ "./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js");
var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();
  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;
  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };
  return hb;
}
var inst = create();
inst.create = create;
_handlebarsNoConflict2['default'](inst);
inst['default'] = inst;
exports["default"] = inst;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
var _exception = __webpack_require__(/*! ./exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
var _exception2 = _interopRequireDefault(_exception);
var _helpers = __webpack_require__(/*! ./helpers */ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js");
var _decorators = __webpack_require__(/*! ./decorators */ "./node_modules/handlebars/dist/cjs/handlebars/decorators.js");
var _logger = __webpack_require__(/*! ./logger */ "./node_modules/handlebars/dist/cjs/handlebars/logger.js");
var _logger2 = _interopRequireDefault(_logger);
var _internalProtoAccess = __webpack_require__(/*! ./internal/proto-access */ "./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js");
var VERSION = '4.7.7';
exports.VERSION = VERSION;
var COMPILER_REVISION = 8;
exports.COMPILER_REVISION = COMPILER_REVISION;
var LAST_COMPATIBLE_COMPILER_REVISION = 7;
exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2',
  // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0 <4.3.0',
  8: '>= 4.3.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';
function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};
  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}
HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,
  logger: _logger2['default'],
  log: _logger2['default'].log,
  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },
  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },
  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  },
  /**
   * Reset the memory of illegal property accesses that have already been logged.
   * @deprecated should only be used in handlebars test-cases
   */
  resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
    _internalProtoAccess.resetLoggedProperties();
  }
};
var log = _logger2['default'].log;
exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/decorators.js":
/*!*******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/decorators.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _decoratorsInline = __webpack_require__(/*! ./decorators/inline */ "./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js");
var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js":
/*!**************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
exports["default"] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function ret(context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }
    props.partials[options.args[0]] = options.fn;
    return ret;
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/exception.js":
/*!******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/exception.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];
function Exception(message, node) {
  var loc = node && node.loc,
    line = undefined,
    endLineNumber = undefined,
    column = undefined,
    endColumn = undefined;
  if (loc) {
    line = loc.start.line;
    endLineNumber = loc.end.line;
    column = loc.start.column;
    endColumn = loc.end.column;
    message += ' - ' + line + ':' + column;
  }
  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }
  try {
    if (loc) {
      this.lineNumber = line;
      this.endLineNumber = endLineNumber;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
        Object.defineProperty(this, 'endColumn', {
          value: endColumn,
          enumerable: true
        });
      } else {
        this.column = column;
        this.endColumn = endColumn;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}
Exception.prototype = new Error();
exports["default"] = Exception;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
exports.moveHelperToHooks = moveHelperToHooks;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _helpersBlockHelperMissing = __webpack_require__(/*! ./helpers/block-helper-missing */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js");
var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
var _helpersEach = __webpack_require__(/*! ./helpers/each */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js");
var _helpersEach2 = _interopRequireDefault(_helpersEach);
var _helpersHelperMissing = __webpack_require__(/*! ./helpers/helper-missing */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js");
var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
var _helpersIf = __webpack_require__(/*! ./helpers/if */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js");
var _helpersIf2 = _interopRequireDefault(_helpersIf);
var _helpersLog = __webpack_require__(/*! ./helpers/log */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js");
var _helpersLog2 = _interopRequireDefault(_helpersLog);
var _helpersLookup = __webpack_require__(/*! ./helpers/lookup */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js");
var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
var _helpersWith = __webpack_require__(/*! ./helpers/with */ "./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js");
var _helpersWith2 = _interopRequireDefault(_helpersWith);
function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}
function moveHelperToHooks(instance, helperName, keepHelper) {
  if (instance.helpers[helperName]) {
    instance.hooks[helperName] = instance.helpers[helperName];
    if (!keepHelper) {
      delete instance.helpers[helperName];
    }
  }
}

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
exports["default"] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
      fn = options.fn;
    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = {
          data: data
        };
      }
      return fn(context, options);
    }
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js":
/*!*********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/each.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
var _exception2 = _interopRequireDefault(_exception);
exports["default"] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }
    var fn = options.fn,
      inverse = options.inverse,
      i = 0,
      ret = '',
      data = undefined,
      contextPath = undefined;
    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }
    if (options.data) {
      data = _utils.createFrame(options.data);
    }
    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;
        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }
      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }
    if (context && _typeof(context) === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else if (__webpack_require__.g.Symbol && context[__webpack_require__.g.Symbol.iterator]) {
        var newContext = [];
        var iterator = context[__webpack_require__.g.Symbol.iterator]();
        for (var it = iterator.next(); !it.done; it = iterator.next()) {
          newContext.push(it.value);
        }
        context = newContext;
        for (var j = context.length; i < j; i++) {
          execIteration(i, i, i === context.length - 1);
        }
      } else {
        (function () {
          var priorKey = undefined;
          Object.keys(context).forEach(function (key) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          });
          if (priorKey !== undefined) {
            execIteration(priorKey, i - 1, true);
          }
        })();
      }
    }
    if (i === 0) {
      ret = inverse(this);
    }
    return ret;
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
var _exception2 = _interopRequireDefault(_exception);
exports["default"] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js":
/*!*******************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/if.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
var _exception2 = _interopRequireDefault(_exception);
exports["default"] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (arguments.length != 2) {
      throw new _exception2['default']('#if requires exactly one argument');
    }
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });
  instance.registerHelper('unless', function (conditional, options) {
    if (arguments.length != 2) {
      throw new _exception2['default']('#unless requires exactly one argument');
    }
    return instance.helpers['if'].call(this, conditional, {
      fn: options.inverse,
      inverse: options.fn,
      hash: options.hash
    });
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js":
/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/log.js ***!
  \********************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
      options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }
    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;
    instance.log.apply(instance, args);
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js":
/*!***********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js ***!
  \***********************************************************************/
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = function (instance) {
  instance.registerHelper('lookup', function (obj, field, options) {
    if (!obj) {
      // Note for 5.0: Change to "obj == null" in 5.0
      return obj;
    }
    return options.lookupProperty(obj, field);
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js":
/*!*********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/helpers/with.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
var _exception = __webpack_require__(/*! ../exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
var _exception2 = _interopRequireDefault(_exception);
exports["default"] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (arguments.length != 2) {
      throw new _exception2['default']('#with requires exactly one argument');
    }
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }
    var fn = options.fn;
    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }
      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createNewLookupObject = createNewLookupObject;
var _utils = __webpack_require__(/*! ../utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");

/**
 * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
 * The resulting object can be used with "object[property]" to check if a property exists
 * @param {...object} sources a varargs parameter of source objects that will be merged
 * @returns {object}
 */

function createNewLookupObject() {
  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  return _utils.extend.apply(undefined, [Object.create(null)].concat(sources));
}

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js":
/*!******************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createProtoAccessControl = createProtoAccessControl;
exports.resultIsAllowed = resultIsAllowed;
exports.resetLoggedProperties = resetLoggedProperties;
// istanbul ignore next

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj['default'] = obj;
    return newObj;
  }
}
var _createNewLookupObject = __webpack_require__(/*! ./create-new-lookup-object */ "./node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js");
var _logger = __webpack_require__(/*! ../logger */ "./node_modules/handlebars/dist/cjs/handlebars/logger.js");
var logger = _interopRequireWildcard(_logger);
var loggedProperties = Object.create(null);
function createProtoAccessControl(runtimeOptions) {
  var defaultMethodWhiteList = Object.create(null);
  defaultMethodWhiteList['constructor'] = false;
  defaultMethodWhiteList['__defineGetter__'] = false;
  defaultMethodWhiteList['__defineSetter__'] = false;
  defaultMethodWhiteList['__lookupGetter__'] = false;
  var defaultPropertyWhiteList = Object.create(null);
  // eslint-disable-next-line no-proto
  defaultPropertyWhiteList['__proto__'] = false;
  return {
    properties: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
      defaultValue: runtimeOptions.allowProtoPropertiesByDefault
    },
    methods: {
      whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
      defaultValue: runtimeOptions.allowProtoMethodsByDefault
    }
  };
}
function resultIsAllowed(result, protoAccessControl, propertyName) {
  if (typeof result === 'function') {
    return checkWhiteList(protoAccessControl.methods, propertyName);
  } else {
    return checkWhiteList(protoAccessControl.properties, propertyName);
  }
}
function checkWhiteList(protoAccessControlForType, propertyName) {
  if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
    return protoAccessControlForType.whitelist[propertyName] === true;
  }
  if (protoAccessControlForType.defaultValue !== undefined) {
    return protoAccessControlForType.defaultValue;
  }
  logUnexpecedPropertyAccessOnce(propertyName);
  return false;
}
function logUnexpecedPropertyAccessOnce(propertyName) {
  if (loggedProperties[propertyName] !== true) {
    loggedProperties[propertyName] = true;
    logger.log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
  }
}
function resetLoggedProperties() {
  Object.keys(loggedProperties).forEach(function (propertyName) {
    delete loggedProperties[propertyName];
  });
}

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.wrapHelper = wrapHelper;
function wrapHelper(helper, transformOptionsFn) {
  if (typeof helper !== 'function') {
    // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
    // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
    return helper;
  }
  var wrapper = function wrapper() /* dynamic arguments */{
    var options = arguments[arguments.length - 1];
    arguments[arguments.length - 1] = transformOptionsFn(options);
    return helper.apply(this, arguments);
  };
  return wrapper;
}

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/logger.js":
/*!***************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/logger.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',
  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }
    return level;
  },
  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);
    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      // eslint-disable-next-line no-console
      if (!console[method]) {
        method = 'log';
      }
      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }
      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports["default"] = logger;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js":
/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/no-conflict.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : window,
    $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/runtime.js":
/*!****************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/runtime.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}

// istanbul ignore next

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }
    newObj['default'] = obj;
    return newObj;
  }
}
var _utils = __webpack_require__(/*! ./utils */ "./node_modules/handlebars/dist/cjs/handlebars/utils.js");
var Utils = _interopRequireWildcard(_utils);
var _exception = __webpack_require__(/*! ./exception */ "./node_modules/handlebars/dist/cjs/handlebars/exception.js");
var _exception2 = _interopRequireDefault(_exception);
var _base = __webpack_require__(/*! ./base */ "./node_modules/handlebars/dist/cjs/handlebars/base.js");
var _helpers = __webpack_require__(/*! ./helpers */ "./node_modules/handlebars/dist/cjs/handlebars/helpers.js");
var _internalWrapHelper = __webpack_require__(/*! ./internal/wrapHelper */ "./node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js");
var _internalProtoAccess = __webpack_require__(/*! ./internal/proto-access */ "./node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js");
function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
    currentRevision = _base.COMPILER_REVISION;
  if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
    return;
  }
  if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
    var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
      compilerVersions = _base.REVISION_CHANGES[compilerRevision];
    throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
  } else {
    // Use the embedded version info since the runtime doesn't know about this revision yet
    throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
  }
}
function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + _typeof(templateSpec));
  }
  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as pseudo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
  var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }
    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var extendedOptions = Utils.extend({}, options, {
      hooks: this.hooks,
      protoAccessControl: this.protoAccessControl
    });
    var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, extendedOptions);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }
          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name, loc) {
      if (!obj || !(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj, {
          loc: loc
        });
      }
      return container.lookupProperty(obj, name);
    },
    lookupProperty: function lookupProperty(parent, propertyName) {
      var result = parent[propertyName];
      if (result == null) {
        return result;
      }
      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
        return result;
      }
      if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
        return result;
      }
      return undefined;
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        var result = depths[i] && container.lookupProperty(depths[i], name);
        if (result != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },
    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
        fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },
    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    mergeIfNeeded: function mergeIfNeeded(param, common) {
      var obj = param || common;
      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }
      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),
    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };
  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var data = options.data;
    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
      blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }
    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;
  ret._setup = function (options) {
    if (!options.partial) {
      var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
      wrapHelpersToPassLookupProperty(mergedHelpers, container);
      container.helpers = mergedHelpers;
      if (templateSpec.usePartial) {
        // Use mergeIfNeeded here to prevent compiling global partials multiple times
        container.partials = container.mergeIfNeeded(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = Utils.extend({}, env.decorators, options.decorators);
      }
      container.hooks = {};
      container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
      var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
      _helpers.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
      _helpers.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
    } else {
      container.protoAccessControl = options.protoAccessControl; // internal option
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
      container.hooks = options.hooks;
    }
  };
  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }
    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}
function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }
    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }
  prog = executeDecorators(fn, prog, container, depths, data, blockParams);
  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

/**
 * This is currently part of the official API, therefore implementation details should not be changed.
 */

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}
function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }
  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }
  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }
  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}
function noop() {
  return '';
}
function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}
function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}
function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
  Object.keys(mergedHelpers).forEach(function (helperName) {
    var helper = mergedHelpers[helperName];
    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
  });
}
function passLookupPropertyOption(helper, container) {
  var lookupProperty = container.lookupProperty;
  return _internalWrapHelper.wrapHelper(helper, function (options) {
    return Utils.extend({
      lookupProperty: lookupProperty
    }, options);
  });
}

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/safe-string.js":
/*!********************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/safe-string.js ***!
  \********************************************************************/
/***/ ((module, exports) => {

"use strict";
// Build out our basic SafeString type


exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}
SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};
exports["default"] = SafeString;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/handlebars/dist/cjs/handlebars/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/handlebars/dist/cjs/handlebars/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};
var badChars = /[&<>"'`=]/g,
  possible = /[&<>"'`=]/;
function escapeChar(chr) {
  return escape[chr];
}
function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }
  return obj;
}
var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function isFunction(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && _typeof(value) === 'object' ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}
function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }
  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}
function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}
function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}
function blockParams(params, ids) {
  params.path = ids;
  return params;
}
function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}

/***/ }),

/***/ "./node_modules/handlebars/runtime.js":
/*!********************************************!*\
  !*** ./node_modules/handlebars/runtime.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = __webpack_require__(/*! ./dist/cjs/handlebars.runtime */ "./node_modules/handlebars/dist/cjs/handlebars.runtime.js")["default"];

/***/ }),

/***/ "./node_modules/papaparse/papaparse.min.js":
/*!*************************************************!*\
  !*** ./node_modules/papaparse/papaparse.min.js ***!
  \*************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/* @license
Papa Parse
v5.3.2
https://github.com/mholt/PapaParse
License: MIT
*/
!function (e, t) {
   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
}(this, function s() {
  "use strict";

  var f = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f ? f : {};
  var n = !f.document && !!f.postMessage,
    o = n && /blob:/i.test((f.location || {}).protocol),
    a = {},
    h = 0,
    b = {
      parse: function parse(e, t) {
        var i = (t = t || {}).dynamicTyping || !1;
        M(i) && (t.dynamicTypingFunction = i, i = {});
        if (t.dynamicTyping = i, t.transform = !!M(t.transform) && t.transform, t.worker && b.WORKERS_SUPPORTED) {
          var r = function () {
            if (!b.WORKERS_SUPPORTED) return !1;
            var e = (i = f.URL || f.webkitURL || null, r = s.toString(), b.BLOB_URL || (b.BLOB_URL = i.createObjectURL(new Blob(["(", r, ")();"], {
                type: "text/javascript"
              })))),
              t = new f.Worker(e);
            var i, r;
            return t.onmessage = _, t.id = h++, a[t.id] = t;
          }();
          return r.userStep = t.step, r.userChunk = t.chunk, r.userComplete = t.complete, r.userError = t.error, t.step = M(t.step), t.chunk = M(t.chunk), t.complete = M(t.complete), t.error = M(t.error), delete t.worker, void r.postMessage({
            input: e,
            config: t,
            workerId: r.id
          });
        }
        var n = null;
        b.NODE_STREAM_INPUT, "string" == typeof e ? n = t.download ? new l(t) : new p(t) : !0 === e.readable && M(e.read) && M(e.on) ? n = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n = new c(t));
        return n.stream(e);
      },
      unparse: function unparse(e, t) {
        var n = !1,
          _ = !0,
          m = ",",
          y = "\r\n",
          s = '"',
          a = s + s,
          i = !1,
          r = null,
          o = !1;
        !function () {
          if ("object" != _typeof(t)) return;
          "string" != typeof t.delimiter || b.BAD_DELIMITERS.filter(function (e) {
            return -1 !== t.delimiter.indexOf(e);
          }).length || (m = t.delimiter);
          ("boolean" == typeof t.quotes || "function" == typeof t.quotes || Array.isArray(t.quotes)) && (n = t.quotes);
          "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (i = t.skipEmptyLines);
          "string" == typeof t.newline && (y = t.newline);
          "string" == typeof t.quoteChar && (s = t.quoteChar);
          "boolean" == typeof t.header && (_ = t.header);
          if (Array.isArray(t.columns)) {
            if (0 === t.columns.length) throw new Error("Option columns is empty");
            r = t.columns;
          }
          void 0 !== t.escapeChar && (a = t.escapeChar + s);
          ("boolean" == typeof t.escapeFormulae || t.escapeFormulae instanceof RegExp) && (o = t.escapeFormulae instanceof RegExp ? t.escapeFormulae : /^[=+\-@\t\r].*$/);
        }();
        var h = new RegExp(j(s), "g");
        "string" == typeof e && (e = JSON.parse(e));
        if (Array.isArray(e)) {
          if (!e.length || Array.isArray(e[0])) return u(null, e, i);
          if ("object" == _typeof(e[0])) return u(r || Object.keys(e[0]), e, i);
        } else if ("object" == _typeof(e)) return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || r), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == _typeof(e.data[0]) ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == _typeof(e.data[0]) || (e.data = [e.data])), u(e.fields || [], e.data || [], i);
        throw new Error("Unable to serialize unrecognized input");
        function u(e, t, i) {
          var r = "";
          "string" == typeof e && (e = JSON.parse(e)), "string" == typeof t && (t = JSON.parse(t));
          var n = Array.isArray(e) && 0 < e.length,
            s = !Array.isArray(t[0]);
          if (n && _) {
            for (var a = 0; a < e.length; a++) 0 < a && (r += m), r += v(e[a], a);
            0 < t.length && (r += y);
          }
          for (var o = 0; o < t.length; o++) {
            var h = n ? e.length : t[o].length,
              u = !1,
              f = n ? 0 === Object.keys(t[o]).length : 0 === t[o].length;
            if (i && !n && (u = "greedy" === i ? "" === t[o].join("").trim() : 1 === t[o].length && 0 === t[o][0].length), "greedy" === i && n) {
              for (var d = [], l = 0; l < h; l++) {
                var c = s ? e[l] : l;
                d.push(t[o][c]);
              }
              u = "" === d.join("").trim();
            }
            if (!u) {
              for (var p = 0; p < h; p++) {
                0 < p && !f && (r += m);
                var g = n && s ? e[p] : p;
                r += v(t[o][g], p);
              }
              o < t.length - 1 && (!i || 0 < h && !f) && (r += y);
            }
          }
          return r;
        }
        function v(e, t) {
          if (null == e) return "";
          if (e.constructor === Date) return JSON.stringify(e).slice(1, 25);
          var i = !1;
          o && "string" == typeof e && o.test(e) && (e = "'" + e, i = !0);
          var r = e.toString().replace(h, a);
          return (i = i || !0 === n || "function" == typeof n && n(e, t) || Array.isArray(n) && n[t] || function (e, t) {
            for (var i = 0; i < t.length; i++) if (-1 < e.indexOf(t[i])) return !0;
            return !1;
          }(r, b.BAD_DELIMITERS) || -1 < r.indexOf(m) || " " === r.charAt(0) || " " === r.charAt(r.length - 1)) ? s + r + s : r;
        }
      }
    };
  if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n && !!f.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = i, b.NetworkStreamer = l, b.FileStreamer = c, b.StringStreamer = p, b.ReadableStreamStreamer = g, f.jQuery) {
    var d = f.jQuery;
    d.fn.parse = function (o) {
      var i = o.config || {},
        h = [];
      return this.each(function (e) {
        if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && f.FileReader) || !this.files || 0 === this.files.length) return !0;
        for (var t = 0; t < this.files.length; t++) h.push({
          file: this.files[t],
          inputElem: this,
          instanceConfig: d.extend({}, i)
        });
      }), e(), this;
      function e() {
        if (0 !== h.length) {
          var e,
            t,
            i,
            r,
            n = h[0];
          if (M(o.before)) {
            var s = o.before(n.file, n.inputElem);
            if ("object" == _typeof(s)) {
              if ("abort" === s.action) return e = "AbortError", t = n.file, i = n.inputElem, r = s.reason, void (M(o.error) && o.error({
                name: e
              }, t, i, r));
              if ("skip" === s.action) return void u();
              "object" == _typeof(s.config) && (n.instanceConfig = d.extend(n.instanceConfig, s.config));
            } else if ("skip" === s) return void u();
          }
          var a = n.instanceConfig.complete;
          n.instanceConfig.complete = function (e) {
            M(a) && a(e, n.file, n.inputElem), u();
          }, b.parse(n.file, n.instanceConfig);
        } else M(o.complete) && o.complete();
      }
      function u() {
        h.splice(0, 1), e();
      }
    };
  }
  function u(e) {
    this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = {
      data: [],
      errors: [],
      meta: {}
    }, function (e) {
      var t = w(e);
      t.chunkSize = parseInt(t.chunkSize), e.step || e.chunk || (t.chunkSize = null);
      this._handle = new i(t), (this._handle.streamer = this)._config = t;
    }.call(this, e), this.parseChunk = function (e, t) {
      if (this.isFirstChunk && M(this._config.beforeFirstChunk)) {
        var i = this._config.beforeFirstChunk(e);
        void 0 !== i && (e = i);
      }
      this.isFirstChunk = !1, this._halted = !1;
      var r = this._partialLine + e;
      this._partialLine = "";
      var n = this._handle.parse(r, this._baseIndex, !this._finished);
      if (!this._handle.paused() && !this._handle.aborted()) {
        var s = n.meta.cursor;
        this._finished || (this._partialLine = r.substring(s - this._baseIndex), this._baseIndex = s), n && n.data && (this._rowCount += n.data.length);
        var a = this._finished || this._config.preview && this._rowCount >= this._config.preview;
        if (o) f.postMessage({
          results: n,
          workerId: b.WORKER_ID,
          finished: a
        });else if (M(this._config.chunk) && !t) {
          if (this._config.chunk(n, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
          n = void 0, this._completeResults = void 0;
        }
        return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n.data), this._completeResults.errors = this._completeResults.errors.concat(n.errors), this._completeResults.meta = n.meta), this._completed || !a || !M(this._config.complete) || n && n.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), a || n && n.meta.paused || this._nextChunk(), n;
      }
      this._halted = !0;
    }, this._sendError = function (e) {
      M(this._config.error) ? this._config.error(e) : o && this._config.error && f.postMessage({
        workerId: b.WORKER_ID,
        error: e,
        finished: !1
      });
    };
  }
  function l(e) {
    var r;
    (e = e || {}).chunkSize || (e.chunkSize = b.RemoteChunkSize), u.call(this, e), this._nextChunk = n ? function () {
      this._readChunk(), this._chunkLoaded();
    } : function () {
      this._readChunk();
    }, this.stream = function (e) {
      this._input = e, this._nextChunk();
    }, this._readChunk = function () {
      if (this._finished) this._chunkLoaded();else {
        if (r = new XMLHttpRequest(), this._config.withCredentials && (r.withCredentials = this._config.withCredentials), n || (r.onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)), r.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n), this._config.downloadRequestHeaders) {
          var e = this._config.downloadRequestHeaders;
          for (var t in e) r.setRequestHeader(t, e[t]);
        }
        if (this._config.chunkSize) {
          var i = this._start + this._config.chunkSize - 1;
          r.setRequestHeader("Range", "bytes=" + this._start + "-" + i);
        }
        try {
          r.send(this._config.downloadRequestBody);
        } catch (e) {
          this._chunkError(e.message);
        }
        n && 0 === r.status && this._chunkError();
      }
    }, this._chunkLoaded = function () {
      4 === r.readyState && (r.status < 200 || 400 <= r.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : r.responseText.length, this._finished = !this._config.chunkSize || this._start >= function (e) {
        var t = e.getResponseHeader("Content-Range");
        if (null === t) return -1;
        return parseInt(t.substring(t.lastIndexOf("/") + 1));
      }(r), this.parseChunk(r.responseText)));
    }, this._chunkError = function (e) {
      var t = r.statusText || e;
      this._sendError(new Error(t));
    };
  }
  function c(e) {
    var r, n;
    (e = e || {}).chunkSize || (e.chunkSize = b.LocalChunkSize), u.call(this, e);
    var s = "undefined" != typeof FileReader;
    this.stream = function (e) {
      this._input = e, n = e.slice || e.webkitSlice || e.mozSlice, s ? ((r = new FileReader()).onload = v(this._chunkLoaded, this), r.onerror = v(this._chunkError, this)) : r = new FileReaderSync(), this._nextChunk();
    }, this._nextChunk = function () {
      this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
    }, this._readChunk = function () {
      var e = this._input;
      if (this._config.chunkSize) {
        var t = Math.min(this._start + this._config.chunkSize, this._input.size);
        e = n.call(e, this._start, t);
      }
      var i = r.readAsText(e, this._config.encoding);
      s || this._chunkLoaded({
        target: {
          result: i
        }
      });
    }, this._chunkLoaded = function (e) {
      this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e.target.result);
    }, this._chunkError = function () {
      this._sendError(r.error);
    };
  }
  function p(e) {
    var i;
    u.call(this, e = e || {}), this.stream = function (e) {
      return i = e, this._nextChunk();
    }, this._nextChunk = function () {
      if (!this._finished) {
        var e,
          t = this._config.chunkSize;
        return t ? (e = i.substring(0, t), i = i.substring(t)) : (e = i, i = ""), this._finished = !i, this.parseChunk(e);
      }
    };
  }
  function g(e) {
    u.call(this, e = e || {});
    var t = [],
      i = !0,
      r = !1;
    this.pause = function () {
      u.prototype.pause.apply(this, arguments), this._input.pause();
    }, this.resume = function () {
      u.prototype.resume.apply(this, arguments), this._input.resume();
    }, this.stream = function (e) {
      this._input = e, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
    }, this._checkIsFinished = function () {
      r && 1 === t.length && (this._finished = !0);
    }, this._nextChunk = function () {
      this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : i = !0;
    }, this._streamData = v(function (e) {
      try {
        t.push("string" == typeof e ? e : e.toString(this._config.encoding)), i && (i = !1, this._checkIsFinished(), this.parseChunk(t.shift()));
      } catch (e) {
        this._streamError(e);
      }
    }, this), this._streamError = v(function (e) {
      this._streamCleanUp(), this._sendError(e);
    }, this), this._streamEnd = v(function () {
      this._streamCleanUp(), r = !0, this._streamData("");
    }, this), this._streamCleanUp = v(function () {
      this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
    }, this);
  }
  function i(m) {
    var a,
      o,
      h,
      r = Math.pow(2, 53),
      n = -r,
      s = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,
      u = /^(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))$/,
      t = this,
      i = 0,
      f = 0,
      d = !1,
      e = !1,
      l = [],
      c = {
        data: [],
        errors: [],
        meta: {}
      };
    if (M(m.step)) {
      var p = m.step;
      m.step = function (e) {
        if (c = e, _()) g();else {
          if (g(), 0 === c.data.length) return;
          i += e.data.length, m.preview && i > m.preview ? o.abort() : (c.data = c.data[0], p(c, t));
        }
      };
    }
    function y(e) {
      return "greedy" === m.skipEmptyLines ? "" === e.join("").trim() : 1 === e.length && 0 === e[0].length;
    }
    function g() {
      return c && h && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), h = !1), m.skipEmptyLines && (c.data = c.data.filter(function (e) {
        return !y(e);
      })), _() && function () {
        if (!c) return;
        function e(e, t) {
          M(m.transformHeader) && (e = m.transformHeader(e, t)), l.push(e);
        }
        if (Array.isArray(c.data[0])) {
          for (var t = 0; _() && t < c.data.length; t++) c.data[t].forEach(e);
          c.data.splice(0, 1);
        } else c.data.forEach(e);
      }(), function () {
        if (!c || !m.header && !m.dynamicTyping && !m.transform) return c;
        function e(e, t) {
          var i,
            r = m.header ? {} : [];
          for (i = 0; i < e.length; i++) {
            var n = i,
              s = e[i];
            m.header && (n = i >= l.length ? "__parsed_extra" : l[i]), m.transform && (s = m.transform(s, n)), s = v(n, s), "__parsed_extra" === n ? (r[n] = r[n] || [], r[n].push(s)) : r[n] = s;
          }
          return m.header && (i > l.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l.length + " fields but parsed " + i, f + t) : i < l.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l.length + " fields but parsed " + i, f + t)), r;
        }
        var t = 1;
        !c.data.length || Array.isArray(c.data[0]) ? (c.data = c.data.map(e), t = c.data.length) : c.data = e(c.data, 0);
        m.header && c.meta && (c.meta.fields = l);
        return f += t, c;
      }();
    }
    function _() {
      return m.header && 0 === l.length;
    }
    function v(e, t) {
      return i = e, m.dynamicTypingFunction && void 0 === m.dynamicTyping[i] && (m.dynamicTyping[i] = m.dynamicTypingFunction(i)), !0 === (m.dynamicTyping[i] || m.dynamicTyping) ? "true" === t || "TRUE" === t || "false" !== t && "FALSE" !== t && (function (e) {
        if (s.test(e)) {
          var t = parseFloat(e);
          if (n < t && t < r) return !0;
        }
        return !1;
      }(t) ? parseFloat(t) : u.test(t) ? new Date(t) : "" === t ? null : t) : t;
      var i;
    }
    function k(e, t, i, r) {
      var n = {
        type: e,
        code: t,
        message: i
      };
      void 0 !== r && (n.row = r), c.errors.push(n);
    }
    this.parse = function (e, t, i) {
      var r = m.quoteChar || '"';
      if (m.newline || (m.newline = function (e, t) {
        e = e.substring(0, 1048576);
        var i = new RegExp(j(t) + "([^]*?)" + j(t), "gm"),
          r = (e = e.replace(i, "")).split("\r"),
          n = e.split("\n"),
          s = 1 < n.length && n[0].length < r[0].length;
        if (1 === r.length || s) return "\n";
        for (var a = 0, o = 0; o < r.length; o++) "\n" === r[o][0] && a++;
        return a >= r.length / 2 ? "\r\n" : "\r";
      }(e, r)), h = !1, m.delimiter) M(m.delimiter) && (m.delimiter = m.delimiter(e), c.meta.delimiter = m.delimiter);else {
        var n = function (e, t, i, r, n) {
          var s, a, o, h;
          n = n || [",", "\t", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
          for (var u = 0; u < n.length; u++) {
            var f = n[u],
              d = 0,
              l = 0,
              c = 0;
            o = void 0;
            for (var p = new E({
                comments: r,
                delimiter: f,
                newline: t,
                preview: 10
              }).parse(e), g = 0; g < p.data.length; g++) if (i && y(p.data[g])) c++;else {
              var _ = p.data[g].length;
              l += _, void 0 !== o ? 0 < _ && (d += Math.abs(_ - o), o = _) : o = _;
            }
            0 < p.data.length && (l /= p.data.length - c), (void 0 === a || d <= a) && (void 0 === h || h < l) && 1.99 < l && (a = d, s = f, h = l);
          }
          return {
            successful: !!(m.delimiter = s),
            bestDelimiter: s
          };
        }(e, m.newline, m.skipEmptyLines, m.comments, m.delimitersToGuess);
        n.successful ? m.delimiter = n.bestDelimiter : (h = !0, m.delimiter = b.DefaultDelimiter), c.meta.delimiter = m.delimiter;
      }
      var s = w(m);
      return m.preview && m.header && s.preview++, a = e, o = new E(s), c = o.parse(a, t, i), g(), d ? {
        meta: {
          paused: !0
        }
      } : c || {
        meta: {
          paused: !1
        }
      };
    }, this.paused = function () {
      return d;
    }, this.pause = function () {
      d = !0, o.abort(), a = M(m.chunk) ? "" : a.substring(o.getCharIndex());
    }, this.resume = function () {
      t.streamer._halted ? (d = !1, t.streamer.parseChunk(a, !0)) : setTimeout(t.resume, 3);
    }, this.aborted = function () {
      return e;
    }, this.abort = function () {
      e = !0, o.abort(), c.meta.aborted = !0, M(m.complete) && m.complete(c), a = "";
    };
  }
  function j(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function E(e) {
    var S,
      O = (e = e || {}).delimiter,
      x = e.newline,
      I = e.comments,
      T = e.step,
      D = e.preview,
      A = e.fastMode,
      L = S = void 0 === e.quoteChar || null === e.quoteChar ? '"' : e.quoteChar;
    if (void 0 !== e.escapeChar && (L = e.escapeChar), ("string" != typeof O || -1 < b.BAD_DELIMITERS.indexOf(O)) && (O = ","), I === O) throw new Error("Comment character same as delimiter");
    !0 === I ? I = "#" : ("string" != typeof I || -1 < b.BAD_DELIMITERS.indexOf(I)) && (I = !1), "\n" !== x && "\r" !== x && "\r\n" !== x && (x = "\n");
    var F = 0,
      z = !1;
    this.parse = function (r, t, i) {
      if ("string" != typeof r) throw new Error("Input must be a string");
      var n = r.length,
        e = O.length,
        s = x.length,
        a = I.length,
        o = M(T),
        h = [],
        u = [],
        f = [],
        d = F = 0;
      if (!r) return C();
      if (A || !1 !== A && -1 === r.indexOf(S)) {
        for (var l = r.split(x), c = 0; c < l.length; c++) {
          if (f = l[c], F += f.length, c !== l.length - 1) F += x.length;else if (i) return C();
          if (!I || f.substring(0, a) !== I) {
            if (o) {
              if (h = [], k(f.split(O)), R(), z) return C();
            } else k(f.split(O));
            if (D && D <= c) return h = h.slice(0, D), C(!0);
          }
        }
        return C();
      }
      for (var p = r.indexOf(O, F), g = r.indexOf(x, F), _ = new RegExp(j(L) + j(S), "g"), m = r.indexOf(S, F);;) if (r[F] !== S) {
        if (I && 0 === f.length && r.substring(F, F + a) === I) {
          if (-1 === g) return C();
          F = g + s, g = r.indexOf(x, F), p = r.indexOf(O, F);
        } else if (-1 !== p && (p < g || -1 === g)) f.push(r.substring(F, p)), F = p + e, p = r.indexOf(O, F);else {
          if (-1 === g) break;
          if (f.push(r.substring(F, g)), w(g + s), o && (R(), z)) return C();
          if (D && h.length >= D) return C(!0);
        }
      } else for (m = F, F++;;) {
        if (-1 === (m = r.indexOf(S, m + 1))) return i || u.push({
          type: "Quotes",
          code: "MissingQuotes",
          message: "Quoted field unterminated",
          row: h.length,
          index: F
        }), E();
        if (m === n - 1) return E(r.substring(F, m).replace(_, S));
        if (S !== L || r[m + 1] !== L) {
          if (S === L || 0 === m || r[m - 1] !== L) {
            -1 !== p && p < m + 1 && (p = r.indexOf(O, m + 1)), -1 !== g && g < m + 1 && (g = r.indexOf(x, m + 1));
            var y = b(-1 === g ? p : Math.min(p, g));
            if (r.substr(m + 1 + y, e) === O) {
              f.push(r.substring(F, m).replace(_, S)), r[F = m + 1 + y + e] !== S && (m = r.indexOf(S, F)), p = r.indexOf(O, F), g = r.indexOf(x, F);
              break;
            }
            var v = b(g);
            if (r.substring(m + 1 + v, m + 1 + v + s) === x) {
              if (f.push(r.substring(F, m).replace(_, S)), w(m + 1 + v + s), p = r.indexOf(O, F), m = r.indexOf(S, F), o && (R(), z)) return C();
              if (D && h.length >= D) return C(!0);
              break;
            }
            u.push({
              type: "Quotes",
              code: "InvalidQuotes",
              message: "Trailing quote on quoted field is malformed",
              row: h.length,
              index: F
            }), m++;
          }
        } else m++;
      }
      return E();
      function k(e) {
        h.push(e), d = F;
      }
      function b(e) {
        var t = 0;
        if (-1 !== e) {
          var i = r.substring(m + 1, e);
          i && "" === i.trim() && (t = i.length);
        }
        return t;
      }
      function E(e) {
        return i || (void 0 === e && (e = r.substring(F)), f.push(e), F = n, k(f), o && R()), C();
      }
      function w(e) {
        F = e, k(f), f = [], g = r.indexOf(x, F);
      }
      function C(e) {
        return {
          data: h,
          errors: u,
          meta: {
            delimiter: O,
            linebreak: x,
            aborted: z,
            truncated: !!e,
            cursor: d + (t || 0)
          }
        };
      }
      function R() {
        T(C()), h = [], u = [];
      }
    }, this.abort = function () {
      z = !0;
    }, this.getCharIndex = function () {
      return F;
    };
  }
  function _(e) {
    var t = e.data,
      i = a[t.workerId],
      r = !1;
    if (t.error) i.userError(t.error, t.file);else if (t.results && t.results.data) {
      var n = {
        abort: function abort() {
          r = !0, m(t.workerId, {
            data: [],
            errors: [],
            meta: {
              aborted: !0
            }
          });
        },
        pause: y,
        resume: y
      };
      if (M(i.userStep)) {
        for (var s = 0; s < t.results.data.length && (i.userStep({
          data: t.results.data[s],
          errors: t.results.errors,
          meta: t.results.meta
        }, n), !r); s++);
        delete t.results;
      } else M(i.userChunk) && (i.userChunk(t.results, n, t.file), delete t.results);
    }
    t.finished && !r && m(t.workerId, t.results);
  }
  function m(e, t) {
    var i = a[e];
    M(i.userComplete) && i.userComplete(t), i.terminate(), delete a[e];
  }
  function y() {
    throw new Error("Not implemented.");
  }
  function w(e) {
    if ("object" != _typeof(e) || null === e) return e;
    var t = Array.isArray(e) ? [] : {};
    for (var i in e) t[i] = w(e[i]);
    return t;
  }
  function v(e, t) {
    return function () {
      e.apply(t, arguments);
    };
  }
  function M(e) {
    return "function" == typeof e;
  }
  return o && (f.onmessage = function (e) {
    var t = e.data;
    void 0 === b.WORKER_ID && t && (b.WORKER_ID = t.workerId);
    if ("string" == typeof t.input) f.postMessage({
      workerId: b.WORKER_ID,
      results: b.parse(t.input, t.config),
      finished: !0
    });else if (f.File && t.input instanceof File || t.input instanceof Object) {
      var i = b.parse(t.input, t.config);
      i && f.postMessage({
        workerId: b.WORKER_ID,
        results: i,
        finished: !0
      });
    }
  }), (l.prototype = Object.create(u.prototype)).constructor = l, (c.prototype = Object.create(u.prototype)).constructor = c, (p.prototype = Object.create(p.prototype)).constructor = p, (g.prototype = Object.create(u.prototype)).constructor = g, b;
});

/***/ }),

/***/ "./src/components/c1-table/index.js":
/*!******************************************!*\
  !*** ./src/components/c1-table/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/utils */ "./src/libs/utils.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./template.hbs */ "./src/components/c1-table/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _row_template_hbs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./row-template.hbs */ "./src/components/c1-table/row-template.hbs");
/* harmony import */ var _row_template_hbs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_row_template_hbs__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _libs_form_to_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../libs/form-to-json */ "./src/libs/form-to-json.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var C1Table = /*#__PURE__*/function (_Component) {
  _inherits(C1Table, _Component);
  var _super = _createSuper(C1Table);
  function C1Table() {
    var _this;
    _classCallCheck(this, C1Table);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_1__.getDBManager)();
    _this._init();
    return _this;
  }
  _createClass(C1Table, [{
    key: "connectedCallback",
    value: function connectedCallback() {}
  }, {
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var labels, filterKey, title, parent, rowsHtmls, data, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // static props
              labels = this.getAttribute('labels').split(',');
              filterKey = this.getAttribute('filterKey');
              title = this.getAttribute('title'); // global props
              this.rowsKey = this.getAttribute('rowsKey');
              this.editEnabled = this.getAttribute('editEnabled');
              this.actionDisabled = this.getAttribute('actionDisabled');
              this.keys = this.getAttribute('keys').split(',');
              this.orderBy = this.getAttribute('orderBy');
              this.orderDir = this.getAttribute('orderDir') || 'asc';

              // get rows and generate
              parent = this._parent();
              _context.next = 12;
              return parent.getRows(this.rowsKey);
            case 12:
              this.rows = _context.sent;
              rowsHtmls = this._generateRows();
              data = {
                labels: labels,
                rowsHtmls: rowsHtmls,
                filterKey: filterKey,
                title: title,
                actionDisabled: this.actionDisabled
              }; // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_3___default()(data), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);
              this.tableBody = this._ref('tbody');
              this._addListeners();
            case 20:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "_addListeners",
    value: function _addListeners() {
      var _this2 = this;
      this._addListener('click', /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(event) {
          var tr, id, ok;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                if (event.target.matches('[ref=deleteRow]')) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return");
              case 2:
                tr = event.target.closest('tr');
                id = tr.dataset.id;
                _context2.next = 6;
                return _this2._parent().deleteRow(id, _this2.rowsKey);
              case 6:
                ok = _context2.sent;
                if (ok) {
                  tr.remove();
                  _this2._ref('count').innerHTML = _this2._ref('count').innerHTML - 1;
                }
              case 8:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      this._addListener('click', /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event) {
          var tr, id;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                if (event.target.matches('[ref=editRow]')) {
                  _context3.next = 2;
                  break;
                }
                return _context3.abrupt("return");
              case 2:
                tr = event.target.closest('tr');
                id = tr.dataset.id;
                _context3.next = 6;
                return _this2._parent().editRow(id, _this2.rowsKey);
              case 6:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
      this._addListener('submit', function (event) {
        event.preventDefault();
        _this2.currentFilter = (0,_libs_form_to_json__WEBPACK_IMPORTED_MODULE_5__.formToJSON)(event.target);
        (0,_libs_utils__WEBPACK_IMPORTED_MODULE_2__.emptyElement)(_this2.tableBody);
        var rowsHtmlsJoin = _this2._generateRows().join('');
        _this2.tableBody.innerHTML = rowsHtmlsJoin;
      }, 'filter');
    }
  }, {
    key: "_rowMap",
    value: function _rowMap(item) {
      var res = {
        id: item.id,
        data: [],
        editEnabled: this.editEnabled,
        actionDisabled: this.actionDisabled
      };
      var _iterator = _createForOfIteratorHelper(this.keys),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          if (key == 'start') res.data.push((0,_libs_utils__WEBPACK_IMPORTED_MODULE_2__.dateToStr)(item[key]));else if (key == 'time' || key == 'end' || key == 'assignedTime') res.data.push((0,_libs_utils__WEBPACK_IMPORTED_MODULE_2__.dateToStr)(item[key], true));else if (key == 'diff') res.data.push((0,_libs_utils__WEBPACK_IMPORTED_MODULE_2__.dateToDiffTimeStr)(item[key], true));else res.data.push(item[key]);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return res;
    }
  }, {
    key: "_generateRows",
    value: function _generateRows() {
      var _this3 = this;
      var finalRows = this.rows;
      // filter data
      if (this.currentFilter) {
        var _loop = function _loop() {
          var key = _Object$keys[_i];
          finalRows = finalRows.filter(function (item) {
            var regex = new RegExp(_this3.currentFilter[key], 'i');
            if (regex.test(item[key])) return true;
            return false;
          });
        };
        for (var _i = 0, _Object$keys = Object.keys(this.currentFilter); _i < _Object$keys.length; _i++) {
          _loop();
        }
      }

      // order data
      if (this.orderBy) {
        finalRows.sort(function (one, two) {
          var a = _this3.orderDir == 'asc' ? one : two;
          var b = _this3.orderDir == 'asc' ? two : one;
          if (a[_this3.orderBy] === undefined) {
            return 1;
          }
          if (b[_this3.orderBy] === undefined) {
            return -1;
          }
          if (a[_this3.orderBy] < b[_this3.orderBy]) {
            return -1;
          }
          if (a[_this3.orderBy] >= b[_this3.orderBy]) {
            return 1;
          }
        });
      }

      // map for layout
      finalRows = finalRows.map(function (item) {
        return _this3._rowMap(item);
      });

      // render rows
      var rowsHtmls = [];
      var _iterator2 = _createForOfIteratorHelper(finalRows),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var row = _step2.value;
          rowsHtmls.push(_row_template_hbs__WEBPACK_IMPORTED_MODULE_4___default()(row));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return rowsHtmls;
    }
  }, {
    key: "reload",
    value: function reload() {
      (0,_libs_utils__WEBPACK_IMPORTED_MODULE_2__.emptyElement)(this);
      this._init();
    }
  }, {
    key: "addRow",
    value: function addRow(row) {
      // add to rows
      var mappedRow = this._rowMap(row);
      this.rows.unshift(mappedRow);

      // ad to html
      var parser = new DOMParser();
      var htmlDoc = parser.parseFromString('<table>' + _row_template_hbs__WEBPACK_IMPORTED_MODULE_4___default()(mappedRow) + '</table>', 'text/html');
      this.tableBody.insertBefore(htmlDoc.body.querySelector('tr'), this.tableBody.firstElementChild);
      this._ref('count').innerHTML = parseInt(this._ref('count').innerHTML) + 1;
    }
  }]);
  return C1Table;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (C1Table);

/***/ }),

/***/ "./src/components/c2-nav/index.js":
/*!****************************************!*\
  !*** ./src/components/c2-nav/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _libs_store_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/store-manager */ "./src/libs/store-manager.js");
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs/utils */ "./src/libs/utils.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./template.hbs */ "./src/components/c2-nav/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_4__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var C2Nav = /*#__PURE__*/function (_Component) {
  _inherits(C2Nav, _Component);
  var _super = _createSuper(C2Nav);
  function C2Nav() {
    var _this;
    _classCallCheck(this, C2Nav);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_1__.getDBManager)();
    _this._init();
    _this._addStoreListener('psChange', function () {
      _this.reload();
    });
    return _this;
  }
  _createClass(C2Nav, [{
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this2 = this;
        var data, selectedRace, ps, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              data = {};
              selectedRace = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_2__.getStoreManager)().get('selectedRace');
              this.raceId = selectedRace.race;
              _context.next = 5;
              return this.dbManager.getAllPS(this.raceId);
            case 5:
              ps = _context.sent;
              data['ps'] = ps;

              // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_4___default()(data), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);

              // add listener to buttons
              this._addListener('click', function (event) {
                var button = event.currentTarget;
                _this2._emit('selectedPage', {
                  destination: button.dataset.destination,
                  title: button.dataset.title
                });
                _this2.checkActiveMenu();
              }, 'menuItem');

              //check active button
              this.checkActiveMenu();
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "reload",
    value: function reload() {
      (0,_libs_utils__WEBPACK_IMPORTED_MODULE_3__.emptyElement)(this);
      this._init();
    }
  }, {
    key: "checkActiveMenu",
    value: function checkActiveMenu() {
      var selectedPage = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_2__.getStoreManager)().get('selectedPage');
      var destination = (selectedPage === null || selectedPage === void 0 ? void 0 : selectedPage.destination) || 'dashboard';
      var menuItems = this._ref('menuItem', true);
      var _iterator = _createForOfIteratorHelper(menuItems),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          if (item.dataset.destination == destination) {
            item.classList.remove('text-gray-400');
            item.classList.remove('border-transparent');
            item.classList.add('text-gray-800');
            item.classList.add('border-gray-500');
          } else {
            item.classList.add('text-gray-400');
            item.classList.add('border-transparent');
            item.classList.remove('text-gray-800');
            item.classList.remove('border-gray-500');
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);
  return C2Nav;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (C2Nav);

/***/ }),

/***/ "./src/components/l1-app/index.js":
/*!****************************************!*\
  !*** ./src/components/l1-app/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.hbs */ "./src/components/l1-app/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/utils */ "./src/libs/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var L1App = /*#__PURE__*/function (_Component) {
  _inherits(L1App, _Component);
  var _super = _createSuper(L1App);
  function L1App() {
    var _this;
    _classCallCheck(this, L1App);
    _this = _super.call(this);

    // parse html
    var parser = new DOMParser();
    var htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_1___default()(), 'text/html');
    _this.appendChild(htmlDoc.body.firstElementChild);
    _this.content = _this._ref('content');
    _this._addListeners();
    return _this;
  }
  _createClass(L1App, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      var _this2 = this;
      console.log('start');
      setTimeout(function () {
        _this2.firstElementChild.classList.remove('opacity-0');
      }, 500);
    }
  }, {
    key: "_addListeners",
    value: function _addListeners() {
      var _this3 = this;
      this._addStoreListener('selectedRace', function (path, value) {
        (0,_libs_utils__WEBPACK_IMPORTED_MODULE_2__.emptyElement)(_this3.content);
        if (value.race) _this3.content.innerHTML = '<l2-main></l2-main>';else _this3.content.innerHTML = '<m0-racer></m0-racer>';
      });
    }
  }]);
  return L1App;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (L1App);

/***/ }),

/***/ "./src/components/l2-main/index.js":
/*!*****************************************!*\
  !*** ./src/components/l2-main/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.hbs */ "./src/components/l2-main/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs/utils */ "./src/libs/utils.js");
/* harmony import */ var _libs_store_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../libs/store-manager */ "./src/libs/store-manager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var L2Main = /*#__PURE__*/function (_Component) {
  _inherits(L2Main, _Component);
  var _super = _createSuper(L2Main);
  function L2Main() {
    var _this;
    _classCallCheck(this, L2Main);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_2__.getDBManager)();
    _this.storeManager = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_4__.getStoreManager)();
    _this._addStoreListeners();
    _this._init();
    return _this;
  }
  _createClass(L2Main, [{
    key: "_addStoreListeners",
    value: function _addStoreListeners() {
      var _this2 = this;
      this._addStoreListener('selectedPage', function (path, data) {
        (0,_libs_utils__WEBPACK_IMPORTED_MODULE_3__.emptyElement)(_this2.dashboardContent);
        var location = _this2._getLocation(data);
        _this2.dashboardContent.innerHTML = location.content;
        _this2.dashboardTitle.innerHTML = location.title;
      });
    }
  }, {
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this3 = this;
        var currentPage, data, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              currentPage = this.storeManager.get('selectedPage');
              data = {
                location: this._getLocation(currentPage)
              }; // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_1___default()(data), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);

              // get elements
              this.close = this._ref('closeRace');
              this.menuBtn = this._ref('menuBtn');
              this.drawerMenu = this._ref('drawerMenu');
              this.nav = this._ref('nav');
              this.dashboardContent = this._ref('dashboardContent');
              this.dashboardTitle = this._ref('dashboardTitle');
              this._addListener('click', function () {
                if (!_this3.drawerMenu.classList.contains('-left-80')) {
                  _this3.drawerMenu.classList.add('-left-80');
                } else {
                  _this3._emit('selectedRace', {});
                }
              }, this.close);
              this._addListener('click', function () {
                if (_this3.drawerMenu.classList.contains('-left-80')) {
                  _this3.drawerMenu.classList.remove('-left-80');
                } else {
                  _this3.drawerMenu.classList.add('-left-80');
                }
              }, 'menuBtn');
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "_getLocation",
    value: function _getLocation(currentPage) {
      if (!currentPage) return {
        title: 'Dashboard',
        content: '<m1-dashboard></m1-dashboard>'
      };
      if (currentPage.destination == 'race') return {
        title: currentPage.title,
        content: '<m2-race></m2-race>'
      };
      if (currentPage.destination == 'runner') return {
        title: currentPage.title,
        content: '<m3-runners></m3-runners>'
      };
      if (currentPage.destination.startsWith('ps-')) return {
        title: currentPage.title,
        content: '<m4-score></m4-score>'
      };
      return {
        title: 'Dashboard',
        content: '<m1-dashboard></m1-dashboard>'
      };
    }
  }]);
  return L2Main;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (L2Main);

/***/ }),

/***/ "./src/components/m0-racer/index.js":
/*!******************************************!*\
  !*** ./src/components/m0-racer/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.hbs */ "./src/components/m0-racer/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _assets_race_webp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../assets/race.webp */ "./src/assets/race.webp");
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var M0Racer = /*#__PURE__*/function (_Component) {
  _inherits(M0Racer, _Component);
  var _super = _createSuper(M0Racer);
  function M0Racer() {
    var _this;
    _classCallCheck(this, M0Racer);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_3__.getDBManager)();
    _this._init();
    return _this;
  }
  _createClass(M0Racer, [{
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var data, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = _assets_race_webp__WEBPACK_IMPORTED_MODULE_2__;
              _context.next = 3;
              return this.dbManager.getAllRace();
            case 3:
              _context.t1 = _context.sent;
              data = {
                img: _context.t0,
                options: _context.t1
              };
              // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_1___default()(data), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);

              // get elements
              this.formCreate = this._ref('createRace');
              this.formSelect = this._ref('selectRace');

              // add listeners
              this._addListeners();
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "_addListeners",
    value: function _addListeners() {
      var _this2 = this;
      this.formCreate.addEventListener('submit', /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(event) {
          var formData, raceName, id;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                event.preventDefault();
                formData = new FormData(event.target);
                raceName = formData.get('name');
                _context2.next = 5;
                return _this2.dbManager.createRace(raceName);
              case 5:
                id = _context2.sent;
                _this2._emit('selectedRace', {
                  race: id
                });
              case 7:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      this.formSelect.addEventListener('submit', function (event) {
        event.preventDefault();
        var formData = new FormData(event.target);
        var id = formData.get('name');
        _this2._emit('selectedRace', {
          race: id
        });
      });
    }
  }]);
  return M0Racer;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (M0Racer);

/***/ }),

/***/ "./src/components/m1-dashboard/index.js":
/*!**********************************************!*\
  !*** ./src/components/m1-dashboard/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _libs_form_to_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/form-to-json */ "./src/libs/form-to-json.js");
/* harmony import */ var _libs_store_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs/store-manager */ "./src/libs/store-manager.js");
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../libs/utils */ "./src/libs/utils.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./template.hbs */ "./src/components/m1-dashboard/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_5__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var M1Dashboard = /*#__PURE__*/function (_Component) {
  _inherits(M1Dashboard, _Component);
  var _super = _createSuper(M1Dashboard);
  function M1Dashboard() {
    var _this;
    _classCallCheck(this, M1Dashboard);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_1__.getDBManager)();
    _this._init();

    //add take event listener
    _this._addListener('take-event', function (event) {
      _this._newTime(event.detail.time);
    }, document.body);
    return _this;
  }
  _createClass(M1Dashboard, [{
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this2 = this;
        var selectedRace, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // load raceId
              selectedRace = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_3__.getStoreManager)().get('selectedRace');
              this.raceId = selectedRace.race;

              // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_5___default()({}), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);

              //get table
              this.timeTable = this._ref('timeTable');
              this.takeTable = this._ref('takeTable');
              this.assignTime = this._ref('assignTime');
              this._addListener('submit', function (event) {
                event.preventDefault();
                _this2._assignTime((0,_libs_form_to_json__WEBPACK_IMPORTED_MODULE_2__.formToJSON)(_this2.assignTime));
              }, this.assignTime);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "getRows",
    value: function () {
      var _getRows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(type) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(type == 'take')) {
                _context2.next = 4;
                break;
              }
              _context2.next = 3;
              return this.dbManager.getAllTakeJoin(this.raceId);
            case 3:
              return _context2.abrupt("return", _context2.sent);
            case 4:
              if (!(type == 'time')) {
                _context2.next = 8;
                break;
              }
              _context2.next = 7;
              return this.dbManager.getAllTimeJoin(this.raceId, true);
            case 7:
              return _context2.abrupt("return", _context2.sent);
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getRows(_x) {
        return _getRows.apply(this, arguments);
      }
      return getRows;
    }()
  }, {
    key: "deleteRow",
    value: function () {
      var _deleteRow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id, type) {
        var time;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(type == 'time')) {
                _context3.next = 10;
                break;
              }
              _context3.next = 3;
              return this.dbManager.getTimeJoin(id);
            case 3:
              time = _context3.sent;
              if (!time.assigned) {
                _context3.next = 7;
                break;
              }
              console.warn('Time is assigned, cannot remove');
              return _context3.abrupt("return", false);
            case 7:
              _context3.next = 9;
              return this.dbManager.deleteTime({
                id: id
              });
            case 9:
              return _context3.abrupt("return", true);
            case 10:
              if (!(type == 'take')) {
                _context3.next = 15;
                break;
              }
              _context3.next = 13;
              return this.dbManager.deleteTake({
                id: id
              });
            case 13:
              this.timeTable.reload();
              return _context3.abrupt("return", true);
            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function deleteRow(_x2, _x3) {
        return _deleteRow.apply(this, arguments);
      }
      return deleteRow;
    }()
  }, {
    key: "editRow",
    value: function () {
      var _editRow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id, type) {
        var time;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(type == 'time')) {
                _context4.next = 5;
                break;
              }
              _context4.next = 3;
              return this.dbManager.getTime(id);
            case 3:
              time = _context4.sent;
              this._setTime(time);
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function editRow(_x4, _x5) {
        return _editRow.apply(this, arguments);
      }
      return editRow;
    }()
  }, {
    key: "_newTime",
    value: function () {
      var _newTime2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(time) {
        var _this$timeTable;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (this.timeTable) {
                _context5.next = 2;
                break;
              }
              return _context5.abrupt("return");
            case 2:
              // add to row to table
              (_this$timeTable = this.timeTable) === null || _this$timeTable === void 0 ? void 0 : _this$timeTable.addRow(time);

              // check focus
              if (!this.assignTime.contains(document.activeElement)) {
                _context5.next = 5;
                break;
              }
              return _context5.abrupt("return");
            case 5:
              // configure form
              this._setTime(time);
            case 6:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function _newTime(_x6) {
        return _newTime2.apply(this, arguments);
      }
      return _newTime;
    }()
  }, {
    key: "_setTime",
    value: function _setTime(time) {
      var _this3 = this;
      // compile form
      var formData = _objectSpread(_objectSpread({}, time), {}, {
        timeStr: (0,_libs_utils__WEBPACK_IMPORTED_MODULE_4__.dateToStr)(new Date(time.time), true)
      });
      (0,_libs_form_to_json__WEBPACK_IMPORTED_MODULE_2__.jsonToForm)(this.assignTime, formData);

      // focus
      setTimeout(function () {
        _this3.assignTime.classList.remove('bg-blue-300');
      }, 1000);
      this.assignTime.classList.add('bg-blue-300');
      this.assignTime.querySelector('[name=runnerNum]').focus();
    }
  }, {
    key: "_assignTime",
    value: function () {
      var _assignTime2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(json) {
        var _this4 = this;
        var ps, runner, take;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (json.id) {
                _context6.next = 3;
                break;
              }
              console.warn('Cannot assign time without a Time ID');
              return _context6.abrupt("return");
            case 3:
              _context6.next = 5;
              return this.dbManager.getPSBy({
                name: json.psName,
                race: this.raceId
              });
            case 5:
              ps = _context6.sent;
              _context6.next = 8;
              return this.dbManager.getRunnerBy({
                number: json.runnerNum,
                race: this.raceId
              });
            case 8:
              runner = _context6.sent;
              if (!(!ps || !runner)) {
                _context6.next = 14;
                break;
              }
              console.warn('Cannot find PS or Runner');
              setTimeout(function () {
                _this4.assignTime.classList.remove('bg-red-300');
              }, 1000);
              this.assignTime.classList.add('bg-red-300');
              return _context6.abrupt("return");
            case 14:
              _context6.next = 16;
              return this.dbManager.getTakeBy({
                ps: ps.id,
                runner: runner.id,
                race: this.raceId
              });
            case 16:
              take = _context6.sent;
              if (!take) {
                _context6.next = 22;
                break;
              }
              console.warn('Take already exists for this PS and Runner');
              setTimeout(function () {
                _this4.assignTime.classList.remove('bg-red-300');
              }, 1000);
              this.assignTime.classList.add('bg-red-300');
              return _context6.abrupt("return");
            case 22:
              _context6.next = 24;
              return this.dbManager.createTake({
                time: json.id,
                ps: ps.id,
                runner: runner.id,
                race: this.raceId
              });
            case 24:
              setTimeout(function () {
                _this4.assignTime.classList.remove('bg-green-300');
              }, 1000);
              this.assignTime.classList.add('bg-green-300');
              this.assignTime.reset();
              this.takeTable.reload();
              this.timeTable.reload();
            case 29:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _assignTime(_x7) {
        return _assignTime2.apply(this, arguments);
      }
      return _assignTime;
    }()
  }]);
  return M1Dashboard;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (M1Dashboard);

/***/ }),

/***/ "./src/components/m2-race/index.js":
/*!*****************************************!*\
  !*** ./src/components/m2-race/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.hbs */ "./src/components/m2-race/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _libs_form_to_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs/form-to-json */ "./src/libs/form-to-json.js");
/* harmony import */ var _libs_store_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../libs/store-manager */ "./src/libs/store-manager.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! papaparse */ "./node_modules/papaparse/papaparse.min.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../libs/utils */ "./src/libs/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







var M2Race = /*#__PURE__*/function (_Component) {
  _inherits(M2Race, _Component);
  var _super = _createSuper(M2Race);
  function M2Race() {
    var _this;
    _classCallCheck(this, M2Race);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_2__.getDBManager)();
    _this._init();
    return _this;
  }
  _createClass(M2Race, [{
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var selectedRace, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // load raceId
              selectedRace = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_4__.getStoreManager)().get('selectedRace');
              this.raceId = selectedRace.race;

              // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_1___default()({}), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);

              //get table
              this.table = this._ref('table');

              //add listeners
              this._addListeners();
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "_addListeners",
    value: function _addListeners() {
      var _this2 = this;
      this._addListener('submit', function (event) {
        event.preventDefault();
        _this2._createPs(event.target);
      }, 'createPs');
      this._addListener('submit', function (event) {
        event.preventDefault();
        _this2._uploadPs(event.target);
      }, 'uploadPs');
      this._addListener('click', function (event) {
        event.preventDefault();
        _this2._download();
      }, 'download');
    }
  }, {
    key: "_createPs",
    value: function () {
      var _createPs2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(form) {
        var json, data;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              json = (0,_libs_form_to_json__WEBPACK_IMPORTED_MODULE_3__.formToJSON)(form);
              data = _objectSpread(_objectSpread({}, json), {}, {
                start: new Date(json.start).getTime(),
                race: this.raceId
              });
              _context2.next = 4;
              return this.dbManager.createOrUpdatePS(data);
            case 4:
              this.table.reload();
              form.reset();
              this._emit('psChange', true);
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _createPs(_x) {
        return _createPs2.apply(this, arguments);
      }
      return _createPs;
    }()
  }, {
    key: "_uploadPs",
    value: function () {
      var _uploadPs2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(form) {
        var files, f, arrayBuffer, decoder, csv, results, rows, _iterator, _step, row;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              files = form.querySelector('[type=file]').files;
              if (files) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return");
            case 3:
              _context3.next = 5;
              return this.dbManager.cleanPS({
                race: this.raceId
              });
            case 5:
              //read file
              f = files[0];
              _context3.next = 8;
              return (0,_libs_utils__WEBPACK_IMPORTED_MODULE_6__.readFileAsync)(f);
            case 8:
              arrayBuffer = _context3.sent;
              decoder = new TextDecoder('utf-8');
              csv = decoder.decode(arrayBuffer); //read csv
              results = papaparse__WEBPACK_IMPORTED_MODULE_5___default().parse(csv, {
                header: true
              }); //add item
              rows = results.data;
              _iterator = _createForOfIteratorHelper(rows);
              _context3.prev = 14;
              _iterator.s();
            case 16:
              if ((_step = _iterator.n()).done) {
                _context3.next = 22;
                break;
              }
              row = _step.value;
              _context3.next = 20;
              return this.dbManager.createOrUpdatePS(_objectSpread(_objectSpread({}, row), {}, {
                start: parseInt(row.start),
                id: null,
                race: this.raceId
              }));
            case 20:
              _context3.next = 16;
              break;
            case 22:
              _context3.next = 27;
              break;
            case 24:
              _context3.prev = 24;
              _context3.t0 = _context3["catch"](14);
              _iterator.e(_context3.t0);
            case 27:
              _context3.prev = 27;
              _iterator.f();
              return _context3.finish(27);
            case 30:
              this.table.reload();
              form.reset();
            case 32:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[14, 24, 27, 30]]);
      }));
      function _uploadPs(_x2) {
        return _uploadPs2.apply(this, arguments);
      }
      return _uploadPs;
    }()
  }, {
    key: "getRows",
    value: function () {
      var _getRows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.dbManager.getAllPS(this.raceId);
            case 2:
              return _context4.abrupt("return", _context4.sent);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getRows() {
        return _getRows.apply(this, arguments);
      }
      return getRows;
    }()
  }, {
    key: "deleteRow",
    value: function () {
      var _deleteRow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(id) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.dbManager.deletePS({
                id: id
              });
            case 2:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function deleteRow(_x3) {
        return _deleteRow.apply(this, arguments);
      }
      return deleteRow;
    }()
  }, {
    key: "_download",
    value: function () {
      var _download2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var rows, csv, csvContent;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.getRows();
            case 2:
              rows = _context6.sent;
              csv = papaparse__WEBPACK_IMPORTED_MODULE_5___default().unparse(rows);
              csvContent = 'data:text/csv;charset=utf-8,' + csv;
              window.open(encodeURI(csvContent));
            case 6:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _download() {
        return _download2.apply(this, arguments);
      }
      return _download;
    }()
  }]);
  return M2Race;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (M2Race);

/***/ }),

/***/ "./src/components/m3-runners/index.js":
/*!********************************************!*\
  !*** ./src/components/m3-runners/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.hbs */ "./src/components/m3-runners/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _libs_form_to_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs/form-to-json */ "./src/libs/form-to-json.js");
/* harmony import */ var _libs_store_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../libs/store-manager */ "./src/libs/store-manager.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! papaparse */ "./node_modules/papaparse/papaparse.min.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _libs_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../libs/utils */ "./src/libs/utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







var M3Runners = /*#__PURE__*/function (_Component) {
  _inherits(M3Runners, _Component);
  var _super = _createSuper(M3Runners);
  function M3Runners() {
    var _this;
    _classCallCheck(this, M3Runners);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_2__.getDBManager)();
    _this._init();
    return _this;
  }
  _createClass(M3Runners, [{
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var selectedRace, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // load raceId
              selectedRace = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_4__.getStoreManager)().get('selectedRace');
              this.raceId = selectedRace.race;

              // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_1___default()({}), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);

              //get table
              this.table = this._ref('table');

              //add listeners
              this._addListeners();
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "_addListeners",
    value: function _addListeners() {
      var _this2 = this;
      this._addListener('submit', function (event) {
        event.preventDefault();
        _this2._createRunner(event.target);
      }, 'createRunner');
      this._addListener('submit', function (event) {
        event.preventDefault();
        _this2._uploadRunner(event.target);
      }, 'uploadRunner');
      this._addListener('click', function (event) {
        event.preventDefault();
        _this2._download();
      }, 'download');
    }
  }, {
    key: "_createRunner",
    value: function () {
      var _createRunner2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(form) {
        var data;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              data = _objectSpread(_objectSpread({}, (0,_libs_form_to_json__WEBPACK_IMPORTED_MODULE_3__.formToJSON)(form)), {}, {
                race: this.raceId
              });
              _context2.next = 3;
              return this.dbManager.createOrUpdateRunner(data);
            case 3:
              this.table.reload();
              form.reset();
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _createRunner(_x) {
        return _createRunner2.apply(this, arguments);
      }
      return _createRunner;
    }()
  }, {
    key: "_uploadRunner",
    value: function () {
      var _uploadRunner2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(form) {
        var files, f, arrayBuffer, decoder, csv, results, rows, _iterator, _step, row;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              files = form.querySelector('[type=file]').files;
              if (files) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return");
            case 3:
              _context3.next = 5;
              return this.dbManager.cleanRunner({
                race: this.raceId
              });
            case 5:
              //read file
              f = files[0];
              _context3.next = 8;
              return (0,_libs_utils__WEBPACK_IMPORTED_MODULE_6__.readFileAsync)(f);
            case 8:
              arrayBuffer = _context3.sent;
              decoder = new TextDecoder('utf-8');
              csv = decoder.decode(arrayBuffer); //read csv
              results = papaparse__WEBPACK_IMPORTED_MODULE_5___default().parse(csv, {
                header: true
              }); //add item
              rows = results.data;
              _iterator = _createForOfIteratorHelper(rows);
              _context3.prev = 14;
              _iterator.s();
            case 16:
              if ((_step = _iterator.n()).done) {
                _context3.next = 22;
                break;
              }
              row = _step.value;
              _context3.next = 20;
              return this.dbManager.createOrUpdateRunner(_objectSpread(_objectSpread({}, row), {}, {
                id: null,
                race: this.raceId
              }));
            case 20:
              _context3.next = 16;
              break;
            case 22:
              _context3.next = 27;
              break;
            case 24:
              _context3.prev = 24;
              _context3.t0 = _context3["catch"](14);
              _iterator.e(_context3.t0);
            case 27:
              _context3.prev = 27;
              _iterator.f();
              return _context3.finish(27);
            case 30:
              this.table.reload();
              form.reset();
            case 32:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[14, 24, 27, 30]]);
      }));
      function _uploadRunner(_x2) {
        return _uploadRunner2.apply(this, arguments);
      }
      return _uploadRunner;
    }()
  }, {
    key: "getRows",
    value: function () {
      var _getRows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.dbManager.getAllRunner(this.raceId);
            case 2:
              return _context4.abrupt("return", _context4.sent);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getRows() {
        return _getRows.apply(this, arguments);
      }
      return getRows;
    }()
  }, {
    key: "deleteRow",
    value: function () {
      var _deleteRow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(id) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.dbManager.deleteRunner({
                id: id
              });
            case 2:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function deleteRow(_x3) {
        return _deleteRow.apply(this, arguments);
      }
      return deleteRow;
    }()
  }, {
    key: "_download",
    value: function () {
      var _download2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var rows, csv, csvContent;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.getRows();
            case 2:
              rows = _context6.sent;
              csv = papaparse__WEBPACK_IMPORTED_MODULE_5___default().unparse(rows);
              csvContent = 'data:text/csv;charset=utf-8,' + csv;
              window.open(encodeURI(csvContent));
            case 6:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _download() {
        return _download2.apply(this, arguments);
      }
      return _download;
    }()
  }]);
  return M3Runners;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (M3Runners);

/***/ }),

/***/ "./src/components/m4-score/index.js":
/*!******************************************!*\
  !*** ./src/components/m4-score/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _libs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/component */ "./src/libs/component.js");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.hbs */ "./src/components/m4-score/template.hbs");
/* harmony import */ var _template_hbs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_template_hbs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _libs_db_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../libs/db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _libs_store_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../libs/store-manager */ "./src/libs/store-manager.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! papaparse */ "./node_modules/papaparse/papaparse.min.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_4__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var M4Score = /*#__PURE__*/function (_Component) {
  _inherits(M4Score, _Component);
  var _super = _createSuper(M4Score);
  function M4Score() {
    var _this;
    _classCallCheck(this, M4Score);
    _this = _super.call(this);
    _this.dbManager = (0,_libs_db_manager__WEBPACK_IMPORTED_MODULE_2__.getDBManager)();
    _this._init();
    return _this;
  }
  _createClass(M4Score, [{
    key: "_init",
    value: function () {
      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this2 = this;
        var selectedRace, selectedPage, parser, htmlDoc;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // load raceId
              selectedRace = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_3__.getStoreManager)().get('selectedRace');
              this.raceId = selectedRace.race;
              selectedPage = (0,_libs_store_manager__WEBPACK_IMPORTED_MODULE_3__.getStoreManager)().get('selectedPage');
              this.psId = selectedPage.destination.substring(3);

              // parse html
              parser = new DOMParser();
              htmlDoc = parser.parseFromString(_template_hbs__WEBPACK_IMPORTED_MODULE_1___default()({}), 'text/html');
              this.appendChild(htmlDoc.body.firstElementChild);

              //get table
              this.table = this._ref('table');
              this._addListener('click', function (event) {
                event.preventDefault();
                _this2._download();
              }, 'download');
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _init() {
        return _init2.apply(this, arguments);
      }
      return _init;
    }()
  }, {
    key: "getRows",
    value: function () {
      var _getRows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.dbManager.getScore(this.psId, this.raceId);
            case 2:
              return _context2.abrupt("return", _context2.sent);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getRows() {
        return _getRows.apply(this, arguments);
      }
      return getRows;
    }()
  }, {
    key: "_download",
    value: function () {
      var _download2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var rows, csv, csvContent;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.getRows();
            case 2:
              rows = _context3.sent;
              csv = papaparse__WEBPACK_IMPORTED_MODULE_4___default().unparse(rows);
              csvContent = 'data:text/csv;charset=utf-8,' + csv;
              window.open(encodeURI(csvContent));
            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _download() {
        return _download2.apply(this, arguments);
      }
      return _download;
    }()
  }]);
  return M4Score;
}(_libs_component__WEBPACK_IMPORTED_MODULE_0__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (M4Score);

/***/ }),

/***/ "./src/libs/component.js":
/*!*******************************!*\
  !*** ./src/libs/component.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _store_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store-manager */ "./src/libs/store-manager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Component = /*#__PURE__*/function (_HTMLElement) {
  _inherits(Component, _HTMLElement);
  var _super = _createSuper(Component);
  function Component() {
    var _this;
    _classCallCheck(this, Component);
    _this = _super.call(this);
    _this.setAttribute('component', true); // tag custom element
    _this.storeManager = (0,_store_manager__WEBPACK_IMPORTED_MODULE_0__.getStoreManager)();
    _this.listeners = [];
    _this.storeListeners = [];
    return _this;
  }
  _createClass(Component, [{
    key: "dispose",
    value: function () {
      var _dispose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this._removeAllListeners();
              this._removeAllStoreListeners();
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function dispose() {
        return _dispose.apply(this, arguments);
      }
      return dispose;
    }()
  }, {
    key: "_addListener",
    value: function _addListener(ev, cb) {
      var el = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'root';
      var startFrom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      //load events
      var events = [];
      if (typeof ev == 'string') {
        events = [ev];
      } else if (ev instanceof Array) {
        events = ev;
      } else {
        console.warn('Invalid addListener call');
        return;
      }

      //load elements if necessary
      var elements = [];
      if (el == 'root') {
        elements = [this];
      } else if (typeof el == 'string') {
        elements = this._ref(el, true, startFrom);
      } else if (el instanceof Element || el instanceof Document || el instanceof Window) {
        elements = [el];
      }

      //check element
      if (elements.length <= 0) {
        console.debug('Event listener not added due to missing element', el);
        return;
      }
      var _iterator = _createForOfIteratorHelper(elements),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var element = _step.value;
          var _iterator2 = _createForOfIteratorHelper(events),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var event = _step2.value;
              this._addListenerTo(element, event, cb, options);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "_addListenerTo",
    value: function _addListenerTo(element, event, callback) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      element.addEventListener(event, callback, options);
      this.listeners.push({
        element: element,
        event: event,
        callback: callback,
        options: options
      });
    }
  }, {
    key: "_removeAllListeners",
    value: function _removeAllListeners() {
      var _iterator3 = _createForOfIteratorHelper(this.listeners),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var listener = _step3.value;
          listener.element.removeEventListener(listener.event, listener.callback, listener.options);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }

    // Store
  }, {
    key: "_emit",
    value: function _emit(path, data) {
      var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.storeManager.emit(path, data, merge);
    }
  }, {
    key: "_addStoreListener",
    value: function _addStoreListener(match, cb) {
      this.storeManager.addListener(match, cb);
      this.storeListeners.push({
        match: match,
        callback: cb
      });
    }
  }, {
    key: "_removeAllStoreListeners",
    value: function _removeAllStoreListeners() {
      var _iterator4 = _createForOfIteratorHelper(this.storeListeners),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var listener = _step4.value;
          this.storeManager.removeListener(listener.match, listener.callback);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }

    //elements methods
  }, {
    key: "_ref",
    value: function _ref(name) {
      var all = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var startFrom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var startEl = startFrom ? startFrom : this;
      if (all) {
        return Array.from(startEl.querySelectorAll("[ref=".concat(name, "]")));
      } else {
        return startEl.querySelector("[ref=".concat(name, "]"));
      }
    }
  }, {
    key: "_parent",
    value: function _parent() {
      return this.parentElement.closest("[component=true]");
    }
  }]);
  return Component;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));


/***/ }),

/***/ "./src/libs/db-manager.js":
/*!********************************!*\
  !*** ./src/libs/db-manager.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDBManager": () => (/* binding */ getDBManager)
/* harmony export */ });
/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ "./node_modules/dexie/dist/modern/dexie.mjs");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

var DBManager = /*#__PURE__*/function () {
  function DBManager() {
    _classCallCheck(this, DBManager);
    this.db = new dexie__WEBPACK_IMPORTED_MODULE_0__["default"]('Lightpass');

    // Declare tables, IDs and indexes
    this.db.version(5).stores({
      race: '++id, name',
      runner: '++id, name, number, category, race',
      ps: '++id, name, start, gap, order, race',
      time: '++id, time, race',
      take: '++id, &time, ps, runner, race'
    });
  }

  ///// RACE
  _createClass(DBManager, [{
    key: "createRace",
    value: function () {
      var _createRace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.db.race.add({
                name: name
              });
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function createRace(_x) {
        return _createRace.apply(this, arguments);
      }
      return createRace;
    }()
  }, {
    key: "getAllRace",
    value: function () {
      var _getAllRace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.db.race.toArray();
            case 2:
              return _context2.abrupt("return", _context2.sent);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getAllRace() {
        return _getAllRace.apply(this, arguments);
      }
      return getAllRace;
    }() ///// PS
  }, {
    key: "getAllPS",
    value: function () {
      var _getAllPS = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(race) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.db.ps.where('race').equals(parseInt(race)).toArray();
            case 2:
              return _context3.abrupt("return", _context3.sent);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getAllPS(_x2) {
        return _getAllPS.apply(this, arguments);
      }
      return getAllPS;
    }()
  }, {
    key: "createOrUpdatePS",
    value: function () {
      var _createOrUpdatePS = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref) {
        var name, gap, order, start, race, id;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              name = _ref.name, gap = _ref.gap, order = _ref.order, start = _ref.start, race = _ref.race, id = _ref.id;
              if (!id) {
                _context4.next = 7;
                break;
              }
              _context4.next = 4;
              return this.db.ps.update(parseInt(id), {
                name: name,
                gap: gap,
                start: parseInt(start),
                order: order,
                race: parseInt(race)
              });
            case 4:
              return _context4.abrupt("return", _context4.sent);
            case 7:
              _context4.next = 9;
              return this.db.ps.add({
                name: name,
                gap: gap,
                start: parseInt(start),
                order: order,
                race: parseInt(race)
              });
            case 9:
              return _context4.abrupt("return", _context4.sent);
            case 10:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function createOrUpdatePS(_x3) {
        return _createOrUpdatePS.apply(this, arguments);
      }
      return createOrUpdatePS;
    }()
  }, {
    key: "deletePS",
    value: function () {
      var _deletePS = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref2) {
        var id;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              id = _ref2.id;
              _context5.next = 3;
              return this.db.ps["delete"](parseInt(id));
            case 3:
              return _context5.abrupt("return", _context5.sent);
            case 4:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function deletePS(_x4) {
        return _deletePS.apply(this, arguments);
      }
      return deletePS;
    }()
  }, {
    key: "cleanPS",
    value: function () {
      var _cleanPS = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref3) {
        var race, array, ids;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              race = _ref3.race;
              _context6.next = 3;
              return this.db.ps.where('race').equals(parseInt(race)).toArray();
            case 3:
              array = _context6.sent;
              ids = array.map(function (item) {
                return item.id;
              });
              _context6.next = 7;
              return this.db.ps.bulkDelete(ids);
            case 7:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function cleanPS(_x5) {
        return _cleanPS.apply(this, arguments);
      }
      return cleanPS;
    }()
  }, {
    key: "getPSBy",
    value: function () {
      var _getPSBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref4) {
        var name, race;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              name = _ref4.name, race = _ref4.race;
              _context7.next = 3;
              return this.db.ps.get({
                name: name,
                race: parseInt(race)
              });
            case 3:
              return _context7.abrupt("return", _context7.sent);
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getPSBy(_x6) {
        return _getPSBy.apply(this, arguments);
      }
      return getPSBy;
    }() ////////////////////////////////////////////////////////////////////////////////// Runners
  }, {
    key: "getRunnerBy",
    value: function () {
      var _getRunnerBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref5) {
        var number, race;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              number = _ref5.number, race = _ref5.race;
              _context8.next = 3;
              return this.db.runner.get({
                number: parseInt(number),
                race: parseInt(race)
              });
            case 3:
              return _context8.abrupt("return", _context8.sent);
            case 4:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getRunnerBy(_x7) {
        return _getRunnerBy.apply(this, arguments);
      }
      return getRunnerBy;
    }()
  }, {
    key: "getAllRunner",
    value: function () {
      var _getAllRunner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(race) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.db.runner.where('race').equals(parseInt(race)).toArray();
            case 2:
              return _context9.abrupt("return", _context9.sent);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function getAllRunner(_x8) {
        return _getAllRunner.apply(this, arguments);
      }
      return getAllRunner;
    }()
  }, {
    key: "createOrUpdateRunner",
    value: function () {
      var _createOrUpdateRunner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref6) {
        var name, number, category, race, id;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              name = _ref6.name, number = _ref6.number, category = _ref6.category, race = _ref6.race, id = _ref6.id;
              if (!id) {
                _context10.next = 7;
                break;
              }
              _context10.next = 4;
              return this.db.runner.update(parseInt(id), {
                name: name,
                number: parseInt(number),
                category: category,
                race: parseInt(race)
              });
            case 4:
              return _context10.abrupt("return", _context10.sent);
            case 7:
              _context10.next = 9;
              return this.db.runner.add({
                name: name,
                number: parseInt(number),
                category: category,
                race: parseInt(race)
              });
            case 9:
              return _context10.abrupt("return", _context10.sent);
            case 10:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function createOrUpdateRunner(_x9) {
        return _createOrUpdateRunner.apply(this, arguments);
      }
      return createOrUpdateRunner;
    }()
  }, {
    key: "deleteRunner",
    value: function () {
      var _deleteRunner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_ref7) {
        var id;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              id = _ref7.id;
              _context11.next = 3;
              return this.db.runner["delete"](parseInt(id));
            case 3:
              return _context11.abrupt("return", _context11.sent);
            case 4:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function deleteRunner(_x10) {
        return _deleteRunner.apply(this, arguments);
      }
      return deleteRunner;
    }()
  }, {
    key: "cleanRunner",
    value: function () {
      var _cleanRunner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref8) {
        var race, array, ids;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              race = _ref8.race;
              _context12.next = 3;
              return this.db.runner.where('race').equals(parseInt(race)).toArray();
            case 3:
              array = _context12.sent;
              ids = array.map(function (item) {
                return item.id;
              });
              _context12.next = 7;
              return this.db.runner.bulkDelete(ids);
            case 7:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function cleanRunner(_x11) {
        return _cleanRunner.apply(this, arguments);
      }
      return cleanRunner;
    }() ////////////////////////////////////////////////////////////////////////////////// time
  }, {
    key: "getTime",
    value: function () {
      var _getTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(id) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return this.db.time.get(parseInt(id));
            case 2:
              return _context13.abrupt("return", _context13.sent);
            case 3:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getTime(_x12) {
        return _getTime.apply(this, arguments);
      }
      return getTime;
    }()
  }, {
    key: "getAllTime",
    value: function () {
      var _getAllTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(race) {
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.db.time.where('race').equals(parseInt(race)).toArray();
            case 2:
              return _context14.abrupt("return", _context14.sent);
            case 3:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function getAllTime(_x13) {
        return _getAllTime.apply(this, arguments);
      }
      return getAllTime;
    }()
  }, {
    key: "addTime",
    value: function () {
      var _addTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(_ref9) {
        var time, race;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              time = _ref9.time, race = _ref9.race;
              _context15.next = 3;
              return this.db.time.add({
                time: time,
                race: parseInt(race)
              });
            case 3:
              return _context15.abrupt("return", _context15.sent);
            case 4:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function addTime(_x14) {
        return _addTime.apply(this, arguments);
      }
      return addTime;
    }()
  }, {
    key: "deleteTime",
    value: function () {
      var _deleteTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(_ref10) {
        var id;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              id = _ref10.id;
              _context16.next = 3;
              return this.db.time["delete"](parseInt(id));
            case 3:
              return _context16.abrupt("return", _context16.sent);
            case 4:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function deleteTime(_x15) {
        return _deleteTime.apply(this, arguments);
      }
      return deleteTime;
    }() ////////////////////////////////////////////////////////////////////////////////// take
  }, {
    key: "getTakeBy",
    value: function () {
      var _getTakeBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_ref11) {
        var ps, runner, race;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              ps = _ref11.ps, runner = _ref11.runner, race = _ref11.race;
              _context17.next = 3;
              return this.db.take.get({
                ps: parseInt(ps),
                runner: parseInt(runner),
                race: parseInt(race)
              });
            case 3:
              return _context17.abrupt("return", _context17.sent);
            case 4:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function getTakeBy(_x16) {
        return _getTakeBy.apply(this, arguments);
      }
      return getTakeBy;
    }()
  }, {
    key: "getAllTake",
    value: function () {
      var _getAllTake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(race) {
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return this.db.take.where('race').equals(parseInt(race)).toArray();
            case 2:
              return _context18.abrupt("return", _context18.sent);
            case 3:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function getAllTake(_x17) {
        return _getAllTake.apply(this, arguments);
      }
      return getAllTake;
    }()
  }, {
    key: "createTake",
    value: function () {
      var _createTake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(_ref12) {
        var time, ps, runner, race;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              time = _ref12.time, ps = _ref12.ps, runner = _ref12.runner, race = _ref12.race;
              _context19.next = 3;
              return this.db.take.add({
                time: parseInt(time),
                ps: parseInt(ps),
                runner: parseInt(runner),
                race: parseInt(race)
              });
            case 3:
              return _context19.abrupt("return", _context19.sent);
            case 4:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function createTake(_x18) {
        return _createTake.apply(this, arguments);
      }
      return createTake;
    }()
  }, {
    key: "deleteTake",
    value: function () {
      var _deleteTake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref13) {
        var id;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              id = _ref13.id;
              _context20.next = 3;
              return this.db.take["delete"](parseInt(id));
            case 3:
              return _context20.abrupt("return", _context20.sent);
            case 4:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function deleteTake(_x19) {
        return _deleteTake.apply(this, arguments);
      }
      return deleteTake;
    }()
  }, {
    key: "cleanTake",
    value: function () {
      var _cleanTake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref14) {
        var race, array, ids;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              race = _ref14.race;
              _context21.next = 3;
              return this.db.take.where('race').equals(parseInt(race)).toArray();
            case 3:
              array = _context21.sent;
              ids = array.map(function (item) {
                return item.id;
              });
              _context21.next = 7;
              return this.db.take.bulkDelete(ids);
            case 7:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function cleanTake(_x20) {
        return _cleanTake.apply(this, arguments);
      }
      return cleanTake;
    }() ////////////////////////////////////////////////////////////////////////////////// special
  }, {
    key: "getTimeJoin",
    value: function () {
      var _getTimeJoin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(id) {
        var time, found, runner;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return this.db.time.get(parseInt(id));
            case 2:
              time = _context22.sent;
              _context22.next = 5;
              return this.db.take.where('time').equals(time.id).toArray();
            case 5:
              found = _context22.sent;
              if (!(!found || found.length == 0)) {
                _context22.next = 8;
                break;
              }
              return _context22.abrupt("return", _objectSpread({}, time));
            case 8:
              _context22.next = 10;
              return this.db.runner.get(found[0].runner);
            case 10:
              runner = _context22.sent;
              if (runner) {
                _context22.next = 13;
                break;
              }
              return _context22.abrupt("return", _objectSpread({}, time));
            case 13:
              return _context22.abrupt("return", _objectSpread(_objectSpread({}, time), {}, {
                assigned: runner.number,
                assignedName: runner.name
              }));
            case 14:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function getTimeJoin(_x21) {
        return _getTimeJoin.apply(this, arguments);
      }
      return getTimeJoin;
    }()
  }, {
    key: "getAllTimeJoin",
    value: function () {
      var _getAllTimeJoin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(race) {
        var _this = this;
        var onlyNotAssigned,
          times,
          result,
          _args24 = arguments;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              onlyNotAssigned = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : false;
              _context24.next = 3;
              return this.getAllTime(race);
            case 3:
              times = _context24.sent;
              _context24.next = 6;
              return Promise.all(times.map( /*#__PURE__*/function () {
                var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(time) {
                  var found, runner, ps;
                  return _regeneratorRuntime().wrap(function _callee23$(_context23) {
                    while (1) switch (_context23.prev = _context23.next) {
                      case 0:
                        _context23.next = 2;
                        return _this.db.take.where('time').equals(time.id).toArray();
                      case 2:
                        found = _context23.sent;
                        if (!(!found || found.length == 0)) {
                          _context23.next = 5;
                          break;
                        }
                        return _context23.abrupt("return", time);
                      case 5:
                        _context23.next = 7;
                        return _this.db.runner.get(found[0].runner);
                      case 7:
                        runner = _context23.sent;
                        _context23.next = 10;
                        return _this.db.ps.get(found[0].ps);
                      case 10:
                        ps = _context23.sent;
                        if (!(!runner || !ps)) {
                          _context23.next = 13;
                          break;
                        }
                        return _context23.abrupt("return", _objectSpread({}, time));
                      case 13:
                        return _context23.abrupt("return", _objectSpread(_objectSpread({}, time), {}, {
                          assigned: runner.number,
                          assignedName: runner.name,
                          assignedPs: ps.name
                        }));
                      case 14:
                      case "end":
                        return _context23.stop();
                    }
                  }, _callee23);
                }));
                return function (_x23) {
                  return _ref15.apply(this, arguments);
                };
              }()));
            case 6:
              result = _context24.sent;
              if (onlyNotAssigned) {
                result = result.filter(function (item) {
                  return !item.assigned;
                });
              }
              return _context24.abrupt("return", result);
            case 9:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function getAllTimeJoin(_x22) {
        return _getAllTimeJoin.apply(this, arguments);
      }
      return getAllTimeJoin;
    }()
  }, {
    key: "getAllTakeJoin",
    value: function () {
      var _getAllTakeJoin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(race) {
        var _this2 = this;
        var takes, result;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.getAllTake(race);
            case 2:
              takes = _context26.sent;
              _context26.next = 5;
              return Promise.all(takes.map( /*#__PURE__*/function () {
                var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(take) {
                  var time, runner, ps;
                  return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                    while (1) switch (_context25.prev = _context25.next) {
                      case 0:
                        _context25.next = 2;
                        return _this2.db.time.get(take.time);
                      case 2:
                        time = _context25.sent;
                        _context25.next = 5;
                        return _this2.db.runner.get(take.runner);
                      case 5:
                        runner = _context25.sent;
                        _context25.next = 8;
                        return _this2.db.ps.get(take.ps);
                      case 8:
                        ps = _context25.sent;
                        if (!(!runner || !ps || !time)) {
                          _context25.next = 11;
                          break;
                        }
                        return _context25.abrupt("return", _objectSpread({}, take));
                      case 11:
                        return _context25.abrupt("return", _objectSpread(_objectSpread({}, take), {}, {
                          assignedIdTime: time.id,
                          assignedTime: time.time,
                          assigned: runner.number,
                          assignedName: runner.name,
                          assignedPs: ps.name
                        }));
                      case 12:
                      case "end":
                        return _context25.stop();
                    }
                  }, _callee25);
                }));
                return function (_x25) {
                  return _ref16.apply(this, arguments);
                };
              }()));
            case 5:
              result = _context26.sent;
              return _context26.abrupt("return", result);
            case 7:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function getAllTakeJoin(_x24) {
        return _getAllTakeJoin.apply(this, arguments);
      }
      return getAllTakeJoin;
    }()
  }, {
    key: "getScore",
    value: function () {
      var _getScore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(psId, race) {
        var ps, runners, start, gap, result, _iterator, _step, _end, _diff, runner, diff, end, take, time;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.db.ps.get(parseInt(psId));
            case 2:
              ps = _context27.sent;
              if (ps) {
                _context27.next = 5;
                break;
              }
              return _context27.abrupt("return", []);
            case 5:
              _context27.next = 7;
              return this.db.runner.where('race').equals(parseInt(race)).toArray();
            case 7:
              runners = _context27.sent;
              if (runners) {
                _context27.next = 10;
                break;
              }
              return _context27.abrupt("return", []);
            case 10:
              // sort runners by ps direction
              runners = runners.sort(function (one, two) {
                var a = ps.direction == 'asc' ? one : two;
                var b = ps.direction == 'asc' ? two : one;
                if (a.number === undefined) {
                  return 1;
                }
                if (b.number === undefined) {
                  return -1;
                }
                if (a.number < b.number) {
                  return -1;
                }
                if (a.number >= b.number) {
                  return 1;
                }
              });

              //iterate and create final object
              start = new Date(ps.start);
              gap = parseInt(ps.gap);
              result = [];
              _iterator = _createForOfIteratorHelper(runners);
              _context27.prev = 15;
              _iterator.s();
            case 17:
              if ((_step = _iterator.n()).done) {
                _context27.next = 35;
                break;
              }
              runner = _step.value;
              // get diff
              diff = null;
              end = null;
              _context27.next = 23;
              return this.getTakeBy({
                ps: ps.id,
                runner: runner.id,
                race: race
              });
            case 23:
              take = _context27.sent;
              if (!take) {
                _context27.next = 31;
                break;
              }
              _context27.next = 27;
              return this.getTime(take.time);
            case 27:
              time = _context27.sent;
              end = new Date(time.time);
              diff = new Date(end.getTime() - start.getTime());
              console.log(diff);
            case 31:
              result.push(_objectSpread(_objectSpread({}, runner), {}, {
                ps: ps.name,
                start: start.getTime(),
                end: (_end = end) === null || _end === void 0 ? void 0 : _end.getTime(),
                diff: (_diff = diff) === null || _diff === void 0 ? void 0 : _diff.getTime()
              }));

              // next start
              start = new Date(start.getTime() + gap * 1000);
            case 33:
              _context27.next = 17;
              break;
            case 35:
              _context27.next = 40;
              break;
            case 37:
              _context27.prev = 37;
              _context27.t0 = _context27["catch"](15);
              _iterator.e(_context27.t0);
            case 40:
              _context27.prev = 40;
              _iterator.f();
              return _context27.finish(40);
            case 43:
              return _context27.abrupt("return", result);
            case 44:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this, [[15, 37, 40, 43]]);
      }));
      function getScore(_x26, _x27) {
        return _getScore.apply(this, arguments);
      }
      return getScore;
    }() ///////////// GLOBAL
  }, {
    key: "clear",
    value: function () {
      var _clear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              this.db.tables.forEach(function (table) {
                table.clear();
              });
            case 1:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function clear() {
        return _clear.apply(this, arguments);
      }
      return clear;
    }()
  }]);
  return DBManager;
}();
/**
 * @returns {DynamicRegister} the register
 */
var getDBManager = function getDBManager() {
  if (!window.rcDbManager) {
    window.rcDbManager = new DBManager();
  }
  return window.rcDbManager;
};

/***/ }),

/***/ "./src/libs/event-service.js":
/*!***********************************!*\
  !*** ./src/libs/event-service.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getEventService": () => (/* binding */ getEventService)
/* harmony export */ });
/* harmony import */ var _db_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db-manager */ "./src/libs/db-manager.js");
/* harmony import */ var _store_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store-manager */ "./src/libs/store-manager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var EventService = /*#__PURE__*/function () {
  function EventService() {
    _classCallCheck(this, EventService);
    if (!window.EventSource) throw 'Cannot start lightpass EventService, window.EventSource need to be defined';
  }
  _createClass(EventService, [{
    key: "start",
    value: function start() {
      this.source = new EventSource('/events');
      this.initDate = null;
      this.initMillis = null;
      this.dbManager = (0,_db_manager__WEBPACK_IMPORTED_MODULE_0__.getDBManager)();
      this.storeManager = (0,_store_manager__WEBPACK_IMPORTED_MODULE_1__.getStoreManager)();
      this._addSourceListeners();
      this._addFakeListeners();
    }
  }, {
    key: "_addSourceListeners",
    value: function _addSourceListeners() {
      var _this = this;
      this.source.addEventListener('open', function (e) {
        console.log('Lightpass sensor Connected');
        (0,_store_manager__WEBPACK_IMPORTED_MODULE_1__.getStoreManager)().emit('events', {
          ok: true
        });
      }, false);
      this.source.addEventListener('error', function (e) {
        if (e.target.readyState != EventSource.OPEN) {
          console.log('Lightpass sensor Disconnected');
          (0,_store_manager__WEBPACK_IMPORTED_MODULE_1__.getStoreManager)().emit('events', {
            ok: false
          });
        }
      }, false);
      this.source.addEventListener('init-event', function (e) {
        _this._initEvent(e);
      }, false);
      this.source.addEventListener('take-event', function (e) {
        _this._takeEvent(e);
      }, false);
      this.storeManager.addListener('selectedRace', function (path, data) {
        _this.raceId = data.race;
      });
    }
  }, {
    key: "_addFakeListeners",
    value: function _addFakeListeners() {
      var _this2 = this;
      document.body.addEventListener('keypress', function (e) {
        if (e.code == 'BracketRight') _this2._sendEvent(new Date());
      });
    }
  }, {
    key: "_initEvent",
    value: function _initEvent(e) {
      this.initDate = new Date();
      this.initMillis = e.data;
      console.log("Initialized events at ".concat(this.initDate, " (").concat(this.initDate.getTime(), ") with millis ").concat(this.initMillis));
    }
  }, {
    key: "_takeEvent",
    value: function _takeEvent(e) {
      if (!this.initDate || !this.initMillis) throw 'Missing init event';
      var newDateMillis = this.initDate.getTime() + (e.data - this.initMillis);
      var currentDate = new Date(newDateMillis);
      console.log("Taked event at ".concat(currentDate, " (").concat(currentDate.getTime(), ") with millis ").concat(e.data));
      this._sendEvent(currentDate);
    }
  }, {
    key: "_sendEvent",
    value: function () {
      var _sendEvent2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(takedDate) {
        var time, timeData, custom;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.raceId) console.warn('Please select a race');
              console.log("Propagated event for race ".concat(this.raceId, " with date ").concat(takedDate, " (").concat(takedDate.getTime(), ")"));
              _context.next = 4;
              return this.dbManager.addTime({
                time: takedDate.getTime(),
                race: this.raceId
              });
            case 4:
              time = _context.sent;
              _context.next = 7;
              return this.dbManager.getTimeJoin(time);
            case 7:
              timeData = _context.sent;
              custom = new CustomEvent('take-event', {
                detail: {
                  time: timeData
                }
              });
              document.body.dispatchEvent(custom);
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _sendEvent(_x) {
        return _sendEvent2.apply(this, arguments);
      }
      return _sendEvent;
    }()
  }]);
  return EventService;
}();
/**
 *
 * @returns {EventService}
 */
var getEventService = function getEventService() {
  if (!window.rcEventService) {
    window.rcEventService = new EventService();
  }
  return window.rcEventService;
};

/***/ }),

/***/ "./src/libs/form-to-json.js":
/*!**********************************!*\
  !*** ./src/libs/form-to-json.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formToJSON": () => (/* binding */ formToJSON),
/* harmony export */   "jsonToForm": () => (/* binding */ jsonToForm)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * Checks that an element has a non-empty `name`
 * @param  {Element} element  the element to check
 * @return {Bool}             true if the has a name
 */
var isValidElement = function isValidElement(element) {
  return !!element.name;
};

/**
 * Checks that an element has a non-empty `value` property.
 * @param  {Element} element  the element to check
 * @return {Bool}             true if the element has a non empty value
 */
var hasValue = function hasValue(element) {
  return !!element.value;
};

/**
 * Checks if an elements value can be saved (e.g. not an unselected checkbox).
 * @param  {Element} element  the element to check
 * @return {Boolean}          true if the value should be added, false if not
 */
var isValidValue = function isValidValue(element) {
  return !['checkbox', 'radio'].includes(element.type) || element.checked;
};

/**
 * Checks if an input is a checkbox, because checkboxes allow multiple values.
 * @param  {Element} element  the element to check
 * @return {Boolean}          true if the element is a checkbox, false if not
 */
var isCheckbox = function isCheckbox(element) {
  return element.type === 'checkbox';
};
var isRadio = function isRadio(element) {
  return element.type === 'radio';
};

/**
 * Checks if an input is a `select` with the `multiple` attribute.
 * @param  {Element} element  the element to check
 * @return {Boolean}          true if the element is a multiselect, false if not
 */
var isMultiSelect = function isMultiSelect(element) {
  return element.options && element.multiple;
};

/**
 * Retrieves the selected options from a multi-select as an array.
 * @param  {HTMLOptionsCollection} options  the options for the select
 * @return {Array}                          an array of selected option values
 */
var getSelectValues = function getSelectValues(options) {
  return [].reduce.call(options, function (values, option) {
    return option.selected ? values.concat(option.value) : values;
  }, []);
};

/**
 * Retrieves input data from a form and returns it as a JSON object.
 * @param  {HTMLFormControlsCollection} elements  the form elements
 * @param  {Boolean} includeEmpty                 include empty fields flag
 * @return {Object}                               form data as an object literal
 */
var formToJSON = function formToJSON(elements) {
  var includeEmpty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return [].reduce.call(elements, function (data, element) {
    // Make sure the element has the required properties and should be added.
    if (isValidElement(element) && (hasValue(element) || includeEmpty) && isValidValue(element)) {
      /*
       * Some fields allow for more than one value, so we need to check if this
       * is one of those fields and, if so, store the values as an array.
       */
      if (isCheckbox(element)) {
        var value = element.value == 'true' ? true : element.value;
        if (!data[element.name]) {
          data[element.name] = value;
        } else {
          data[element.name] = [value].push(data[element.name]);
        }
      } else if (isRadio(element)) {
        data[element.name] = element.value == 'true' ? true : element.value;
      } else if (isMultiSelect(element)) {
        data[element.name] = getSelectValues(element);
      } else {
        data[element.name] = element.value;
      }
    }
    return data;
  }, {});
};

/**
 * Retrieves input data from a form and returns it as a JSON object.
 * @param  {HTMLFormControlsCollection} elements  the form elements
 * @parm {Object}                               json data as an object literal
 * @param {HTMLElement[]} ignore elements to ignore during form set
 */
var jsonToForm = function jsonToForm(form, json, ignore) {
  var _iterator = _createForOfIteratorHelper(form.elements),
    _step;
  try {
    var _loop = function _loop() {
      var element = _step.value;
      if (!isValidElement(element)) return "continue";
      if (ignore && ignore.indexOf(element) >= 0) return "continue";
      var name = element.name;
      var value = typeof json[name] == 'boolean' ? '' + json[name] : typeof json[name] == 'undefined' ? '' : json[name];
      if (isCheckbox(element)) {
        element.checked = value && element.value && (value == element.value || value.indexOf(element.value) >= 0);
      } else if (isRadio(element)) {
        element.checked = value && element.value && (value == element.value || value.indexOf(element.value) >= 0);
      } else if (isMultiSelect(element)) {
        element.options.each(function (option) {
          option.selected = value == element.value || value.indexOf(option.value) >= 0;
        });
      } else {
        element.value = value;
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};

/***/ }),

/***/ "./src/libs/store-manager.js":
/*!***********************************!*\
  !*** ./src/libs/store-manager.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StoreManager": () => (/* binding */ StoreManager),
/* harmony export */   "getStoreManager": () => (/* binding */ getStoreManager)
/* harmony export */ });
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var StoreManager = /*#__PURE__*/function () {
  function StoreManager() {
    _classCallCheck(this, StoreManager);
    this.rootEl = document.documentElement;
    this.stores = {};
    this.cbs = {};
  }
  _createClass(StoreManager, [{
    key: "_checkInit",
    value: function _checkInit(initialStore) {
      if (!initialStore || initialStore == 'undefined') return;
      var stores = typeof initialStore == 'string' ? JSON.parse(initialStore) : initialStore;
      for (var _i = 0, _Object$keys = Object.keys(stores); _i < _Object$keys.length; _i++) {
        var st = _Object$keys[_i];
        this.emit(st, stores[st]);
      }
      console.log('Initializated store manager');
    }
  }, {
    key: "addListener",
    value: function addListener(match, cb) {
      var _this = this;
      var regex = match instanceof RegExp ? match : new RegExp('^' + match + '.*$');
      var fFn = function fFn(event) {
        var pathChanged = event.detail.path;
        if (regex.test(pathChanged)) {
          cb(pathChanged, event.detail.newData, event.detail.oldData);
        }
      };
      this.rootEl.addEventListener('ecStoreChange', fFn);
      this.cbs[cb] = fFn;

      // check pre-init
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _i2, _Object$keys2, st;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              for (_i2 = 0, _Object$keys2 = Object.keys(_this.stores); _i2 < _Object$keys2.length; _i2++) {
                st = _Object$keys2[_i2];
                if (regex.test(st)) {
                  cb(st, _this.stores[st], {});
                }
              }
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  }, {
    key: "removeListener",
    value: function removeListener(match, cb) {
      var fFn = this.cbs[cb];
      this.rootEl.removeEventListener('ecStoreChange', fFn);
    }
  }, {
    key: "emitIncrement",
    value: function emitIncrement(path) {
      var oldValue = this._recLookup(this.stores, path);
      var newValue = 0;
      if (!oldValue) {
        newValue = 1;
      } else if (typeof newValue == 'number') {
        newValue = oldValue + 1;
      }
      this.emit(path, newValue);
    }
  }, {
    key: "emitDecrement",
    value: function emitDecrement(path) {
      var oldValue = this._recLookup(this.stores, path);
      var newValue = 0;
      if (!oldValue) {
        newValue = -1;
      } else if (typeof newValue == 'number') {
        newValue = oldValue - 1;
      }
      this.emit(path, newValue);
    }
  }, {
    key: "emitToggle",
    value: function emitToggle(path) {
      var oldValue = this._recLookup(this.stores, path);
      var newValue = true;
      if (typeof newValue == 'boolean') {
        newValue = !oldValue;
      }
      this.emit(path, newValue);
    }
  }, {
    key: "emit",
    value: function emit(path, data) {
      var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var oldData = this._recLookup(this.stores, path) || {};
      var newData = data;
      if (merge && _typeof(data) == 'object' && _typeof(oldData) == 'object') {
        newData = _objectSpread(_objectSpread({}, oldData), data);
      }

      //set store
      this.stores = this._recSetup(this.stores, path, newData);

      //send event
      var event = new CustomEvent('ecStoreChange', {
        detail: {
          path: path,
          oldData: oldData,
          newData: newData
        }
      });
      this.rootEl.dispatchEvent(event);
      console.debug("Changed store \"".concat(path, "\" to"), newData);
    }
  }, {
    key: "get",
    value: function get(path) {
      return this._recLookup(this.stores, path);
    }
  }, {
    key: "_recLookup",
    value: function _recLookup(obj, path) {
      if (!obj) return null;
      var parts = path.split('/');
      if (parts.length == 1) {
        return obj[parts[0]];
      }
      return this._recLookup(obj[parts[0]], parts.slice(1).join('/'));
    }
  }, {
    key: "_recSetup",
    value: function _recSetup(obj, path, data) {
      var nObj = obj;
      var parts = path.split('/');
      var iObj = obj[parts[0]] ? obj[parts[0]] : {};
      if (parts.length > 1) {
        nObj[parts[0]] = this._recSetup(iObj, parts.slice(1).join('/'), data);
      } else {
        nObj[parts[0]] = data;
      }
      return nObj;
    }
  }]);
  return StoreManager;
}();

/**
 *
 * @returns {StoreManager}
 */
var getStoreManager = function getStoreManager() {
  if (!window.rcStoreManager) {
    window.rcStoreManager = new StoreManager();
  }
  return window.rcStoreManager;
};

/***/ }),

/***/ "./src/libs/utils.js":
/*!***************************!*\
  !*** ./src/libs/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animationEnd": () => (/* binding */ animationEnd),
/* harmony export */   "buildQuery": () => (/* binding */ buildQuery),
/* harmony export */   "buildWaitForEvent": () => (/* binding */ buildWaitForEvent),
/* harmony export */   "calcLeft": () => (/* binding */ calcLeft),
/* harmony export */   "calcTop": () => (/* binding */ calcTop),
/* harmony export */   "dateToDiffTimeStr": () => (/* binding */ dateToDiffTimeStr),
/* harmony export */   "dateToStr": () => (/* binding */ dateToStr),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "delay": () => (/* binding */ delay),
/* harmony export */   "emptyElement": () => (/* binding */ emptyElement),
/* harmony export */   "getClosestAll": () => (/* binding */ getClosestAll),
/* harmony export */   "getFirstChild": () => (/* binding */ getFirstChild),
/* harmony export */   "getLastChild": () => (/* binding */ getLastChild),
/* harmony export */   "getNextSibling": () => (/* binding */ getNextSibling),
/* harmony export */   "getNextSiblingAll": () => (/* binding */ getNextSiblingAll),
/* harmony export */   "getPrevSibling": () => (/* binding */ getPrevSibling),
/* harmony export */   "getPrevSiblingAll": () => (/* binding */ getPrevSiblingAll),
/* harmony export */   "htmlToElement": () => (/* binding */ htmlToElement),
/* harmony export */   "isInViewport": () => (/* binding */ isInViewport),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isObjectEmpty": () => (/* binding */ isObjectEmpty),
/* harmony export */   "isPositive": () => (/* binding */ isPositive),
/* harmony export */   "isReferrerCurrentDomain": () => (/* binding */ isReferrerCurrentDomain),
/* harmony export */   "makeid": () => (/* binding */ makeid),
/* harmony export */   "mergeDeep": () => (/* binding */ mergeDeep),
/* harmony export */   "readFileAsync": () => (/* binding */ readFileAsync),
/* harmony export */   "timeInstant": () => (/* binding */ timeInstant),
/* harmony export */   "toUrlFriendly": () => (/* binding */ toUrlFriendly),
/* harmony export */   "transitionEnd": () => (/* binding */ transitionEnd)
/* harmony export */ });
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
///////////////////////////////////////////////////
//////////// PROMISIFY EVENT
///////////////////////////////////////////////////
var buildWaitForEvent = function buildWaitForEvent(eventName) {
  return function (node, func) {
    return new Promise(function (resolve, reject) {
      // reject for invalid node
      if (!(node instanceof window.HTMLElement || node instanceof window.SVGElement)) {
        return reject(new Error('tail-end: an HTML or SVG element is required.'));
      }

      // create the event handler
      var handler = function handler() {
        // unbind the handler
        node.removeEventListener(eventName, handler);
        // resolve the (now clean) node
        return resolve(node);
      };

      // bind the handler
      node.addEventListener(eventName, handler);

      // if it exists, call the function passing in the node
      if (typeof func === 'function') {
        window.requestAnimationFrame(function () {
          return func(node);
        });
      }
    });
  };
};

///////////////////////////////////////////////////
//////////// PROMISIFY ANIMATIONEND - TRANSITIONEND
///////////////////////////////////////////////////
var animationEnd = buildWaitForEvent('animationend');
var transitionEnd = buildWaitForEvent('transitionend');

///////////////////////////////////////////////////
//////////// DELAY
///////////////////////////////////////////////////
var delay = function delay(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
};

///////////////////////////////////////////////////
//////////// NEXT PREV SIBLINGS
///////////////////////////////////////////////////
var getNextSibling = function getNextSibling(elem, selector) {
  // Get the next sibling element
  var sibling = elem.nextElementSibling;

  // If there's no selector, return the first sibling
  if (!selector) return sibling;

  // If the sibling matches our selector, use it
  // If not, jump to the next sibling and continue the loop
  while (sibling) {
    if (sibling.matches && sibling.matches(selector)) return sibling;
    sibling = sibling.nextElementSibling;
  }
};
var getPrevSibling = function getPrevSibling(elem, selector) {
  // Get the next sibling element
  var sibling = elem.previousElementSibling;

  // If there's no selector, return the first sibling
  if (!selector) return sibling;

  // If the sibling matches our selector, use it
  // If not, jump to the next sibling and continue the loop
  while (sibling) {
    if (sibling.matches && sibling.matches(selector)) return sibling;
    sibling = sibling.previousElementSibling;
  }
};
var getNextSiblingAll = function getNextSiblingAll(elem, selector) {
  // Get the next sibling element
  var sibling = elem.nextElementSibling;
  var result = [];
  // If the sibling matches our selector, use it
  // If not, jump to the next sibling and continue the loop
  while (sibling) {
    if (sibling.matches && sibling.matches(selector)) result.push(sibling);
    sibling = sibling.nextElementSibling;
  }
  return result;
};
var getPrevSiblingAll = function getPrevSiblingAll(elem, selector) {
  // Get the next sibling element
  var sibling = elem.previousElementSibling;
  var result = [];
  // If the sibling matches our selector, use it
  // If not, jump to the next sibling and continue the loop
  while (sibling) {
    if (sibling.matches && sibling.matches(selector)) result.push(sibling);
    sibling = sibling.previousElementSibling;
  }
  return result;
};

///////////////////////////////////////////////////
//////////// FIRST AND LAST CHILD
///////////////////////////////////////////////////
var getFirstChild = function getFirstChild(elem, selector) {
  // Get the first child element
  var nodes = elem.children;
  if (nodes.length <= 0) return;

  // If there's no selector, return the first sibling
  if (!selector) return nodes[0];

  // If the child node matches our selector, use it
  // If not, jump to the next child and continue the loop
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].matches && nodes[i].matches(selector)) return nodes[i];
  }
};
var getLastChild = function getLastChild(elem, selector) {
  // Get the last child element
  var nodes = elem.children;
  if (nodes.length <= 0) return;

  // If there's no selector, return the last sibling
  if (!selector) return nodes[nodes.length - 1];

  // If the child node matches our selector, use it
  // If not, jump to the prev child and continue the loop
  for (var i = nodes.length - 1; i >= 0; i--) {
    if (nodes[i].matches && nodes[i].matches(selector)) return nodes[i];
  }
};
var getClosestAll = function getClosestAll(elem, selector) {
  var closestOne = function closestOne(el, arr) {
    if (!el) return arr;
    var clo = el.closest(selector);
    if (!clo) return arr;
    return closestOne(clo.parentElement, [clo].concat(_toConsumableArray(arr)));
  };
  return closestOne(elem, []);
};

///////////////////////////////////////////////////
//////////// CREATE QUERY PARAMETERS
///////////////////////////////////////////////////
var buildQuery = function buildQuery(obj) {
  return Object.entries(obj).map(function (pair) {
    return pair.map(encodeURIComponent).join('=');
  }).join('&');
};

///////////////////////////////////////////////////
//////////// HTML ELEMENTS
///////////////////////////////////////////////////
var htmlToElement = function htmlToElement(html) {
  var template = document.createElement('template');
  html = html.trim(); // Never return a text node of whitespace as the result
  template.innerHTML = html;
  return template.content.firstChild;
};
var emptyElement = function emptyElement(element) {
  while (element.firstChild) {
    element.removeChild(element.lastChild);
  }
};

///////////////////////////////////////////////////
//////////// OTHERS
///////////////////////////////////////////////////
var isPositive = function isPositive(value) {
  if (value == true || value == 'true' || value == 'S' || value == 's' || value == '1') {
    return true;
  }
  return false;
};

/**
 * Check if an object is null or empty
 * @param {*} obj
 * @returns
 */
var isObjectEmpty = function isObjectEmpty(obj) {
  return !obj || Object.keys(obj).length === 0 && Object.getPrototypeOf(obj) === Object.prototype;
};

///////////////////////////////////////////////////
//////////// DEBOUNCE
///////////////////////////////////////////////////
var debounce = function debounce(cb) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  var timeoutId = null;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    clearTimeout(timeoutId);
    timeoutId = window.setTimeout(function () {
      cb.apply(null, args);
    }, delay);
  };
};

///////////////////////////////////////////////////
//////////// MAKE ID
///////////////////////////////////////////////////
var makeid = function makeid(length) {
  var result = '';
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
};

///////////////////////////////////////////////////
//////////// TIME INSTANT
///////////////////////////////////////////////////
var timeInstant = function timeInstant(formattedHour) {
  var t0 = new Date();
  var t0split = formattedHour.split(':');
  t0.setHours(parseInt(t0split[0]));
  t0.setMinutes(parseInt(t0split[1]));
  return t0;
};

/**
 *
 * @param {String} text
 * @returns Convert a text to url friendly
 */
var toUrlFriendly = function toUrlFriendly(text) {
  var result = text.normalize('NFD').trim().toLowerCase().replaceAll(/\s|[//_:]/g, '-').replaceAll('[^a-z0-9-]', '');
  return result.length > 150 ? result.substring(0, 150) : result;
};

/**
 *
 * @returns true if referrer comes from current domain
 */
var isReferrerCurrentDomain = function isReferrerCurrentDomain() {
  if (!document.referrer) return false;
  try {
    var referrer = new URL(document.referrer);
    return referrer.origin === location.origin;
  } catch (e) {
    console.info('Cannot check referrer');
  }
  return false;
};
var isInViewport = function isInViewport(el) {
  var rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
};

///////////////////////////////////////////////////
//////////// CALCULATE OVERLAY POSITION
///////////////////////////////////////////////////
var calcTop = function calcTop(self, target) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var rect = target.getBoundingClientRect();
  var popHeight = self.clientHeight;
  var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  var top = rect.top + scrollTop + rect.height + 8;
  if (top + popHeight > document.documentElement.scrollHeight) {
    var diff = top + popHeight - document.documentElement.scrollHeight;
    top = top - diff - 8;
    top = top >= 0 ? top : 0;
  }
  return top + offset + 'px';
};
var calcLeft = function calcLeft(self, target) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var rect = target.getBoundingClientRect();
  var popWidth = self.clientWidth;
  var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
  var left = rect.left + scrollLeft;
  if (left + popWidth > document.documentElement.scrollWidth) {
    var diff = left + popWidth - document.documentElement.scrollWidth;
    left = left - diff - 8;
    left = left >= 0 ? left : 0;
  }
  return left + offset + 'px';
};

///////////////////////////////////////////////////
//////////// DEEP MERGE
///////////////////////////////////////////////////
var isObject = function isObject(item) {
  return item && _typeof(item) === 'object' && !Array.isArray(item);
};
var mergeDeep = function mergeDeep(target) {
  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }
  if (!sources.length) return target;
  var source = sources.shift();
  if (isObject(target) && isObject(source)) {
    for (var key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, _defineProperty({}, key, source[key]));
      }
    }
  }
  return mergeDeep.apply(void 0, [target].concat(sources));
};

///////////////////////////////////// FILE READ
var readFileAsync = function readFileAsync(file) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
};

////////////////////////////////////////
var dateToStr = function dateToStr(ms) {
  var withMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!ms) return;
  var date = new Date(ms);
  var str = date.toLocaleString();
  if (withMs) {
    return str + ' ' + String(date.getMilliseconds()).padStart(3, '0');
  }
  return str;
};
var dateToDiffTimeStr = function dateToDiffTimeStr(ms) {
  var withMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!ms) return;
  var date = new Date(ms);
  var str = "".concat(String(date.getUTCHours()).padStart(2, '0'), ":").concat(String(date.getMinutes()).padStart(2, '0'), ":").concat(String(date.getSeconds()).padStart(2, '0'));
  if (withMs) {
    return str + ' ' + String(date.getMilliseconds()).padStart(3, '0');
  }
  return str;
};

/***/ }),

/***/ "./src/components/c1-table/row-template.hbs":
/*!**************************************************!*\
  !*** ./src/components/c1-table/row-template.hbs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
    return "        <td class=\"px-5 py-3 text-sm bg-white border-b border-gray-200\">\n            <p class=\"text-gray-900 whitespace-no-wrap\">\n                "
    + container.escapeExpression(container.lambda(depth0, depth0))
    + "\n            </p>\n        </td>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "        <td class=\"px-5 py-3 text-sm bg-white border-b border-gray-200\">\n            <div class=\"flex flew-row justify-end\">\n"
    + ((stack1 = lookupProperty(helpers,"if").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"editEnabled") : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":12,"column":16},"end":{"line":33,"column":23}}})) != null ? stack1 : "")
    + "                <button\n                    class=\"flex items-center p-1 text-white bg-gray-500 rounded-full shadow hover:text-white-700 text-md\"\n                    title=\"Cancella\"\n                    ref=\"deleteRow\"\n                >\n                    <svg\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                        viewBox=\"0 0 24 24\"\n                        fill=\"currentColor\"\n                        class=\"w-4 h-4 pointer-events-none\"\n                    >\n                        <path\n                            fill-rule=\"evenodd\"\n                            d=\"M5.47 5.47a.75.75 0 011.06 0L12 10.94l5.47-5.47a.75.75 0 111.06 1.06L13.06 12l5.47 5.47a.75.75 0 11-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 01-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 010-1.06z\"\n                            clip-rule=\"evenodd\"\n                        />\n                    </svg>\n                </button>\n            </div>\n        </td>\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "                    <button\n                        class=\"flex items-center p-1 text-white bg-gray-500 rounded-full shadow hover:text-white-700 text-md mr-1\"\n                        title=\"Modifica\"\n                        ref=\"editRow\"\n                    >\n                        <svg\n                            xmlns=\"http://www.w3.org/2000/svg\"\n                            fill=\"none\"\n                            viewBox=\"0 0 24 24\"\n                            stroke-width=\"1.5\"\n                            stroke=\"currentColor\"\n                            class=\"w-4 h-4 pointer-events-none\"\n                        >\n                            <path\n                                stroke-linecap=\"round\"\n                                stroke-linejoin=\"round\"\n                                d=\"M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10\"\n                            />\n                        </svg>\n                    </button>\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<tr data-id=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"id") || (depth0 != null ? lookupProperty(depth0,"id") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"id","hash":{},"data":data,"loc":{"start":{"line":1,"column":13},"end":{"line":1,"column":19}}}) : helper)))
    + "\">\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,(depth0 != null ? lookupProperty(depth0,"data") : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":2,"column":4},"end":{"line":8,"column":13}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"actionDisabled") : depth0),{"name":"unless","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":9,"column":4},"end":{"line":54,"column":15}}})) != null ? stack1 : "")
    + "</tr>";
},"useData":true});

/***/ }),

/***/ "./src/components/c1-table/template.hbs":
/*!**********************************************!*\
  !*** ./src/components/c1-table/template.hbs ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<h2 class=\"font-semibold text-lg mr-4\">"
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"title") || (depth0 != null ? lookupProperty(depth0,"title") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"data":data,"loc":{"start":{"line":4,"column":64},"end":{"line":4,"column":73}}}) : helper)))
    + "</h2>";
},"3":function(container,depth0,helpers,partials,data) {
    var helper, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <form class=\"mt-4 md:mt-0 flex flex-col md:flex-row mb-0\" ref=\"filter\">\n                <div class=\"relative\">\n                    <input\n                        type=\"text\"\n                        id=\"&quot;form-subscribe-Filter\"\n                        class=\"rounded-lg border-transparent flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                        name=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"filterKey") || (depth0 != null ? lookupProperty(depth0,"filterKey") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"filterKey","hash":{},"data":data,"loc":{"start":{"line":17,"column":30},"end":{"line":17,"column":43}}}) : helper)))
    + "\"\n                        placeholder=\"Filtra...\"\n                    />\n                </div>\n                <button\n                    class=\"self-end mt-1 md:mt-0 md:ml-1 flex-shrink-0 px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                    type=\"submit\"\n                >\n                    Filtra\n                </button>\n            </form>\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "                            <th\n                                scope=\"col\"\n                                class=\"px-5 py-3 text-sm font-normal text-left text-gray-800 uppercase bg-white border-b border-gray-200\"\n                            >\n                                "
    + container.escapeExpression(container.lambda(depth0, depth0))
    + "\n                            </th>\n";
},"7":function(container,depth0,helpers,partials,data) {
    return "                            <th\n                                scope=\"col\"\n                                class=\"px-5 py-3 text-sm font-normal text-left text-gray-800 uppercase bg-white border-b border-gray-200 text-right\"\n                            >\n                                Azioni\n                            </th>\n";
},"9":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "                        "
    + ((stack1 = container.lambda(depth0, depth0)) != null ? stack1 : "")
    + "\n";
},"11":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "                <div class=\"flex flex-col items-center px-5 py-5 bg-white xs:flex-row xs:justify-between\">\n                    <div class=\"flex items-center\">\n                        <button\n                            type=\"button\"\n                            class=\"w-full p-4 text-base text-gray-600 bg-white border rounded-l-xl hover:bg-gray-100\"\n                            data-value=\"prev\"\n                            ref=\"pageBtn\"\n                        >\n                            <svg\n                                width=\"9\"\n                                fill=\"currentColor\"\n                                height=\"8\"\n                                class=\"\"\n                                viewBox=\"0 0 1792 1792\"\n                                xmlns=\"http://www.w3.org/2000/svg\"\n                            >\n                                <path\n                                    d=\"M1427 301l-531 531 531 531q19 19 19 45t-19 45l-166 166q-19 19-45 19t-45-19l-742-742q-19-19-19-45t19-45l742-742q19-19 45-19t45 19l166 166q19 19 19 45t-19 45z\"\n                                >\n                                </path>\n                            </svg>\n                        </button>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"pagination") : depth0),{"name":"each","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":82,"column":24},"end":{"line":91,"column":33}}})) != null ? stack1 : "")
    + "                        <button\n                            type=\"button\"\n                            class=\"w-full p-4 text-base text-gray-600 bg-white border-t border-b border-r rounded-r-xl hover:bg-gray-100\"\n                            data-value=\"next\"\n                            ref=\"pageBtn\"\n                        >\n                            <svg\n                                width=\"9\"\n                                fill=\"currentColor\"\n                                height=\"8\"\n                                class=\"\"\n                                viewBox=\"0 0 1792 1792\"\n                                xmlns=\"http://www.w3.org/2000/svg\"\n                            >\n                                <path\n                                    d=\"M1363 877l-742 742q-19 19-45 19t-45-19l-166-166q-19-19-19-45t19-45l531-531-531-531q-19-19-19-45t19-45l166-166q19-19 45-19t45 19l742 742q19 19 19 45t-19 45z\"\n                                >\n                                </path>\n                            </svg>\n                        </button>\n                    </div>\n                </div>\n";
},"12":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "                            <button\n                                type=\"button\"\n                                class=\"w-full px-4 py-2 text-base text-indigo-500 bg-white border-t border-b hover:bg-gray-100\"\n                                data-value=\""
    + alias4(((helper = (helper = lookupProperty(helpers,"value") || (depth0 != null ? lookupProperty(depth0,"value") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"value","hash":{},"data":data,"loc":{"start":{"line":86,"column":44},"end":{"line":86,"column":53}}}) : helper)))
    + "\"\n                                ref=\"pageBtn\"\n                            >\n                                "
    + alias4(((helper = (helper = lookupProperty(helpers,"label") || (depth0 != null ? lookupProperty(depth0,"label") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"label","hash":{},"data":data,"loc":{"start":{"line":89,"column":32},"end":{"line":89,"column":41}}}) : helper)))
    + "\n                            </button>\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"\">\n    <div class=\"flex flex-col md:flex-row justify-between md:items-center\">\n        <div class=\"flex flex-row items-center\">\n            "
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"title") : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":4,"column":12},"end":{"line":4,"column":85}}})) != null ? stack1 : "")
    + "\n            <div\n                class=\"flex items-center justify-center font-semibold p-2 text-gray-600 bg-white rounded-full shadow hover:text-gray-700 text-md shrink-0 w-10 h-10\"\n                ref=\"count\"\n            > "
    + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? lookupProperty(depth0,"rowsHtmls") : depth0)) != null ? lookupProperty(stack1,"length") : stack1), depth0))
    + " </div>\n        </div>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"filterKey") : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":10,"column":8},"end":{"line":28,"column":15}}})) != null ? stack1 : "")
    + "    </div>\n    <div class=\"py-4 overflow-x-auto\">\n        <div class=\"inline-block min-w-full overflow-hidden rounded-lg shadow\">\n            <table class=\"min-w-full leading-normal\">\n                <thead>\n                    <tr>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,(depth0 != null ? lookupProperty(depth0,"labels") : depth0),{"name":"each","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":35,"column":24},"end":{"line":42,"column":33}}})) != null ? stack1 : "")
    + ((stack1 = lookupProperty(helpers,"unless").call(alias1,(depth0 != null ? lookupProperty(depth0,"actionDisabled") : depth0),{"name":"unless","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":43,"column":24},"end":{"line":50,"column":35}}})) != null ? stack1 : "")
    + "                    </tr>\n                </thead>\n                <tbody ref=\"tbody\">\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,(depth0 != null ? lookupProperty(depth0,"rowsHtmls") : depth0),{"name":"each","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":54,"column":20},"end":{"line":56,"column":29}}})) != null ? stack1 : "")
    + "                </tbody>\n            </table>\n"
    + ((stack1 = lookupProperty(helpers,"if").call(alias1,(depth0 != null ? lookupProperty(depth0,"pagination") : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":59,"column":12},"end":{"line":114,"column":19}}})) != null ? stack1 : "")
    + "        </div>\n    </div>\n</div>";
},"useData":true});

/***/ }),

/***/ "./src/components/c2-nav/template.hbs":
/*!********************************************!*\
  !*** ./src/components/c2-nav/template.hbs ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "            <button\n                class=\"flex items-center justify-start w-full p-2 pl-6 my-2 text-gray-400 transition-colors duration-200 border-l-4 border-transparent hover:text-gray-800\"\n                ref=\"menuItem\"\n                data-destination=\"ps-"
    + alias4(((helper = (helper = lookupProperty(helpers,"id") || (depth0 != null ? lookupProperty(depth0,"id") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data,"loc":{"start":{"line":31,"column":37},"end":{"line":31,"column":43}}}) : helper)))
    + "\"\n                data-title=\""
    + alias4(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data,"loc":{"start":{"line":32,"column":28},"end":{"line":32,"column":36}}}) : helper)))
    + "\"\n            >\n                <span class=\"text-left\">\n                    <svg\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                        fill=\"none\"\n                        viewBox=\"0 0 24 24\"\n                        stroke-width=\"1.5\"\n                        stroke=\"currentColor\"\n                        class=\"w-6 h-6\"\n                    >\n                        <path\n                            stroke-linecap=\"round\"\n                            stroke-linejoin=\"round\"\n                            d=\"M4.5 12a7.5 7.5 0 0015 0m-15 0a7.5 7.5 0 1115 0m-15 0H3m16.5 0H21m-1.5 0H12m-8.457 3.077l1.41-.513m14.095-5.13l1.41-.513M5.106 17.785l1.15-.964m11.49-9.642l1.149-.964M7.501 19.795l.75-1.3m7.5-12.99l.75-1.3m-6.063 16.658l.26-1.477m2.605-14.772l.26-1.477m0 17.726l-.26-1.477M10.698 4.614l-.26-1.477M16.5 19.794l-.75-1.299M7.5 4.205L12 12m6.894 5.785l-1.149-.964M6.256 7.178l-1.15-.964m15.352 8.864l-1.41-.513M4.954 9.435l-1.41-.514M12.002 12l-3.75 6.495\"\n                        />\n                    </svg>\n\n                </span>\n                <span class=\"mx-2 text-sm font-normal\">\n                    "
    + alias4(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data,"loc":{"start":{"line":52,"column":20},"end":{"line":52,"column":28}}}) : helper)))
    + "\n                </span>\n            </button>\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<nav class=\"mt-6\">\n    <div>\n        <button\n            class=\"flex items-center justify-start w-full p-2 pl-6 my-2 text-gray-400 transition-colors duration-200 border-l-4 border-transparent hover:text-gray-800 active:text-gray-800\"\n            ref=\"menuItem\"\n            data-destination=\"dashboard\"\n            data-title=\"Dashboard\"\n        >\n            <span class=\"text-left\">\n                <svg\n                    width=\"20\"\n                    height=\"20\"\n                    fill=\"currentColor\"\n                    viewBox=\"0 0 1792 1792\"\n                    xmlns=\"http://www.w3.org/2000/svg\"\n                >\n                    <path\n                        d=\"M1472 992v480q0 26-19 45t-45 19h-384v-384h-256v384h-384q-26 0-45-19t-19-45v-480q0-1 .5-3t.5-3l575-474 575 474q1 2 1 6zm223-69l-62 74q-8 9-21 11h-3q-13 0-21-7l-692-577-692 577q-12 8-24 7-13-2-21-11l-62-74q-8-10-7-23.5t11-21.5l719-599q32-26 76-26t76 26l244 204v-195q0-14 9-23t23-9h192q14 0 23 9t9 23v408l219 182q10 8 11 21.5t-7 23.5z\"\n                    >\n                    </path>\n                </svg>\n            </span>\n            <span class=\"mx-2 text-sm font-normal\">\n                Dashboard\n            </span>\n        </button>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? lookupProperty(depth0,"ps") : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":27,"column":8},"end":{"line":55,"column":17}}})) != null ? stack1 : "")
    + "        <button\n            class=\"flex items-center justify-start w-full p-2 pl-6 my-2 text-gray-400 transition-colors duration-200 border-l-4 border-transparent hover:text-gray-800\"\n            ref=\"menuItem\"\n            data-destination=\"runner\"\n            data-title=\"Corridori\"\n        >\n            <span class=\"text-left\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\" class=\"w-6 h-6\">\n                    <path\n                        d=\"M4.5 6.375a4.125 4.125 0 118.25 0 4.125 4.125 0 01-8.25 0zM14.25 8.625a3.375 3.375 0 116.75 0 3.375 3.375 0 01-6.75 0zM1.5 19.125a7.125 7.125 0 0114.25 0v.003l-.001.119a.75.75 0 01-.363.63 13.067 13.067 0 01-6.761 1.873c-2.472 0-4.786-.684-6.76-1.873a.75.75 0 01-.364-.63l-.001-.122zM17.25 19.128l-.001.144a2.25 2.25 0 01-.233.96 10.088 10.088 0 005.06-1.01.75.75 0 00.42-.643 4.875 4.875 0 00-6.957-4.611 8.586 8.586 0 011.71 5.157v.003z\"\n                    />\n                </svg>\n\n            </span>\n            <span class=\"mx-2 text-sm font-normal\">\n                Corridori\n            </span>\n        </button>\n        <button\n            class=\"flex items-center justify-start w-full p-2 pl-6 my-2 text-gray-400 transition-colors duration-200 border-l-4 border-transparent hover:text-gray-800\"\n            ref=\"menuItem\"\n            data-destination=\"race\"\n            data-title=\"Gara\"\n        >\n            <span class=\"text-left\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\" class=\"w-6 h-6\">\n                    <path\n                        d=\"M17.004 10.407c.138.435-.216.842-.672.842h-3.465a.75.75 0 01-.65-.375l-1.732-3c-.229-.396-.053-.907.393-1.004a5.252 5.252 0 016.126 3.537zM8.12 8.464c.307-.338.838-.235 1.066.16l1.732 3a.75.75 0 010 .75l-1.732 3.001c-.229.396-.76.498-1.067.16A5.231 5.231 0 016.75 12c0-1.362.519-2.603 1.37-3.536zM10.878 17.13c-.447-.097-.623-.608-.394-1.003l1.733-3.003a.75.75 0 01.65-.375h3.465c.457 0 .81.408.672.843a5.252 5.252 0 01-6.126 3.538z\"\n                    />\n                    <path\n                        fill-rule=\"evenodd\"\n                        d=\"M21 12.75a.75.75 0 000-1.5h-.783a8.22 8.22 0 00-.237-1.357l.734-.267a.75.75 0 10-.513-1.41l-.735.268a8.24 8.24 0 00-.689-1.191l.6-.504a.75.75 0 10-.964-1.149l-.6.504a8.3 8.3 0 00-1.054-.885l.391-.678a.75.75 0 10-1.299-.75l-.39.677a8.188 8.188 0 00-1.295-.471l.136-.77a.75.75 0 00-1.477-.26l-.136.77a8.364 8.364 0 00-1.377 0l-.136-.77a.75.75 0 10-1.477.26l.136.77c-.448.121-.88.28-1.294.47l-.39-.676a.75.75 0 00-1.3.75l.392.678a8.29 8.29 0 00-1.054.885l-.6-.504a.75.75 0 00-.965 1.149l.6.503a8.243 8.243 0 00-.689 1.192L3.8 8.217a.75.75 0 10-.513 1.41l.735.267a8.222 8.222 0 00-.238 1.355h-.783a.75.75 0 000 1.5h.783c.042.464.122.917.238 1.356l-.735.268a.75.75 0 10.513 1.41l.735-.268c.197.417.428.816.69 1.192l-.6.504a.75.75 0 10.963 1.149l.601-.505c.326.323.679.62 1.054.885l-.392.68a.75.75 0 101.3.75l.39-.679c.414.192.847.35 1.294.471l-.136.771a.75.75 0 101.477.26l.137-.772a8.376 8.376 0 001.376 0l.136.773a.75.75 0 101.477-.26l-.136-.772a8.19 8.19 0 001.294-.47l.391.677a.75.75 0 101.3-.75l-.393-.679a8.282 8.282 0 001.054-.885l.601.504a.75.75 0 10.964-1.15l-.6-.503a8.24 8.24 0 00.69-1.191l.735.268a.75.75 0 10.512-1.41l-.734-.268c.115-.438.195-.892.237-1.356h.784zm-2.657-3.06a6.744 6.744 0 00-1.19-2.053 6.784 6.784 0 00-1.82-1.51A6.704 6.704 0 0012 5.25a6.801 6.801 0 00-1.225.111 6.7 6.7 0 00-2.15.792 6.784 6.784 0 00-2.952 3.489.758.758 0 01-.036.099A6.74 6.74 0 005.251 12a6.739 6.739 0 003.355 5.835l.01.006.01.005a6.706 6.706 0 002.203.802c.007 0 .014.002.021.004a6.792 6.792 0 002.301 0l.022-.004a6.707 6.707 0 002.228-.816 6.781 6.781 0 001.762-1.483l.009-.01.009-.012a6.744 6.744 0 001.18-2.064c.253-.708.39-1.47.39-2.264a6.74 6.74 0 00-.408-2.308z\"\n                        clip-rule=\"evenodd\"\n                    />\n                </svg>\n            </span>\n            <span class=\"mx-2 text-sm font-normal\">\n                Gara\n            </span>\n        </button>\n    </div>\n</nav>";
},"useData":true});

/***/ }),

/***/ "./src/components/l1-app/template.hbs":
/*!********************************************!*\
  !*** ./src/components/l1-app/template.hbs ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div ref=\"content\">\n    <m0-racer></m0-racer>\n</div>";
},"useData":true});

/***/ }),

/***/ "./src/components/l2-main/template.hbs":
/*!*********************************************!*\
  !*** ./src/components/l2-main/template.hbs ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, alias1=container.lambda, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<main class=\"relative h-screen overflow-hidden bg-gray-100 dark:bg-gray-800\">\n    <div class=\"flex items-start justify-between\">\n        <div\n            class=\"-left-80 lg:left-0 transition-all absolute lg:relative h-screen shadow-lg lg:block w-80 z-50 shrink-0\"\n            ref=\"drawerMenu\"\n        >\n            <div class=\"h-full bg-white dark:bg-gray-700\">\n                <div class=\"flex items-center justify-start pt-6 ml-8\">\n                    <p class=\"text-2xl font-bold dark:text-white\">\n                        Lighpass V2\n                    </p>\n                </div>\n                <c2-nav ref=\"nav\"></c2-nav>\n            </div>\n        </div>\n        <div class=\"flex flex-col w-full space-y-2 md:space-y-4\">\n            <header class=\"z-40 flex items-center justify-between w-full h-16\">\n                <div class=\"flex flex-col justify-end h-full px-3 lg:hidden\">\n                    <div class=\"relative flex items-center justify-end w-full p-1 space-x-4\">\n                        <button\n                            class=\"flex items-center p-2 text-gray-500 bg-white rounded-full shadow text-md\"\n                            ref=\"menuBtn\"\n                        >\n                            <svg\n                                class=\"w-6 h-6\"\n                                class=\"text-gray-400\"\n                                fill=\"currentColor\"\n                                viewBox=\"0 0 1792 1792\"\n                                xmlns=\"http://www.w3.org/2000/svg\"\n                            >\n                                <path\n                                    d=\"M1664 1344v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45zm0-512v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45zm0-512v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45z\"\n                                >\n                                </path>\n                            </svg>\n                        </button>\n                    </div>\n                </div>\n                <div class=\"relative z-20 flex flex-col justify-end h-full px-3 md:w-full\">\n                    <div class=\"relative flex items-center justify-end w-full p-1 space-x-4\">\n                        <button\n                            class=\"flex items-center p-2 text-red-600 bg-white rounded-full shadow hover:text-gray-700 text-md\"\n                            title=\"Chiudi Gara\"\n                            ref=\"closeRace\"\n                        >\n                            <svg\n                                xmlns=\"http://www.w3.org/2000/svg\"\n                                viewBox=\"0 0 24 24\"\n                                fill=\"currentColor\"\n                                class=\"w-6 h-6\"\n                            >\n                                <path\n                                    fill-rule=\"evenodd\"\n                                    d=\"M5.47 5.47a.75.75 0 011.06 0L12 10.94l5.47-5.47a.75.75 0 111.06 1.06L13.06 12l5.47 5.47a.75.75 0 11-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 01-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 010-1.06z\"\n                                    clip-rule=\"evenodd\"\n                                />\n                            </svg>\n\n                        </button>\n\n                    </div>\n                </div>\n            </header>\n            <div class=\"h-screen px-4 pb-24 overflow-auto md:px-6\">\n                <h1 class=\"text-4xl font-semibold text-gray-800 dark:text-white mb-4\" ref=\"dashboardTitle\">\n                    "
    + container.escapeExpression(alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"location") : depth0)) != null ? lookupProperty(stack1,"title") : stack1), depth0))
    + "\n                </h1>\n                <div ref=\"dashboardContent\">\n                    "
    + ((stack1 = alias1(((stack1 = (depth0 != null ? lookupProperty(depth0,"location") : depth0)) != null ? lookupProperty(stack1,"content") : stack1), depth0)) != null ? stack1 : "")
    + "\n                </div>\n            </div>\n        </div>\n    </div>\n</main>";
},"useData":true});

/***/ }),

/***/ "./src/components/m0-racer/template.hbs":
/*!**********************************************!*\
  !*** ./src/components/m0-racer/template.hbs ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"1":function(container,depth0,helpers,partials,data) {
    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.hooks.helperMissing, alias3="function", alias4=container.escapeExpression, lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "                                <option value=\""
    + alias4(((helper = (helper = lookupProperty(helpers,"id") || (depth0 != null ? lookupProperty(depth0,"id") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data,"loc":{"start":{"line":19,"column":47},"end":{"line":19,"column":53}}}) : helper)))
    + "\">\n                                    "
    + alias4(((helper = (helper = lookupProperty(helpers,"name") || (depth0 != null ? lookupProperty(depth0,"name") : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data,"loc":{"start":{"line":20,"column":36},"end":{"line":20,"column":44}}}) : helper)))
    + "\n                                </option>\n";
},"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), lookupProperty = container.lookupProperty || function(parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return parent[propertyName];
        }
        return undefined
    };

  return "<div class=\"flex flex-wrap w-full\">\n    <div class=\"flex flex-col w-full md:w-1/2 justify-center\">\n        <div class=\"flex flex-col justify-center px-8 pt-8 my-4 md:pt-0 md:px-24 lg:px-32\">\n            <p class=\"text-3xl text-center\">\n                Selezione una Gara\n            </p>\n            <form class=\"flex flex-col pt-3\" ref=\"selectRace\">\n                <div class=\"flex flex-col pt-4 pb-4\">\n                    <div class=\"flex relative\">\n\n                        <select\n                            class=\"w-full block px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary-500 focus:border-primary-500\"\n                            name=\"name\"\n                        >\n                            <option value=\"\">\n                                Seleziona una gara\n                            </option>\n"
    + ((stack1 = lookupProperty(helpers,"each").call(alias1,(depth0 != null ? lookupProperty(depth0,"options") : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data,"loc":{"start":{"line":18,"column":28},"end":{"line":22,"column":37}}})) != null ? stack1 : "")
    + "                        </select>\n\n                    </div>\n                </div>\n                <button\n                    type=\"submit\"\n                    class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                >\n                    <span class=\"w-full\">\n                        Seleziona\n                    </span>\n                </button>\n            </form>\n        </div>\n        <div class=\"flex items-center justify-center\">\n            <hr class=\"w-16\" />\n            <div class=\"px-5\">O</div>\n            <hr class=\"w-16\" />\n        </div>\n        <div class=\"flex flex-col justify-center px-8 pt-8 my-4 md:pt-0 md:px-24 lg:px-32\">\n            <p class=\"text-3xl text-center\">\n                Crea una Gara\n            </p>\n            <form class=\"flex flex-col pt-3 md:pt-8\" ref=\"createRace\">\n                <div class=\"flex flex-col pt-4 pb-4\">\n                    <div class=\"flex relative\">\n                        <input\n                            type=\"text\"\n                            class=\"flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-purple-600 focus:border-transparent\"\n                            name=\"name\"\n                            placeholder=\"es: E Ben Sa Ghe 2023\"\n                        />\n                    </div>\n                </div>\n                <button\n                    class=\"flex-shrink-0 px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                    type=\"submit\"\n                >\n                    <span class=\"w-full\">\n                        Crea\n                    </span>\n                </button>\n            </form>\n        </div>\n    </div>\n    <div class=\"w-1/2 shadow-2xl\">\n        <img class=\"hidden object-cover w-full h-screen md:block\" src=\""
    + container.escapeExpression(((helper = (helper = lookupProperty(helpers,"img") || (depth0 != null ? lookupProperty(depth0,"img") : depth0)) != null ? helper : container.hooks.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"img","hash":{},"data":data,"loc":{"start":{"line":69,"column":71},"end":{"line":69,"column":78}}}) : helper)))
    + "\" />\n    </div>\n</div>";
},"useData":true});

/***/ }),

/***/ "./src/components/m1-dashboard/template.hbs":
/*!**************************************************!*\
  !*** ./src/components/m1-dashboard/template.hbs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"lg:flex w-full\">\n    <div class=\"w-full lg:w-2/3 lg:pr-2\">\n\n        <div class=\"mb-8\">\n            <c1-table\n                labels=\"id,Data\"\n                keys=\"id,time\"\n                orderBy=\"time\"\n                rowsKey=\"time\"\n                orderDir=\"desc\"\n                editEnabled=\"true\"\n                title=\"Tempi non assegnati\"\n                ref=\"timeTable\"\n            ></c1-table>\n        </div>\n\n        <div>\n            <c1-table\n                labels=\"ID,Time,PS,Data,Nome,Num\"\n                keys=\"id,assignedIdTime,assignedPs,assignedTime,assignedName,assigned\"\n                filterKey=\"assignedName\"\n                orderBy=\"assigned\"\n                rowsKey=\"take\"\n                title=\"Tempi assegnati\"\n                ref=\"takeTable\"\n            ></c1-table>\n        </div>\n    </div>\n    <div class=\"w-full lg:w-1/3\">\n        <form\n            class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden transition-colors\"\n            ref=\"assignTime\"\n        >\n\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"relative mt-6\">\n                    <div class=\"relative flex justify-center text-base leading-5 font-semibold\">\n                        <span class=\"px-2 text-gray-500\">\n                            Assegna\n                        </span>\n                    </div>\n                </div>\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    required\n                                    placeholder=\"Time ID\"\n                                    name=\"id\"\n                                    readonly\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    required\n                                    placeholder=\"Time\"\n                                    name=\"timeStr\"\n                                    readonly\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    required\n                                    placeholder=\"PS\"\n                                    name=\"psName\"\n                                />\n                            </div>\n                        </div>\n\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    required\n                                    placeholder=\"Corridore (Numero)\"\n                                    name=\"runnerNum\"\n                                />\n                            </div>\n                        </div>\n\n                        <div class=\"w-full\">\n\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"submit\"\n                            >\n                                Assegna\n                            </button>\n\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </form>\n\n    </div>\n</div>";
},"useData":true});

/***/ }),

/***/ "./src/components/m2-race/template.hbs":
/*!*********************************************!*\
  !*** ./src/components/m2-race/template.hbs ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"lg:flex w-full\">\n    <div class=\"w-full lg:w-2/3 lg:pr-2\">\n        <c1-table\n            labels=\"ID,Nome,Gap,Start,Ordine\"\n            keys=\"id,name,gap,start,order\"\n            filterKey=\"name\"\n            orderBy=\"name\"\n            ref=\"table\"\n        ></c1-table>\n    </div>\n    <div class=\"w-full lg:w-1/3\">\n\n        <form class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden\" ref=\"createPs\">\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"relative mt-6\">\n                    <div class=\"relative flex justify-center text-base leading-5 font-semibold\">\n                        <span class=\"px-2 text-gray-500 bg-white\">\n                            Nuova PS\n                        </span>\n                    </div>\n                </div>\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    required\n                                    placeholder=\"Nome\"\n                                    name=\"name\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"datetime-local\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    required\n                                    placeholder=\"Start\"\n                                    name=\"start\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    placeholder=\"Gap\"\n                                    required\n                                    name=\"gap\"\n                                    pattern=\"[0-9]+\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <select\n                                    class=\"w-full block px-3 py-2 text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-primary-500 focus:border-primary-500\"\n                                    name=\"order\"\n                                    required\n                                >\n                                    <option value=\"asc\">\n                                        Crescente\n                                    </option>\n                                    <option value=\"desc\">\n                                        Decrescente\n                                    </option>\n                                </select>\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"submit\"\n                            >\n                                Crea\n                            </button>\n\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </form>\n\n        <form class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden\" ref=\"uploadPs\">\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"relative mt-6\">\n                    <div class=\"relative flex justify-center text-base leading-5 font-semibold\">\n                        <span class=\"px-2 text-gray-500 bg-white\">\n                            Carica PS\n                        </span>\n                    </div>\n                </div>\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"file\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    placeholder=\"File\"\n                                    required\n                                    name=\"file\"\n                                    pattern=\"[0-9]+\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"submit\"\n                            >\n                                Carica\n                            </button>\n\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </form>\n\n        <div class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden\">\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"button\"\n                                ref=\"download\"\n                            >\n                                Scarica CSV\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>";
},"useData":true});

/***/ }),

/***/ "./src/components/m3-runners/template.hbs":
/*!************************************************!*\
  !*** ./src/components/m3-runners/template.hbs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"lg:flex w-full\">\n    <div class=\"w-full lg:w-2/3 lg:pr-2\">\n        <c1-table\n            labels=\"ID,Nome,Numero,Categoria\"\n            keys=\"id,name,number,category\"\n            filterKey=\"name\"\n            orderBy=\"number\"\n            ref=\"table\"\n        ></c1-table>\n    </div>\n    <div class=\"w-full lg:w-1/3\">\n\n        <form class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden\" ref=\"createRunner\">\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"relative mt-6\">\n                    <div class=\"relative flex justify-center text-base leading-5 font-semibold\">\n                        <span class=\"px-2 text-gray-500 bg-white\">\n                            Nuovo Corridore\n                        </span>\n                    </div>\n                </div>\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    required\n                                    placeholder=\"Nome\"\n                                    name=\"name\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    placeholder=\"Numero\"\n                                    required\n                                    name=\"number\"\n                                    pattern=\"[0-9]+\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"text\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    placeholder=\"Categoria\"\n                                    required\n                                    name=\"category\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"submit\"\n                            >\n                                Crea\n                            </button>\n\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </form>\n\n        <form class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden\" ref=\"uploadRunner\">\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"relative mt-6\">\n                    <div class=\"relative flex justify-center text-base leading-5 font-semibold\">\n                        <span class=\"px-2 text-gray-500 bg-white\">\n                            Carica Corridori\n                        </span>\n                    </div>\n                </div>\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <div class=\"relative\">\n                                <input\n                                    type=\"file\"\n                                    class=\"rounded-lg flex-1 appearance-none border border-gray-300 w-full py-2 px-4 bg-white text-gray-700 placeholder-gray-400 shadow-sm text-base focus:outline-none focus:ring-2 focus:ring-gray-600 focus:border-transparent\"\n                                    placeholder=\"File\"\n                                    required\n                                    name=\"file\"\n                                    pattern=\"[0-9]+\"\n                                />\n                            </div>\n                        </div>\n                        <div class=\"w-full\">\n\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"submit\"\n                            >\n                                Carica\n                            </button>\n\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </form>\n\n        <div class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden\">\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"button\"\n                                ref=\"download\"\n                            >\n                                Scarica CSV\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>";
},"useData":true});

/***/ }),

/***/ "./src/components/m4-score/template.hbs":
/*!**********************************************!*\
  !*** ./src/components/m4-score/template.hbs ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Handlebars = __webpack_require__(/*! ../../../node_modules/handlebars/runtime.js */ "./node_modules/handlebars/runtime.js");
function __default(obj) { return obj && (obj.__esModule ? obj["default"] : obj); }
module.exports = (Handlebars["default"] || Handlebars).template({"compiler":[8,">= 4.3.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<div class=\"lg:flex w-full\">\n    <div class=\"w-full lg:w-2/3 lg:pr-2\">\n        <c1-table\n            labels=\"ID,Numero,Nome,Start,End,Diff\"\n            keys=\"id,number,name,start,end,diff\"\n            filterKey=\"name\"\n            orderBy=\"diff\"\n            actionDisabled=\"true\"\n            ref=\"table\"\n        ></c1-table>\n    </div>\n    <div class=\"w-full lg:w-1/3\">\n         <div class=\"bg-white rounded-lg shadow sm:max-w-md sm:w-full sm:mx-auto sm:overflow-hidden\">\n            <div class=\"px-4 py-8 sm:px-10\">\n                <div class=\"mt-6\">\n                    <div class=\"w-full space-y-6\">\n                        <div class=\"w-full\">\n                            <button\n                                class=\"w-full px-4 py-2 text-base font-semibold text-white bg-gray-500 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 focus:ring-offset-gray-200\"\n                                type=\"button\"\n                                ref=\"download\"\n                            >\n                                Scarica CSV\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>";
},"useData":true});

/***/ }),

/***/ "./src/main.css":
/*!**********************!*\
  !*** ./src/main.css ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/race.webp":
/*!******************************!*\
  !*** ./src/assets/race.webp ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "50f1df4936dcd3211275.webp";

/***/ }),

/***/ "./node_modules/dexie/dist/modern/dexie.mjs":
/*!**************************************************!*\
  !*** ./node_modules/dexie/dist/modern/dexie.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dexie": () => (/* binding */ Dexie$1),
/* harmony export */   "RangeSet": () => (/* binding */ RangeSet),
/* harmony export */   "default": () => (/* binding */ Dexie$1),
/* harmony export */   "liveQuery": () => (/* binding */ liveQuery),
/* harmony export */   "mergeRanges": () => (/* binding */ mergeRanges),
/* harmony export */   "rangesOverlap": () => (/* binding */ rangesOverlap)
/* harmony export */ });
/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 3.2.3, Mon Jan 23 2023
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */
 
const _global = typeof globalThis !== 'undefined' ? globalThis :
    typeof self !== 'undefined' ? self :
        typeof window !== 'undefined' ? window :
            global;

const keys = Object.keys;
const isArray = Array.isArray;
if (typeof Promise !== 'undefined' && !_global.Promise) {
    _global.Promise = Promise;
}
function extend(obj, extension) {
    if (typeof extension !== 'object')
        return obj;
    keys(extension).forEach(function (key) {
        obj[key] = extension[key];
    });
    return obj;
}
const getProto = Object.getPrototypeOf;
const _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
    return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
    if (typeof extension === 'function')
        extension = extension(getProto(proto));
    (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(key => {
        setProp(proto, key, extension[key]);
    });
}
const defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options) {
    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ?
        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :
        { value: functionOrGetSet, configurable: true, writable: true }, options));
}
function derive(Child) {
    return {
        from: function (Parent) {
            Child.prototype = Object.create(Parent.prototype);
            setProp(Child.prototype, "constructor", Child);
            return {
                extend: props.bind(null, Child.prototype)
            };
        }
    };
}
const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
    const pd = getOwnPropertyDescriptor(obj, prop);
    let proto;
    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
const _slice = [].slice;
function slice(args, start, end) {
    return _slice.call(args, start, end);
}
function override(origFunc, overridedFactory) {
    return overridedFactory(origFunc);
}
function assert(b) {
    if (!b)
        throw new Error("Assertion Failed");
}
function asap$1(fn) {
    if (_global.setImmediate)
        setImmediate(fn);
    else
        setTimeout(fn, 0);
}
function arrayToObject(array, extractor) {
    return array.reduce((result, item, i) => {
        var nameAndValue = extractor(item, i);
        if (nameAndValue)
            result[nameAndValue[0]] = nameAndValue[1];
        return result;
    }, {});
}
function tryCatch(fn, onerror, args) {
    try {
        fn.apply(null, args);
    }
    catch (ex) {
        onerror && onerror(ex);
    }
}
function getByKeyPath(obj, keyPath) {
    if (hasOwn(obj, keyPath))
        return obj[keyPath];
    if (!keyPath)
        return obj;
    if (typeof keyPath !== 'string') {
        var rv = [];
        for (var i = 0, l = keyPath.length; i < l; ++i) {
            var val = getByKeyPath(obj, keyPath[i]);
            rv.push(val);
        }
        return rv;
    }
    var period = keyPath.indexOf('.');
    if (period !== -1) {
        var innerObj = obj[keyPath.substr(0, period)];
        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
    }
    return undefined;
}
function setByKeyPath(obj, keyPath, value) {
    if (!obj || keyPath === undefined)
        return;
    if ('isFrozen' in Object && Object.isFrozen(obj))
        return;
    if (typeof keyPath !== 'string' && 'length' in keyPath) {
        assert(typeof value !== 'string' && 'length' in value);
        for (var i = 0, l = keyPath.length; i < l; ++i) {
            setByKeyPath(obj, keyPath[i], value[i]);
        }
    }
    else {
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var currentKeyPath = keyPath.substr(0, period);
            var remainingKeyPath = keyPath.substr(period + 1);
            if (remainingKeyPath === "")
                if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                        obj.splice(currentKeyPath, 1);
                    else
                        delete obj[currentKeyPath];
                }
                else
                    obj[currentKeyPath] = value;
            else {
                var innerObj = obj[currentKeyPath];
                if (!innerObj || !hasOwn(obj, currentKeyPath))
                    innerObj = (obj[currentKeyPath] = {});
                setByKeyPath(innerObj, remainingKeyPath, value);
            }
        }
        else {
            if (value === undefined) {
                if (isArray(obj) && !isNaN(parseInt(keyPath)))
                    obj.splice(keyPath, 1);
                else
                    delete obj[keyPath];
            }
            else
                obj[keyPath] = value;
        }
    }
}
function delByKeyPath(obj, keyPath) {
    if (typeof keyPath === 'string')
        setByKeyPath(obj, keyPath, undefined);
    else if ('length' in keyPath)
        [].map.call(keyPath, function (kp) {
            setByKeyPath(obj, kp, undefined);
        });
}
function shallowClone(obj) {
    var rv = {};
    for (var m in obj) {
        if (hasOwn(obj, m))
            rv[m] = obj[m];
    }
    return rv;
}
const concat = [].concat;
function flatten(a) {
    return concat.apply([], a);
}
const intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey"
    .split(',').concat(flatten([8, 16, 32, 64].map(num => ["Int", "Uint", "Float"].map(t => t + num + "Array")))).filter(t => _global[t]);
const intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);
arrayToObject(intrinsicTypeNames, x => [x, true]);
let circularRefs = null;
function deepClone(any) {
    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();
    const rv = innerDeepClone(any);
    circularRefs = null;
    return rv;
}
function innerDeepClone(any) {
    if (!any || typeof any !== 'object')
        return any;
    let rv = circularRefs && circularRefs.get(any);
    if (rv)
        return rv;
    if (isArray(any)) {
        rv = [];
        circularRefs && circularRefs.set(any, rv);
        for (var i = 0, l = any.length; i < l; ++i) {
            rv.push(innerDeepClone(any[i]));
        }
    }
    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
        rv = any;
    }
    else {
        const proto = getProto(any);
        rv = proto === Object.prototype ? {} : Object.create(proto);
        circularRefs && circularRefs.set(any, rv);
        for (var prop in any) {
            if (hasOwn(any, prop)) {
                rv[prop] = innerDeepClone(any[prop]);
            }
        }
    }
    return rv;
}
const { toString } = {};
function toStringTag(o) {
    return toString.call(o).slice(8, -1);
}
const iteratorSymbol = typeof Symbol !== 'undefined' ?
    Symbol.iterator :
    '@@iterator';
const getIteratorOf = typeof iteratorSymbol === "symbol" ? function (x) {
    var i;
    return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function () { return null; };
const NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
    var i, a, x, it;
    if (arguments.length === 1) {
        if (isArray(arrayLike))
            return arrayLike.slice();
        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')
            return [arrayLike];
        if ((it = getIteratorOf(arrayLike))) {
            a = [];
            while ((x = it.next()), !x.done)
                a.push(x.value);
            return a;
        }
        if (arrayLike == null)
            return [arrayLike];
        i = arrayLike.length;
        if (typeof i === 'number') {
            a = new Array(i);
            while (i--)
                a[i] = arrayLike[i];
            return a;
        }
        return [arrayLike];
    }
    i = arguments.length;
    a = new Array(i);
    while (i--)
        a[i] = arguments[i];
    return a;
}
const isAsyncFunction = typeof Symbol !== 'undefined'
    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'
    : () => false;

var debug = typeof location !== 'undefined' &&
    /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter) {
    debug = value;
    libraryFilter = filter;
}
var libraryFilter = () => true;
const NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
    if (NEEDS_THROW_FOR_STACK)
        try {
            getErrorWithStack.arguments;
            throw new Error();
        }
        catch (e) {
            return e;
        }
    return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
    var stack = exception.stack;
    if (!stack)
        return "";
    numIgnoredFrames = (numIgnoredFrames || 0);
    if (stack.indexOf(exception.name) === 0)
        numIgnoredFrames += (exception.name + exception.message).split('\n').length;
    return stack.split('\n')
        .slice(numIgnoredFrames)
        .filter(libraryFilter)
        .map(frame => "\n" + frame)
        .join('');
}

var dexieErrorNames = [
    'Modify',
    'Bulk',
    'OpenFailed',
    'VersionChange',
    'Schema',
    'Upgrade',
    'InvalidTable',
    'MissingAPI',
    'NoSuchDatabase',
    'InvalidArgument',
    'SubTransaction',
    'Unsupported',
    'Internal',
    'DatabaseClosed',
    'PrematureCommit',
    'ForeignAwait'
];
var idbDomErrorNames = [
    'Unknown',
    'Constraint',
    'Data',
    'TransactionInactive',
    'ReadOnly',
    'Version',
    'NotFound',
    'InvalidState',
    'InvalidAccess',
    'Abort',
    'Timeout',
    'QuotaExceeded',
    'Syntax',
    'DataClone'
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
    VersionChanged: "Database version changed by other database connection",
    DatabaseClosed: "Database has been closed",
    Abort: "Transaction aborted",
    TransactionInactive: "Transaction has already completed or failed",
    MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
    this._e = getErrorWithStack();
    this.name = name;
    this.message = msg;
}
derive(DexieError).from(Error).extend({
    stack: {
        get: function () {
            return this._stack ||
                (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
        }
    },
    toString: function () { return this.name + ": " + this.message; }
});
function getMultiErrorMessage(msg, failures) {
    return msg + ". Errors: " + Object.keys(failures)
        .map(key => failures[key].toString())
        .filter((v, i, s) => s.indexOf(v) === i)
        .join('\n');
}
function ModifyError(msg, failures, successCount, failedKeys) {
    this._e = getErrorWithStack();
    this.failures = failures;
    this.failedKeys = failedKeys;
    this.successCount = successCount;
    this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
    this._e = getErrorWithStack();
    this.name = "BulkError";
    this.failures = Object.keys(failures).map(pos => failures[pos]);
    this.failuresByPos = failures;
    this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
const BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
    var fullName = name + "Error";
    function DexieError(msgOrInner, inner) {
        this._e = getErrorWithStack();
        this.name = fullName;
        if (!msgOrInner) {
            this.message = defaultTexts[name] || fullName;
            this.inner = null;
        }
        else if (typeof msgOrInner === 'string') {
            this.message = `${msgOrInner}${!inner ? '' : '\n ' + inner}`;
            this.inner = inner || null;
        }
        else if (typeof msgOrInner === 'object') {
            this.message = `${msgOrInner.name} ${msgOrInner.message}`;
            this.inner = msgOrInner;
        }
    }
    derive(DexieError).from(BaseException);
    obj[name] = DexieError;
    return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
    obj[name + "Error"] = exceptions[name];
    return obj;
}, {});
function mapError(domError, message) {
    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
        return domError;
    var rv = new exceptionMap[domError.name](message || domError.message, domError);
    if ("stack" in domError) {
        setProp(rv, "stack", { get: function () {
                return this.inner.stack;
            } });
    }
    return rv;
}
var fullNameExceptions = errorList.reduce((obj, name) => {
    if (["Syntax", "Type", "Range"].indexOf(name) === -1)
        obj[name + "Error"] = exceptions[name];
    return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;

function nop() { }
function mirror(val) { return val; }
function pureFunctionChain(f1, f2) {
    if (f1 == null || f1 === mirror)
        return f2;
    return function (val) {
        return f2(f1(val));
    };
}
function callBoth(on1, on2) {
    return function () {
        on1.apply(this, arguments);
        on2.apply(this, arguments);
    };
}
function hookCreatingChain(f1, f2) {
    if (f1 === nop)
        return f2;
    return function () {
        var res = f1.apply(this, arguments);
        if (res !== undefined)
            arguments[0] = res;
        var onsuccess = this.onsuccess,
        onerror = this.onerror;
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res2 !== undefined ? res2 : res;
    };
}
function hookDeletingChain(f1, f2) {
    if (f1 === nop)
        return f2;
    return function () {
        f1.apply(this, arguments);
        var onsuccess = this.onsuccess,
        onerror = this.onerror;
        this.onsuccess = this.onerror = null;
        f2.apply(this, arguments);
        if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    };
}
function hookUpdatingChain(f1, f2) {
    if (f1 === nop)
        return f2;
    return function (modifications) {
        var res = f1.apply(this, arguments);
        extend(modifications, res);
        var onsuccess = this.onsuccess,
        onerror = this.onerror;
        this.onsuccess = null;
        this.onerror = null;
        var res2 = f2.apply(this, arguments);
        if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
        if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        return res === undefined ?
            (res2 === undefined ? undefined : res2) :
            (extend(res, res2));
    };
}
function reverseStoppableEventChain(f1, f2) {
    if (f1 === nop)
        return f2;
    return function () {
        if (f2.apply(this, arguments) === false)
            return false;
        return f1.apply(this, arguments);
    };
}
function promisableChain(f1, f2) {
    if (f1 === nop)
        return f2;
    return function () {
        var res = f1.apply(this, arguments);
        if (res && typeof res.then === 'function') {
            var thiz = this, i = arguments.length, args = new Array(i);
            while (i--)
                args[i] = arguments[i];
            return res.then(function () {
                return f2.apply(thiz, args);
            });
        }
        return f2.apply(this, arguments);
    };
}

var INTERNAL = {};
const LONG_STACKS_CLIP_LIMIT = 100,
MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?
    [] :
    (() => {
        let globalP = Promise.resolve();
        if (typeof crypto === 'undefined' || !crypto.subtle)
            return [globalP, getProto(globalP), globalP];
        const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [
            nativeP,
            getProto(nativeP),
            globalP
        ];
    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
const NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
const patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ?
    () => { resolvedGlobalPromise.then(physicalTick); }
    :
        _global.setImmediate ?
            setImmediate.bind(null, physicalTick) :
            _global.MutationObserver ?
                () => {
                    var hiddenDiv = document.createElement("div");
                    (new MutationObserver(() => {
                        physicalTick();
                        hiddenDiv = null;
                    })).observe(hiddenDiv, { attributes: true });
                    hiddenDiv.setAttribute('i', '1');
                } :
                () => { setTimeout(physicalTick, 0); };
var asap = function (callback, args) {
    microtickQueue.push([callback, args]);
    if (needsNewPhysicalTick) {
        schedulePhysicalTick();
        needsNewPhysicalTick = false;
    }
};
var isOutsideMicroTick = true,
needsNewPhysicalTick = true,
unhandledErrors = [],
rejectingErrors = [],
currentFulfiller = null, rejectionMapper = mirror;
var globalPSD = {
    id: 'global',
    global: true,
    ref: 0,
    unhandleds: [],
    onunhandled: globalError,
    pgp: false,
    env: {},
    finalize: function () {
        this.unhandleds.forEach(uh => {
            try {
                globalError(uh[0], uh[1]);
            }
            catch (e) { }
        });
    }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn) {
    if (typeof this !== 'object')
        throw new TypeError('Promises must be constructed via new');
    this._listeners = [];
    this.onuncatched = nop;
    this._lib = false;
    var psd = (this._PSD = PSD);
    if (debug) {
        this._stackHolder = getErrorWithStack();
        this._prev = null;
        this._numPrev = 0;
    }
    if (typeof fn !== 'function') {
        if (fn !== INTERNAL)
            throw new TypeError('Not a function');
        this._state = arguments[1];
        this._value = arguments[2];
        if (this._state === false)
            handleRejection(this, this._value);
        return;
    }
    this._state = null;
    this._value = null;
    ++psd.ref;
    executePromiseTask(this, fn);
}
const thenProp = {
    get: function () {
        var psd = PSD, microTaskId = totalEchoes;
        function then(onFulfilled, onRejected) {
            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
            const cleanup = possibleAwait && !decrementExpectedAwaits();
            var rv = new DexiePromise((resolve, reject) => {
                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
            });
            debug && linkToPreviousPromise(rv, this);
            return rv;
        }
        then.prototype = INTERNAL;
        return then;
    },
    set: function (value) {
        setProp(this, 'then', value && value.prototype === INTERNAL ?
            thenProp :
            {
                get: function () {
                    return value;
                },
                set: thenProp.set
            });
    }
};
props(DexiePromise.prototype, {
    then: thenProp,
    _then: function (onFulfilled, onRejected) {
        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
    },
    catch: function (onRejected) {
        if (arguments.length === 1)
            return this.then(null, onRejected);
        var type = arguments[0], handler = arguments[1];
        return typeof type === 'function' ? this.then(null, err =>
        err instanceof type ? handler(err) : PromiseReject(err))
            : this.then(null, err =>
            err && err.name === type ? handler(err) : PromiseReject(err));
    },
    finally: function (onFinally) {
        return this.then(value => {
            onFinally();
            return value;
        }, err => {
            onFinally();
            return PromiseReject(err);
        });
    },
    stack: {
        get: function () {
            if (this._stack)
                return this._stack;
            try {
                stack_being_generated = true;
                var stacks = getStack(this, [], MAX_LONG_STACKS);
                var stack = stacks.join("\nFrom previous: ");
                if (this._state !== null)
                    this._stack = stack;
                return stack;
            }
            finally {
                stack_being_generated = false;
            }
        }
    },
    timeout: function (ms, msg) {
        return ms < Infinity ?
            new DexiePromise((resolve, reject) => {
                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);
                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
            }) : this;
    }
});
if (typeof Symbol !== 'undefined' && Symbol.toStringTag)
    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve, reject, zone) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.resolve = resolve;
    this.reject = reject;
    this.psd = zone;
}
props(DexiePromise, {
    all: function () {
        var values = getArrayOf.apply(null, arguments)
            .map(onPossibleParallellAsync);
        return new DexiePromise(function (resolve, reject) {
            if (values.length === 0)
                resolve([]);
            var remaining = values.length;
            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {
                values[i] = x;
                if (!--remaining)
                    resolve(values);
            }, reject));
        });
    },
    resolve: value => {
        if (value instanceof DexiePromise)
            return value;
        if (value && typeof value.then === 'function')
            return new DexiePromise((resolve, reject) => {
                value.then(resolve, reject);
            });
        var rv = new DexiePromise(INTERNAL, true, value);
        linkToPreviousPromise(rv, currentFulfiller);
        return rv;
    },
    reject: PromiseReject,
    race: function () {
        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
        return new DexiePromise((resolve, reject) => {
            values.map(value => DexiePromise.resolve(value).then(resolve, reject));
        });
    },
    PSD: {
        get: () => PSD,
        set: value => PSD = value
    },
    totalEchoes: { get: () => totalEchoes },
    newPSD: newScope,
    usePSD: usePSD,
    scheduler: {
        get: () => asap,
        set: value => { asap = value; }
    },
    rejectionMapper: {
        get: () => rejectionMapper,
        set: value => { rejectionMapper = value; }
    },
    follow: (fn, zoneProps) => {
        return new DexiePromise((resolve, reject) => {
            return newScope((resolve, reject) => {
                var psd = PSD;
                psd.unhandleds = [];
                psd.onunhandled = reject;
                psd.finalize = callBoth(function () {
                    run_at_end_of_this_or_next_physical_tick(() => {
                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);
                    });
                }, psd.finalize);
                fn();
            }, zoneProps, resolve, reject);
        });
    }
});
if (NativePromise) {
    if (NativePromise.allSettled)
        setProp(DexiePromise, "allSettled", function () {
            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(resolve => {
                if (possiblePromises.length === 0)
                    resolve([]);
                let remaining = possiblePromises.length;
                const results = new Array(remaining);
                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: "fulfilled", value }, reason => results[i] = { status: "rejected", reason })
                    .then(() => --remaining || resolve(results)));
            });
        });
    if (NativePromise.any && typeof AggregateError !== 'undefined')
        setProp(DexiePromise, "any", function () {
            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise((resolve, reject) => {
                if (possiblePromises.length === 0)
                    reject(new AggregateError([]));
                let remaining = possiblePromises.length;
                const failures = new Array(remaining);
                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {
                    failures[i] = failure;
                    if (!--remaining)
                        reject(new AggregateError(failures));
                }));
            });
        });
}
function executePromiseTask(promise, fn) {
    try {
        fn(value => {
            if (promise._state !== null)
                return;
            if (value === promise)
                throw new TypeError('A promise cannot be resolved with itself.');
            var shouldExecuteTick = promise._lib && beginMicroTickScope();
            if (value && typeof value.then === 'function') {
                executePromiseTask(promise, (resolve, reject) => {
                    value instanceof DexiePromise ?
                        value._then(resolve, reject) :
                        value.then(resolve, reject);
                });
            }
            else {
                promise._state = true;
                promise._value = value;
                propagateAllListeners(promise);
            }
            if (shouldExecuteTick)
                endMicroTickScope();
        }, handleRejection.bind(null, promise));
    }
    catch (ex) {
        handleRejection(promise, ex);
    }
}
function handleRejection(promise, reason) {
    rejectingErrors.push(reason);
    if (promise._state !== null)
        return;
    var shouldExecuteTick = promise._lib && beginMicroTickScope();
    reason = rejectionMapper(reason);
    promise._state = false;
    promise._value = reason;
    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {
        var origProp = getPropertyDescriptor(reason, "stack");
        reason._promise = promise;
        setProp(reason, "stack", {
            get: () => stack_being_generated ?
                origProp && (origProp.get ?
                    origProp.get.apply(reason) :
                    origProp.value) :
                promise.stack
        });
    });
    addPossiblyUnhandledError(promise);
    propagateAllListeners(promise);
    if (shouldExecuteTick)
        endMicroTickScope();
}
function propagateAllListeners(promise) {
    var listeners = promise._listeners;
    promise._listeners = [];
    for (var i = 0, len = listeners.length; i < len; ++i) {
        propagateToListener(promise, listeners[i]);
    }
    var psd = promise._PSD;
    --psd.ref || psd.finalize();
    if (numScheduledCalls === 0) {
        ++numScheduledCalls;
        asap(() => {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
        }, []);
    }
}
function propagateToListener(promise, listener) {
    if (promise._state === null) {
        promise._listeners.push(listener);
        return;
    }
    var cb = promise._state ? listener.onFulfilled : listener.onRejected;
    if (cb === null) {
        return (promise._state ? listener.resolve : listener.reject)(promise._value);
    }
    ++listener.psd.ref;
    ++numScheduledCalls;
    asap(callListener, [cb, promise, listener]);
}
function callListener(cb, promise, listener) {
    try {
        currentFulfiller = promise;
        var ret, value = promise._value;
        if (promise._state) {
            ret = cb(value);
        }
        else {
            if (rejectingErrors.length)
                rejectingErrors = [];
            ret = cb(value);
            if (rejectingErrors.indexOf(value) === -1)
                markErrorAsHandled(promise);
        }
        listener.resolve(ret);
    }
    catch (e) {
        listener.reject(e);
    }
    finally {
        currentFulfiller = null;
        if (--numScheduledCalls === 0)
            finalizePhysicalTick();
        --listener.psd.ref || listener.psd.finalize();
    }
}
function getStack(promise, stacks, limit) {
    if (stacks.length === limit)
        return stacks;
    var stack = "";
    if (promise._state === false) {
        var failure = promise._value, errorName, message;
        if (failure != null) {
            errorName = failure.name || "Error";
            message = failure.message || failure;
            stack = prettyStack(failure, 0);
        }
        else {
            errorName = failure;
            message = "";
        }
        stacks.push(errorName + (message ? ": " + message : "") + stack);
    }
    if (debug) {
        stack = prettyStack(promise._stackHolder, 2);
        if (stack && stacks.indexOf(stack) === -1)
            stacks.push(stack);
        if (promise._prev)
            getStack(promise._prev, stacks, limit);
    }
    return stacks;
}
function linkToPreviousPromise(promise, prev) {
    var numPrev = prev ? prev._numPrev + 1 : 0;
    if (numPrev < LONG_STACKS_CLIP_LIMIT) {
        promise._prev = prev;
        promise._numPrev = numPrev;
    }
}
function physicalTick() {
    beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
    var wasRootExec = isOutsideMicroTick;
    isOutsideMicroTick = false;
    needsNewPhysicalTick = false;
    return wasRootExec;
}
function endMicroTickScope() {
    var callbacks, i, l;
    do {
        while (microtickQueue.length > 0) {
            callbacks = microtickQueue;
            microtickQueue = [];
            l = callbacks.length;
            for (i = 0; i < l; ++i) {
                var item = callbacks[i];
                item[0].apply(null, item[1]);
            }
        }
    } while (microtickQueue.length > 0);
    isOutsideMicroTick = true;
    needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
    var unhandledErrs = unhandledErrors;
    unhandledErrors = [];
    unhandledErrs.forEach(p => {
        p._PSD.onunhandled.call(null, p._value, p);
    });
    var finalizers = tickFinalizers.slice(0);
    var i = finalizers.length;
    while (i)
        finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn) {
    function finalizer() {
        fn();
        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
    }
    tickFinalizers.push(finalizer);
    ++numScheduledCalls;
    asap(() => {
        if (--numScheduledCalls === 0)
            finalizePhysicalTick();
    }, []);
}
function addPossiblyUnhandledError(promise) {
    if (!unhandledErrors.some(p => p._value === promise._value))
        unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
    var i = unhandledErrors.length;
    while (i)
        if (unhandledErrors[--i]._value === promise._value) {
            unhandledErrors.splice(i, 1);
            return;
        }
}
function PromiseReject(reason) {
    return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn, errorCatcher) {
    var psd = PSD;
    return function () {
        var wasRootExec = beginMicroTickScope(), outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn.apply(this, arguments);
        }
        catch (e) {
            errorCatcher && errorCatcher(e);
        }
        finally {
            switchToZone(outerScope, false);
            if (wasRootExec)
                endMicroTickScope();
        }
    };
}
const task = { awaits: 0, echoes: 0, id: 0 };
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn, props, a1, a2) {
    var parent = PSD, psd = Object.create(parent);
    psd.parent = parent;
    psd.ref = 0;
    psd.global = false;
    psd.id = ++zone_id_counter;
    var globalEnv = globalPSD.env;
    psd.env = patchGlobalPromise ? {
        Promise: DexiePromise,
        PromiseProp: { value: DexiePromise, configurable: true, writable: true },
        all: DexiePromise.all,
        race: DexiePromise.race,
        allSettled: DexiePromise.allSettled,
        any: DexiePromise.any,
        resolve: DexiePromise.resolve,
        reject: DexiePromise.reject,
        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
    } : {};
    if (props)
        extend(psd, props);
    ++parent.ref;
    psd.finalize = function () {
        --this.parent.ref || this.parent.finalize();
    };
    var rv = usePSD(psd, fn, a1, a2);
    if (psd.ref === 0)
        psd.finalize();
    return rv;
}
function incrementExpectedAwaits() {
    if (!task.id)
        task.id = ++taskCounter;
    ++task.awaits;
    task.echoes += ZONE_ECHO_LIMIT;
    return task.id;
}
function decrementExpectedAwaits() {
    if (!task.awaits)
        return false;
    if (--task.awaits === 0)
        task.id = 0;
    task.echoes = task.awaits * ZONE_ECHO_LIMIT;
    return true;
}
if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
    incrementExpectedAwaits = decrementExpectedAwaits = nop;
}
function onPossibleParallellAsync(possiblePromise) {
    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
        incrementExpectedAwaits();
        return possiblePromise.then(x => {
            decrementExpectedAwaits();
            return x;
        }, e => {
            decrementExpectedAwaits();
            return rejection(e);
        });
    }
    return possiblePromise;
}
function zoneEnterEcho(targetZone) {
    ++totalEchoes;
    if (!task.echoes || --task.echoes === 0) {
        task.echoes = task.id = 0;
    }
    zoneStack.push(PSD);
    switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
    var zone = zoneStack[zoneStack.length - 1];
    zoneStack.pop();
    switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
    var currentZone = PSD;
    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
    }
    if (targetZone === PSD)
        return;
    PSD = targetZone;
    if (currentZone === globalPSD)
        globalPSD.env = snapShot();
    if (patchGlobalPromise) {
        var GlobalPromise = globalPSD.env.Promise;
        var targetEnv = targetZone.env;
        nativePromiseProto.then = targetEnv.nthen;
        GlobalPromise.prototype.then = targetEnv.gthen;
        if (currentZone.global || targetZone.global) {
            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
            GlobalPromise.all = targetEnv.all;
            GlobalPromise.race = targetEnv.race;
            GlobalPromise.resolve = targetEnv.resolve;
            GlobalPromise.reject = targetEnv.reject;
            if (targetEnv.allSettled)
                GlobalPromise.allSettled = targetEnv.allSettled;
            if (targetEnv.any)
                GlobalPromise.any = targetEnv.any;
        }
    }
}
function snapShot() {
    var GlobalPromise = _global.Promise;
    return patchGlobalPromise ? {
        Promise: GlobalPromise,
        PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
        all: GlobalPromise.all,
        race: GlobalPromise.race,
        allSettled: GlobalPromise.allSettled,
        any: GlobalPromise.any,
        resolve: GlobalPromise.resolve,
        reject: GlobalPromise.reject,
        nthen: nativePromiseProto.then,
        gthen: GlobalPromise.prototype.then
    } : {};
}
function usePSD(psd, fn, a1, a2, a3) {
    var outerScope = PSD;
    try {
        switchToZone(psd, true);
        return fn(a1, a2, a3);
    }
    finally {
        switchToZone(outerScope, false);
    }
}
function enqueueNativeMicroTask(job) {
    nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
    return typeof fn !== 'function' ? fn : function () {
        var outerZone = PSD;
        if (possibleAwait)
            incrementExpectedAwaits();
        switchToZone(zone, true);
        try {
            return fn.apply(this, arguments);
        }
        finally {
            switchToZone(outerZone, false);
            if (cleanup)
                enqueueNativeMicroTask(decrementExpectedAwaits);
        }
    };
}
function getPatchedPromiseThen(origThen, zone) {
    return function (onResolved, onRejected) {
        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
    };
}
const UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
    var rv;
    try {
        rv = promise.onuncatched(err);
    }
    catch (e) { }
    if (rv !== false)
        try {
            var event, eventData = { promise: promise, reason: err };
            if (_global.document && document.createEvent) {
                event = document.createEvent('Event');
                event.initEvent(UNHANDLEDREJECTION, true, true);
                extend(event, eventData);
            }
            else if (_global.CustomEvent) {
                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
                extend(event, eventData);
            }
            if (event && _global.dispatchEvent) {
                dispatchEvent(event);
                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
                    try {
                        _global.onunhandledrejection(event);
                    }
                    catch (_) { }
            }
            if (debug && event && !event.defaultPrevented) {
                console.warn(`Unhandled rejection: ${err.stack || err}`);
            }
        }
        catch (e) { }
}
var rejection = DexiePromise.reject;

function tempTransaction(db, mode, storeNames, fn) {
    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {
        if (db._state.openComplete) {
            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
        }
        if (!db._state.isBeingOpened) {
            if (!db._options.autoOpen)
                return rejection(new exceptions.DatabaseClosed());
            db.open().catch(nop);
        }
        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));
    }
    else {
        var trans = db._createTransaction(mode, storeNames, db._dbSchema);
        try {
            trans.create();
            db._state.PR1398_maxLoop = 3;
        }
        catch (ex) {
            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                console.warn('Dexie: Need to reopen db');
                db._close();
                return db.open().then(() => tempTransaction(db, mode, storeNames, fn));
            }
            return rejection(ex);
        }
        return trans._promise(mode, (resolve, reject) => {
            return newScope(() => {
                PSD.trans = trans;
                return fn(resolve, reject, trans);
            });
        }).then(result => {
            return trans._completion.then(() => result);
        });
    }
}

const DEXIE_VERSION = '3.2.3';
const maxString = String.fromCharCode(65535);
const minKey = -Infinity;
const INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
const STRING_EXPECTED = "String expected.";
const connections = [];
const isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
const hasIEDeleteObjectStoreBug = isIEOrEdge;
const hangsOnDeleteLargeKeyRange = isIEOrEdge;
const dexieStackFrameFilter = frame => !/(dexie\.js|dexie\.min\.js)/.test(frame);
const DBNAMES_DB = '__dbnames';
const READONLY = 'readonly';
const READWRITE = 'readwrite';

function combine(filter1, filter2) {
    return filter1 ?
        filter2 ?
            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :
            filter1 :
        filter2;
}

const AnyRange = {
    type: 3 ,
    lower: -Infinity,
    lowerOpen: false,
    upper: [[]],
    upperOpen: false
};

function workaroundForUndefinedPrimKey(keyPath) {
    return typeof keyPath === "string" && !/\./.test(keyPath)
        ? (obj) => {
            if (obj[keyPath] === undefined && (keyPath in obj)) {
                obj = deepClone(obj);
                delete obj[keyPath];
            }
            return obj;
        }
        : (obj) => obj;
}

class Table {
    _trans(mode, fn, writeLocked) {
        const trans = this._tx || PSD.trans;
        const tableName = this.name;
        function checkTableInTransaction(resolve, reject, trans) {
            if (!trans.schema[tableName])
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            return fn(trans.idbtrans, trans);
        }
        const wasRootExec = beginMicroTickScope();
        try {
            return trans && trans.db === this.db ?
                trans === PSD.trans ?
                    trans._promise(mode, checkTableInTransaction, writeLocked) :
                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :
                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
        }
        finally {
            if (wasRootExec)
                endMicroTickScope();
        }
    }
    get(keyOrCrit, cb) {
        if (keyOrCrit && keyOrCrit.constructor === Object)
            return this.where(keyOrCrit).first(cb);
        return this._trans('readonly', (trans) => {
            return this.core.get({ trans, key: keyOrCrit })
                .then(res => this.hook.reading.fire(res));
        }).then(cb);
    }
    where(indexOrCrit) {
        if (typeof indexOrCrit === 'string')
            return new this.db.WhereClause(this, indexOrCrit);
        if (isArray(indexOrCrit))
            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);
        const keyPaths = keys(indexOrCrit);
        if (keyPaths.length === 1)
            return this
                .where(keyPaths[0])
                .equals(indexOrCrit[keyPaths[0]]);
        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&
            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&
            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];
        if (compoundIndex && this.db._maxKey !== maxString)
            return this
                .where(compoundIndex.name)
                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));
        if (!compoundIndex && debug)
            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +
                `compound index [${keyPaths.join('+')}]`);
        const { idxByName } = this.schema;
        const idb = this.db._deps.indexedDB;
        function equals(a, b) {
            try {
                return idb.cmp(a, b) === 0;
            }
            catch (e) {
                return false;
            }
        }
        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
            const index = idxByName[keyPath];
            const value = indexOrCrit[keyPath];
            return [
                prevIndex || index,
                prevIndex || !index ?
                    combine(prevFilterFn, index && index.multi ?
                        x => {
                            const prop = getByKeyPath(x, keyPath);
                            return isArray(prop) && prop.some(item => equals(value, item));
                        } : x => equals(value, getByKeyPath(x, keyPath)))
                    : prevFilterFn
            ];
        }, [null, null]);
        return idx ?
            this.where(idx.name).equals(indexOrCrit[idx.keyPath])
                .filter(filterFunction) :
            compoundIndex ?
                this.filter(filterFunction) :
                this.where(keyPaths).equals('');
    }
    filter(filterFunction) {
        return this.toCollection().and(filterFunction);
    }
    count(thenShortcut) {
        return this.toCollection().count(thenShortcut);
    }
    offset(offset) {
        return this.toCollection().offset(offset);
    }
    limit(numRows) {
        return this.toCollection().limit(numRows);
    }
    each(callback) {
        return this.toCollection().each(callback);
    }
    toArray(thenShortcut) {
        return this.toCollection().toArray(thenShortcut);
    }
    toCollection() {
        return new this.db.Collection(new this.db.WhereClause(this));
    }
    orderBy(index) {
        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?
            `[${index.join('+')}]` :
            index));
    }
    reverse() {
        return this.toCollection().reverse();
    }
    mapToClass(constructor) {
        this.schema.mappedClass = constructor;
        const readHook = obj => {
            if (!obj)
                return obj;
            const res = Object.create(constructor.prototype);
            for (var m in obj)
                if (hasOwn(obj, m))
                    try {
                        res[m] = obj[m];
                    }
                    catch (_) { }
            return res;
        };
        if (this.schema.readHook) {
            this.hook.reading.unsubscribe(this.schema.readHook);
        }
        this.schema.readHook = readHook;
        this.hook("reading", readHook);
        return constructor;
    }
    defineClass() {
        function Class(content) {
            extend(this, content);
        }
        return this.mapToClass(Class);
    }
    add(obj, key) {
        const { auto, keyPath } = this.schema.primKey;
        let objToAdd = obj;
        if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
        }
        return this._trans('readwrite', trans => {
            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });
        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)
            .then(lastResult => {
            if (keyPath) {
                try {
                    setByKeyPath(obj, keyPath, lastResult);
                }
                catch (_) { }
            }
            return lastResult;
        });
    }
    update(keyOrObject, modifications) {
        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
            if (key === undefined)
                return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
            try {
                if (typeof modifications !== "function") {
                    keys(modifications).forEach(keyPath => {
                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
                    });
                }
                else {
                    modifications(keyOrObject, { value: keyOrObject, primKey: key });
                }
            }
            catch (_a) {
            }
            return this.where(":id").equals(key).modify(modifications);
        }
        else {
            return this.where(":id").equals(keyOrObject).modify(modifications);
        }
    }
    put(obj, key) {
        const { auto, keyPath } = this.schema.primKey;
        let objToAdd = obj;
        if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
        }
        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))
            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)
            .then(lastResult => {
            if (keyPath) {
                try {
                    setByKeyPath(obj, keyPath, lastResult);
                }
                catch (_) { }
            }
            return lastResult;
        });
    }
    delete(key) {
        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))
            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);
    }
    clear() {
        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))
            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);
    }
    bulkGet(keys) {
        return this._trans('readonly', trans => {
            return this.core.getMany({
                keys,
                trans
            }).then(result => result.map(res => this.hook.reading.fire(res)));
        });
    }
    bulkAdd(objects, keysOrOptions, options) {
        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
        options = options || (keys ? undefined : keysOrOptions);
        const wantResults = options ? options.allKeys : undefined;
        return this._trans('readwrite', trans => {
            const { auto, keyPath } = this.schema.primKey;
            if (keyPath && keys)
                throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
            if (keys && keys.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            const numObjects = objects.length;
            let objectsToAdd = keyPath && auto ?
                objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                objects;
            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })
                .then(({ numFailures, results, lastResult, failures }) => {
                const result = wantResults ? results : lastResult;
                if (numFailures === 0)
                    return result;
                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
            });
        });
    }
    bulkPut(objects, keysOrOptions, options) {
        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
        options = options || (keys ? undefined : keysOrOptions);
        const wantResults = options ? options.allKeys : undefined;
        return this._trans('readwrite', trans => {
            const { auto, keyPath } = this.schema.primKey;
            if (keyPath && keys)
                throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
            if (keys && keys.length !== objects.length)
                throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            const numObjects = objects.length;
            let objectsToPut = keyPath && auto ?
                objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                objects;
            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })
                .then(({ numFailures, results, lastResult, failures }) => {
                const result = wantResults ? results : lastResult;
                if (numFailures === 0)
                    return result;
                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
            });
        });
    }
    bulkDelete(keys) {
        const numKeys = keys.length;
        return this._trans('readwrite', trans => {
            return this.core.mutate({ trans, type: 'delete', keys: keys });
        }).then(({ numFailures, lastResult, failures }) => {
            if (numFailures === 0)
                return lastResult;
            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
        });
    }
}

function Events(ctx) {
    var evs = {};
    var rv = function (eventName, subscriber) {
        if (subscriber) {
            var i = arguments.length, args = new Array(i - 1);
            while (--i)
                args[i - 1] = arguments[i];
            evs[eventName].subscribe.apply(null, args);
            return ctx;
        }
        else if (typeof (eventName) === 'string') {
            return evs[eventName];
        }
    };
    rv.addEventType = add;
    for (var i = 1, l = arguments.length; i < l; ++i) {
        add(arguments[i]);
    }
    return rv;
    function add(eventName, chainFunction, defaultFunction) {
        if (typeof eventName === 'object')
            return addConfiguredEvents(eventName);
        if (!chainFunction)
            chainFunction = reverseStoppableEventChain;
        if (!defaultFunction)
            defaultFunction = nop;
        var context = {
            subscribers: [],
            fire: defaultFunction,
            subscribe: function (cb) {
                if (context.subscribers.indexOf(cb) === -1) {
                    context.subscribers.push(cb);
                    context.fire = chainFunction(context.fire, cb);
                }
            },
            unsubscribe: function (cb) {
                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });
                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
            }
        };
        evs[eventName] = rv[eventName] = context;
        return context;
    }
    function addConfiguredEvents(cfg) {
        keys(cfg).forEach(function (eventName) {
            var args = cfg[eventName];
            if (isArray(args)) {
                add(eventName, cfg[eventName][0], cfg[eventName][1]);
            }
            else if (args === 'asap') {
                var context = add(eventName, mirror, function fire() {
                    var i = arguments.length, args = new Array(i);
                    while (i--)
                        args[i] = arguments[i];
                    context.subscribers.forEach(function (fn) {
                        asap$1(function fireEvent() {
                            fn.apply(null, args);
                        });
                    });
                });
            }
            else
                throw new exceptions.InvalidArgument("Invalid event config");
        });
    }
}

function makeClassConstructor(prototype, constructor) {
    derive(constructor).from({ prototype });
    return constructor;
}

function createTableConstructor(db) {
    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
        this.db = db;
        this._tx = trans;
        this.name = name;
        this.schema = tableSchema;
        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
            "creating": [hookCreatingChain, nop],
            "reading": [pureFunctionChain, mirror],
            "updating": [hookUpdatingChain, nop],
            "deleting": [hookDeletingChain, nop]
        });
    });
}

function isPlainKeyRange(ctx, ignoreLimitFilter) {
    return !(ctx.filter || ctx.algorithm || ctx.or) &&
        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn) {
    ctx.filter = combine(ctx.filter, fn);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
    var curr = ctx.replayFilter;
    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
    ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn) {
    ctx.isMatch = combine(ctx.isMatch, fn);
}
function getIndexOrStore(ctx, coreSchema) {
    if (ctx.isPrimKey)
        return coreSchema.primaryKey;
    const index = coreSchema.getIndexByKeyPath(ctx.index);
    if (!index)
        throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
    return index;
}
function openCursor(ctx, coreTable, trans) {
    const index = getIndexOrStore(ctx, coreTable.schema);
    return coreTable.openCursor({
        trans,
        values: !ctx.keysOnly,
        reverse: ctx.dir === 'prev',
        unique: !!ctx.unique,
        query: {
            index,
            range: ctx.range
        }
    });
}
function iter(ctx, fn, coreTrans, coreTable) {
    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
    if (!ctx.or) {
        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
    }
    else {
        const set = {};
        const union = (item, cursor, advance) => {
            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {
                var primaryKey = cursor.primaryKey;
                var key = '' + primaryKey;
                if (key === '[object ArrayBuffer]')
                    key = '' + new Uint8Array(primaryKey);
                if (!hasOwn(set, key)) {
                    set[key] = true;
                    fn(item, cursor, advance);
                }
            }
        };
        return Promise.all([
            ctx.or._iterate(union, coreTrans),
            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
        ]);
    }
}
function iterate(cursorPromise, filter, fn, valueMapper) {
    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;
    var wrappedFn = wrap(mappedFn);
    return cursorPromise.then(cursor => {
        if (cursor) {
            return cursor.start(() => {
                var c = () => cursor.continue();
                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))
                    wrappedFn(cursor.value, cursor, advancer => c = advancer);
                c();
            });
        }
    });
}

function cmp(a, b) {
    try {
        const ta = type(a);
        const tb = type(b);
        if (ta !== tb) {
            if (ta === 'Array')
                return 1;
            if (tb === 'Array')
                return -1;
            if (ta === 'binary')
                return 1;
            if (tb === 'binary')
                return -1;
            if (ta === 'string')
                return 1;
            if (tb === 'string')
                return -1;
            if (ta === 'Date')
                return 1;
            if (tb !== 'Date')
                return NaN;
            return -1;
        }
        switch (ta) {
            case 'number':
            case 'Date':
            case 'string':
                return a > b ? 1 : a < b ? -1 : 0;
            case 'binary': {
                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
            }
            case 'Array':
                return compareArrays(a, b);
        }
    }
    catch (_a) { }
    return NaN;
}
function compareArrays(a, b) {
    const al = a.length;
    const bl = b.length;
    const l = al < bl ? al : bl;
    for (let i = 0; i < l; ++i) {
        const res = cmp(a[i], b[i]);
        if (res !== 0)
            return res;
    }
    return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a, b) {
    const al = a.length;
    const bl = b.length;
    const l = al < bl ? al : bl;
    for (let i = 0; i < l; ++i) {
        if (a[i] !== b[i])
            return a[i] < b[i] ? -1 : 1;
    }
    return al === bl ? 0 : al < bl ? -1 : 1;
}
function type(x) {
    const t = typeof x;
    if (t !== 'object')
        return t;
    if (ArrayBuffer.isView(x))
        return 'binary';
    const tsTag = toStringTag(x);
    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
}
function getUint8Array(a) {
    if (a instanceof Uint8Array)
        return a;
    if (ArrayBuffer.isView(a))
        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    return new Uint8Array(a);
}

class Collection {
    _read(fn, cb) {
        var ctx = this._ctx;
        return ctx.error ?
            ctx.table._trans(null, rejection.bind(null, ctx.error)) :
            ctx.table._trans('readonly', fn).then(cb);
    }
    _write(fn) {
        var ctx = this._ctx;
        return ctx.error ?
            ctx.table._trans(null, rejection.bind(null, ctx.error)) :
            ctx.table._trans('readwrite', fn, "locked");
    }
    _addAlgorithm(fn) {
        var ctx = this._ctx;
        ctx.algorithm = combine(ctx.algorithm, fn);
    }
    _iterate(fn, coreTrans) {
        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
    }
    clone(props) {
        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
        if (props)
            extend(ctx, props);
        rv._ctx = ctx;
        return rv;
    }
    raw() {
        this._ctx.valueMapper = null;
        return this;
    }
    each(fn) {
        var ctx = this._ctx;
        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));
    }
    count(cb) {
        return this._read(trans => {
            const ctx = this._ctx;
            const coreTable = ctx.table.core;
            if (isPlainKeyRange(ctx, true)) {
                return coreTable.count({
                    trans,
                    query: {
                        index: getIndexOrStore(ctx, coreTable.schema),
                        range: ctx.range
                    }
                }).then(count => Math.min(count, ctx.limit));
            }
            else {
                var count = 0;
                return iter(ctx, () => { ++count; return false; }, trans, coreTable)
                    .then(() => count);
            }
        }).then(cb);
    }
    sortBy(keyPath, cb) {
        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
        function getval(obj, i) {
            if (i)
                return getval(obj[parts[i]], i - 1);
            return obj[lastPart];
        }
        var order = this._ctx.dir === "next" ? 1 : -1;
        function sorter(a, b) {
            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
            return aVal < bVal ? -order : aVal > bVal ? order : 0;
        }
        return this.toArray(function (a) {
            return a.sort(sorter);
        }).then(cb);
    }
    toArray(cb) {
        return this._read(trans => {
            var ctx = this._ctx;
            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                const { valueMapper } = ctx;
                const index = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                    trans,
                    limit: ctx.limit,
                    values: true,
                    query: {
                        index,
                        range: ctx.range
                    }
                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
            }
            else {
                const a = [];
                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);
            }
        }, cb);
    }
    offset(offset) {
        var ctx = this._ctx;
        if (offset <= 0)
            return this;
        ctx.offset += offset;
        if (isPlainKeyRange(ctx)) {
            addReplayFilter(ctx, () => {
                var offsetLeft = offset;
                return (cursor, advance) => {
                    if (offsetLeft === 0)
                        return true;
                    if (offsetLeft === 1) {
                        --offsetLeft;
                        return false;
                    }
                    advance(() => {
                        cursor.advance(offsetLeft);
                        offsetLeft = 0;
                    });
                    return false;
                };
            });
        }
        else {
            addReplayFilter(ctx, () => {
                var offsetLeft = offset;
                return () => (--offsetLeft < 0);
            });
        }
        return this;
    }
    limit(numRows) {
        this._ctx.limit = Math.min(this._ctx.limit, numRows);
        addReplayFilter(this._ctx, () => {
            var rowsLeft = numRows;
            return function (cursor, advance, resolve) {
                if (--rowsLeft <= 0)
                    advance(resolve);
                return rowsLeft >= 0;
            };
        }, true);
        return this;
    }
    until(filterFunction, bIncludeStopEntry) {
        addFilter(this._ctx, function (cursor, advance, resolve) {
            if (filterFunction(cursor.value)) {
                advance(resolve);
                return bIncludeStopEntry;
            }
            else {
                return true;
            }
        });
        return this;
    }
    first(cb) {
        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);
    }
    last(cb) {
        return this.reverse().first(cb);
    }
    filter(filterFunction) {
        addFilter(this._ctx, function (cursor) {
            return filterFunction(cursor.value);
        });
        addMatchFilter(this._ctx, filterFunction);
        return this;
    }
    and(filter) {
        return this.filter(filter);
    }
    or(indexName) {
        return new this.db.WhereClause(this._ctx.table, indexName, this);
    }
    reverse() {
        this._ctx.dir = (this._ctx.dir === "prev" ? "next" : "prev");
        if (this._ondirectionchange)
            this._ondirectionchange(this._ctx.dir);
        return this;
    }
    desc() {
        return this.reverse();
    }
    eachKey(cb) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        return this.each(function (val, cursor) { cb(cursor.key, cursor); });
    }
    eachUniqueKey(cb) {
        this._ctx.unique = "unique";
        return this.eachKey(cb);
    }
    eachPrimaryKey(cb) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });
    }
    keys(cb) {
        var ctx = this._ctx;
        ctx.keysOnly = !ctx.isMatch;
        var a = [];
        return this.each(function (item, cursor) {
            a.push(cursor.key);
        }).then(function () {
            return a;
        }).then(cb);
    }
    primaryKeys(cb) {
        var ctx = this._ctx;
        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
            return this._read(trans => {
                var index = getIndexOrStore(ctx, ctx.table.core.schema);
                return ctx.table.core.query({
                    trans,
                    values: false,
                    limit: ctx.limit,
                    query: {
                        index,
                        range: ctx.range
                    }
                });
            }).then(({ result }) => result).then(cb);
        }
        ctx.keysOnly = !ctx.isMatch;
        var a = [];
        return this.each(function (item, cursor) {
            a.push(cursor.primaryKey);
        }).then(function () {
            return a;
        }).then(cb);
    }
    uniqueKeys(cb) {
        this._ctx.unique = "unique";
        return this.keys(cb);
    }
    firstKey(cb) {
        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);
    }
    lastKey(cb) {
        return this.reverse().firstKey(cb);
    }
    distinct() {
        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
        if (!idx || !idx.multi)
            return this;
        var set = {};
        addFilter(this._ctx, function (cursor) {
            var strKey = cursor.primaryKey.toString();
            var found = hasOwn(set, strKey);
            set[strKey] = true;
            return !found;
        });
        return this;
    }
    modify(changes) {
        var ctx = this._ctx;
        return this._write(trans => {
            var modifyer;
            if (typeof changes === 'function') {
                modifyer = changes;
            }
            else {
                var keyPaths = keys(changes);
                var numKeys = keyPaths.length;
                modifyer = function (item) {
                    var anythingModified = false;
                    for (var i = 0; i < numKeys; ++i) {
                        var keyPath = keyPaths[i], val = changes[keyPath];
                        if (getByKeyPath(item, keyPath) !== val) {
                            setByKeyPath(item, keyPath, val);
                            anythingModified = true;
                        }
                    }
                    return anythingModified;
                };
            }
            const coreTable = ctx.table.core;
            const { outbound, extractKey } = coreTable.schema.primaryKey;
            const limit = this.db._options.modifyChunkSize || 200;
            const totalFailures = [];
            let successCount = 0;
            const failedKeys = [];
            const applyMutateResult = (expectedCount, res) => {
                const { failures, numFailures } = res;
                successCount += expectedCount - numFailures;
                for (let pos of keys(failures)) {
                    totalFailures.push(failures[pos]);
                }
            };
            return this.clone().primaryKeys().then(keys => {
                const nextChunk = (offset) => {
                    const count = Math.min(limit, keys.length - offset);
                    return coreTable.getMany({
                        trans,
                        keys: keys.slice(offset, offset + count),
                        cache: "immutable"
                    }).then(values => {
                        const addValues = [];
                        const putValues = [];
                        const putKeys = outbound ? [] : null;
                        const deleteKeys = [];
                        for (let i = 0; i < count; ++i) {
                            const origValue = values[i];
                            const ctx = {
                                value: deepClone(origValue),
                                primKey: keys[offset + i]
                            };
                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {
                                if (ctx.value == null) {
                                    deleteKeys.push(keys[offset + i]);
                                }
                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {
                                    deleteKeys.push(keys[offset + i]);
                                    addValues.push(ctx.value);
                                }
                                else {
                                    putValues.push(ctx.value);
                                    if (outbound)
                                        putKeys.push(keys[offset + i]);
                                }
                            }
                        }
                        const criteria = isPlainKeyRange(ctx) &&
                            ctx.limit === Infinity &&
                            (typeof changes !== 'function' || changes === deleteCallback) && {
                            index: ctx.index,
                            range: ctx.range
                        };
                        return Promise.resolve(addValues.length > 0 &&
                            coreTable.mutate({ trans, type: 'add', values: addValues })
                                .then(res => {
                                for (let pos in res.failures) {
                                    deleteKeys.splice(parseInt(pos), 1);
                                }
                                applyMutateResult(addValues.length, res);
                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&
                            coreTable.mutate({
                                trans,
                                type: 'put',
                                keys: putKeys,
                                values: putValues,
                                criteria,
                                changeSpec: typeof changes !== 'function'
                                    && changes
                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&
                            coreTable.mutate({
                                trans,
                                type: 'delete',
                                keys: deleteKeys,
                                criteria
                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {
                            return keys.length > offset + count && nextChunk(offset + limit);
                        });
                    });
                };
                return nextChunk(0).then(() => {
                    if (totalFailures.length > 0)
                        throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                    return keys.length;
                });
            });
        });
    }
    delete() {
        var ctx = this._ctx, range = ctx.range;
        if (isPlainKeyRange(ctx) &&
            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))
         {
            return this._write(trans => {
                const { primaryKey } = ctx.table.core.schema;
                const coreRange = range;
                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {
                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })
                        .then(({ failures, lastResult, results, numFailures }) => {
                        if (numFailures)
                            throw new ModifyError("Could not delete some values", Object.keys(failures).map(pos => failures[pos]), count - numFailures);
                        return count - numFailures;
                    });
                });
            });
        }
        return this.modify(deleteCallback);
    }
}
const deleteCallback = (value, ctx) => ctx.value = null;

function createCollectionConstructor(db) {
    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
        this.db = db;
        let keyRange = AnyRange, error = null;
        if (keyRangeGenerator)
            try {
                keyRange = keyRangeGenerator();
            }
            catch (ex) {
                error = ex;
            }
        const whereCtx = whereClause._ctx;
        const table = whereCtx.table;
        const readingHook = table.hook.reading.fire;
        this._ctx = {
            table: table,
            index: whereCtx.index,
            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),
            range: keyRange,
            keysOnly: false,
            dir: "next",
            unique: "",
            algorithm: null,
            filter: null,
            replayFilter: null,
            justLimit: true,
            isMatch: null,
            offset: 0,
            limit: Infinity,
            error: error,
            or: whereCtx.or,
            valueMapper: readingHook !== mirror ? readingHook : null
        };
    });
}

function simpleCompare(a, b) {
    return a < b ? -1 : a === b ? 0 : 1;
}
function simpleCompareReverse(a, b) {
    return a > b ? -1 : a === b ? 0 : 1;
}

function fail(collectionOrWhereClause, err, T) {
    var collection = collectionOrWhereClause instanceof WhereClause ?
        new collectionOrWhereClause.Collection(collectionOrWhereClause) :
        collectionOrWhereClause;
    collection._ctx.error = T ? new T(err) : new TypeError(err);
    return collection;
}
function emptyCollection(whereClause) {
    return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}
function upperFactory(dir) {
    return dir === "next" ?
        (s) => s.toUpperCase() :
        (s) => s.toLowerCase();
}
function lowerFactory(dir) {
    return dir === "next" ?
        (s) => s.toLowerCase() :
        (s) => s.toUpperCase();
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
    var length = Math.min(key.length, lowerNeedle.length);
    var llp = -1;
    for (var i = 0; i < length; ++i) {
        var lwrKeyChar = lowerKey[i];
        if (lwrKeyChar !== lowerNeedle[i]) {
            if (cmp(key[i], upperNeedle[i]) < 0)
                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
            if (cmp(key[i], lowerNeedle[i]) < 0)
                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
            if (llp >= 0)
                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
            return null;
        }
        if (cmp(key[i], lwrKeyChar) < 0)
            llp = i;
    }
    if (length < lowerNeedle.length && dir === "next")
        return key + upperNeedle.substr(key.length);
    if (length < key.length && dir === "prev")
        return key.substr(0, upperNeedle.length);
    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));
}
function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
    if (!needles.every(s => typeof s === 'string')) {
        return fail(whereClause, STRING_EXPECTED);
    }
    function initDirection(dir) {
        upper = upperFactory(dir);
        lower = lowerFactory(dir);
        compare = (dir === "next" ? simpleCompare : simpleCompareReverse);
        var needleBounds = needles.map(function (needle) {
            return { lower: lower(needle), upper: upper(needle) };
        }).sort(function (a, b) {
            return compare(a.lower, b.lower);
        });
        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });
        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });
        direction = dir;
        nextKeySuffix = (dir === "next" ? "" : suffix);
    }
    initDirection("next");
    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
    c._ondirectionchange = function (direction) {
        initDirection(direction);
    };
    var firstPossibleNeedle = 0;
    c._addAlgorithm(function (cursor, advance, resolve) {
        var key = cursor.key;
        if (typeof key !== 'string')
            return false;
        var lowerKey = lower(key);
        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
            return true;
        }
        else {
            var lowestPossibleCasing = null;
            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                if (casing === null && lowestPossibleCasing === null)
                    firstPossibleNeedle = i + 1;
                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                    lowestPossibleCasing = casing;
                }
            }
            if (lowestPossibleCasing !== null) {
                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });
            }
            else {
                advance(resolve);
            }
            return false;
        }
    });
    return c;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
    return {
        type: 2 ,
        lower,
        upper,
        lowerOpen,
        upperOpen
    };
}
function rangeEqual(value) {
    return {
        type: 1 ,
        lower: value,
        upper: value
    };
}

class WhereClause {
    get Collection() {
        return this._ctx.table.db.Collection;
    }
    between(lower, upper, includeLower, includeUpper) {
        includeLower = includeLower !== false;
        includeUpper = includeUpper === true;
        try {
            if ((this._cmp(lower, upper) > 0) ||
                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))
                return emptyCollection(this);
            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
        }
        catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
    }
    equals(value) {
        if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, () => rangeEqual(value));
    }
    above(value) {
        if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, () => createRange(value, undefined, true));
    }
    aboveOrEqual(value) {
        if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, () => createRange(value, undefined, false));
    }
    below(value) {
        if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, () => createRange(undefined, value, false, true));
    }
    belowOrEqual(value) {
        if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
        return new this.Collection(this, () => createRange(undefined, value));
    }
    startsWith(str) {
        if (typeof str !== 'string')
            return fail(this, STRING_EXPECTED);
        return this.between(str, str + maxString, true, true);
    }
    startsWithIgnoreCase(str) {
        if (str === "")
            return this.startsWith(str);
        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
    }
    equalsIgnoreCase(str) {
        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
    }
    anyOfIgnoreCase() {
        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set.length === 0)
            return emptyCollection(this);
        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, "");
    }
    startsWithAnyOfIgnoreCase() {
        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set.length === 0)
            return emptyCollection(this);
        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);
    }
    anyOf() {
        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        let compare = this._cmp;
        try {
            set.sort(compare);
        }
        catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
        if (set.length === 0)
            return emptyCollection(this);
        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));
        c._ondirectionchange = direction => {
            compare = (direction === "next" ?
                this._ascending :
                this._descending);
            set.sort(compare);
        };
        let i = 0;
        c._addAlgorithm((cursor, advance, resolve) => {
            const key = cursor.key;
            while (compare(key, set[i]) > 0) {
                ++i;
                if (i === set.length) {
                    advance(resolve);
                    return false;
                }
            }
            if (compare(key, set[i]) === 0) {
                return true;
            }
            else {
                advance(() => { cursor.continue(set[i]); });
                return false;
            }
        });
        return c;
    }
    notEqual(value) {
        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
    }
    noneOf() {
        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (set.length === 0)
            return new this.Collection(this);
        try {
            set.sort(this._ascending);
        }
        catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
        const ranges = set.reduce((res, val) => res ?
            res.concat([[res[res.length - 1][1], val]]) :
            [[minKey, val]], null);
        ranges.push([set[set.length - 1], this.db._maxKey]);
        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
    }
    inAnyRange(ranges, options) {
        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
        if (ranges.length === 0)
            return emptyCollection(this);
        if (!ranges.every(range => range[0] !== undefined &&
            range[1] !== undefined &&
            ascending(range[0], range[1]) <= 0)) {
            return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
        }
        const includeLowers = !options || options.includeLowers !== false;
        const includeUppers = options && options.includeUppers === true;
        function addRange(ranges, newRange) {
            let i = 0, l = ranges.length;
            for (; i < l; ++i) {
                const range = ranges[i];
                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                    range[0] = min(range[0], newRange[0]);
                    range[1] = max(range[1], newRange[1]);
                    break;
                }
            }
            if (i === l)
                ranges.push(newRange);
            return ranges;
        }
        let sortDirection = ascending;
        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }
        let set;
        try {
            set = ranges.reduce(addRange, []);
            set.sort(rangeSorter);
        }
        catch (ex) {
            return fail(this, INVALID_KEY_ARGUMENT);
        }
        let rangePos = 0;
        const keyIsBeyondCurrentEntry = includeUppers ?
            key => ascending(key, set[rangePos][1]) > 0 :
            key => ascending(key, set[rangePos][1]) >= 0;
        const keyIsBeforeCurrentEntry = includeLowers ?
            key => descending(key, set[rangePos][0]) > 0 :
            key => descending(key, set[rangePos][0]) >= 0;
        function keyWithinCurrentRange(key) {
            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
        }
        let checkKey = keyIsBeyondCurrentEntry;
        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));
        c._ondirectionchange = direction => {
            if (direction === "next") {
                checkKey = keyIsBeyondCurrentEntry;
                sortDirection = ascending;
            }
            else {
                checkKey = keyIsBeforeCurrentEntry;
                sortDirection = descending;
            }
            set.sort(rangeSorter);
        };
        c._addAlgorithm((cursor, advance, resolve) => {
            var key = cursor.key;
            while (checkKey(key)) {
                ++rangePos;
                if (rangePos === set.length) {
                    advance(resolve);
                    return false;
                }
            }
            if (keyWithinCurrentRange(key)) {
                return true;
            }
            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
                return false;
            }
            else {
                advance(() => {
                    if (sortDirection === ascending)
                        cursor.continue(set[rangePos][0]);
                    else
                        cursor.continue(set[rangePos][1]);
                });
                return false;
            }
        });
        return c;
    }
    startsWithAnyOf() {
        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
        if (!set.every(s => typeof s === 'string')) {
            return fail(this, "startsWithAnyOf() only works with strings");
        }
        if (set.length === 0)
            return emptyCollection(this);
        return this.inAnyRange(set.map((str) => [str, str + maxString]));
    }
}

function createWhereClauseConstructor(db) {
    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
        this.db = db;
        this._ctx = {
            table: table,
            index: index === ":id" ? null : index,
            or: orCollection
        };
        const indexedDB = db._deps.indexedDB;
        if (!indexedDB)
            throw new exceptions.MissingAPI();
        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);
        this._descending = (a, b) => indexedDB.cmp(b, a);
        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;
        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;
        this._IDBKeyRange = db._deps.IDBKeyRange;
    });
}

function eventRejectHandler(reject) {
    return wrap(function (event) {
        preventDefault(event);
        reject(event.target.error);
        return false;
    });
}
function preventDefault(event) {
    if (event.stopPropagation)
        event.stopPropagation();
    if (event.preventDefault)
        event.preventDefault();
}

const DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
const STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
const globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

class Transaction {
    _lock() {
        assert(!PSD.global);
        ++this._reculock;
        if (this._reculock === 1 && !PSD.global)
            PSD.lockOwnerFor = this;
        return this;
    }
    _unlock() {
        assert(!PSD.global);
        if (--this._reculock === 0) {
            if (!PSD.global)
                PSD.lockOwnerFor = null;
            while (this._blockedFuncs.length > 0 && !this._locked()) {
                var fnAndPSD = this._blockedFuncs.shift();
                try {
                    usePSD(fnAndPSD[1], fnAndPSD[0]);
                }
                catch (e) { }
            }
        }
        return this;
    }
    _locked() {
        return this._reculock && PSD.lockOwnerFor !== this;
    }
    create(idbtrans) {
        if (!this.mode)
            return this;
        const idbdb = this.db.idbdb;
        const dbOpenError = this.db._state.dbOpenError;
        assert(!this.idbtrans);
        if (!idbtrans && !idbdb) {
            switch (dbOpenError && dbOpenError.name) {
                case "DatabaseClosedError":
                    throw new exceptions.DatabaseClosed(dbOpenError);
                case "MissingAPIError":
                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                default:
                    throw new exceptions.OpenFailed(dbOpenError);
            }
        }
        if (!this.active)
            throw new exceptions.TransactionInactive();
        assert(this._completion._state === null);
        idbtrans = this.idbtrans = idbtrans ||
            (this.db.core
                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })
                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
        idbtrans.onerror = wrap(ev => {
            preventDefault(ev);
            this._reject(idbtrans.error);
        });
        idbtrans.onabort = wrap(ev => {
            preventDefault(ev);
            this.active && this._reject(new exceptions.Abort(idbtrans.error));
            this.active = false;
            this.on("abort").fire(ev);
        });
        idbtrans.oncomplete = wrap(() => {
            this.active = false;
            this._resolve();
            if ('mutatedParts' in idbtrans) {
                globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
            }
        });
        return this;
    }
    _promise(mode, fn, bWriteLock) {
        if (mode === 'readwrite' && this.mode !== 'readwrite')
            return rejection(new exceptions.ReadOnly("Transaction is readonly"));
        if (!this.active)
            return rejection(new exceptions.TransactionInactive());
        if (this._locked()) {
            return new DexiePromise((resolve, reject) => {
                this._blockedFuncs.push([() => {
                        this._promise(mode, fn, bWriteLock).then(resolve, reject);
                    }, PSD]);
            });
        }
        else if (bWriteLock) {
            return newScope(() => {
                var p = new DexiePromise((resolve, reject) => {
                    this._lock();
                    const rv = fn(resolve, reject, this);
                    if (rv && rv.then)
                        rv.then(resolve, reject);
                });
                p.finally(() => this._unlock());
                p._lib = true;
                return p;
            });
        }
        else {
            var p = new DexiePromise((resolve, reject) => {
                var rv = fn(resolve, reject, this);
                if (rv && rv.then)
                    rv.then(resolve, reject);
            });
            p._lib = true;
            return p;
        }
    }
    _root() {
        return this.parent ? this.parent._root() : this;
    }
    waitFor(promiseLike) {
        var root = this._root();
        const promise = DexiePromise.resolve(promiseLike);
        if (root._waitingFor) {
            root._waitingFor = root._waitingFor.then(() => promise);
        }
        else {
            root._waitingFor = promise;
            root._waitingQueue = [];
            var store = root.idbtrans.objectStore(root.storeNames[0]);
            (function spin() {
                ++root._spinCount;
                while (root._waitingQueue.length)
                    (root._waitingQueue.shift())();
                if (root._waitingFor)
                    store.get(-Infinity).onsuccess = spin;
            }());
        }
        var currentWaitPromise = root._waitingFor;
        return new DexiePromise((resolve, reject) => {
            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {
                if (root._waitingFor === currentWaitPromise) {
                    root._waitingFor = null;
                }
            });
        });
    }
    abort() {
        if (this.active) {
            this.active = false;
            if (this.idbtrans)
                this.idbtrans.abort();
            this._reject(new exceptions.Abort());
        }
    }
    table(tableName) {
        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));
        if (hasOwn(memoizedTables, tableName))
            return memoizedTables[tableName];
        const tableSchema = this.schema[tableName];
        if (!tableSchema) {
            throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
        }
        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
        transactionBoundTable.core = this.db.core.table(tableName);
        memoizedTables[tableName] = transactionBoundTable;
        return transactionBoundTable;
    }
}

function createTransactionConstructor(db) {
    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
        this.db = db;
        this.mode = mode;
        this.storeNames = storeNames;
        this.schema = dbschema;
        this.chromeTransactionDurability = chromeTransactionDurability;
        this.idbtrans = null;
        this.on = Events(this, "complete", "error", "abort");
        this.parent = parent || null;
        this.active = true;
        this._reculock = 0;
        this._blockedFuncs = [];
        this._resolve = null;
        this._reject = null;
        this._waitingFor = null;
        this._waitingQueue = null;
        this._spinCount = 0;
        this._completion = new DexiePromise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        this._completion.then(() => {
            this.active = false;
            this.on.complete.fire();
        }, e => {
            var wasActive = this.active;
            this.active = false;
            this.on.error.fire(e);
            this.parent ?
                this.parent._reject(e) :
                wasActive && this.idbtrans && this.idbtrans.abort();
            return rejection(e);
        });
    });
}

function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
    return {
        name,
        keyPath,
        unique,
        multi,
        auto,
        compound,
        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath)
    };
}
function nameFromKeyPath(keyPath) {
    return typeof keyPath === 'string' ?
        keyPath :
        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : "";
}

function createTableSchema(name, primKey, indexes) {
    return {
        name,
        primKey,
        indexes,
        mappedClass: null,
        idxByName: arrayToObject(indexes, index => [index.name, index])
    };
}

function safariMultiStoreFix(storeNames) {
    return storeNames.length === 1 ? storeNames[0] : storeNames;
}
let getMaxKey = (IdbKeyRange) => {
    try {
        IdbKeyRange.only([[]]);
        getMaxKey = () => [[]];
        return [[]];
    }
    catch (e) {
        getMaxKey = () => maxString;
        return maxString;
    }
};

function getKeyExtractor(keyPath) {
    if (keyPath == null) {
        return () => undefined;
    }
    else if (typeof keyPath === 'string') {
        return getSinglePathKeyExtractor(keyPath);
    }
    else {
        return obj => getByKeyPath(obj, keyPath);
    }
}
function getSinglePathKeyExtractor(keyPath) {
    const split = keyPath.split('.');
    if (split.length === 1) {
        return obj => obj[keyPath];
    }
    else {
        return obj => getByKeyPath(obj, keyPath);
    }
}

function arrayify(arrayLike) {
    return [].slice.call(arrayLike);
}
let _id_counter = 0;
function getKeyPathAlias(keyPath) {
    return keyPath == null ?
        ":id" :
        typeof keyPath === 'string' ?
            keyPath :
            `[${keyPath.join('+')}]`;
}
function createDBCore(db, IdbKeyRange, tmpTrans) {
    function extractSchema(db, trans) {
        const tables = arrayify(db.objectStoreNames);
        return {
            schema: {
                name: db.name,
                tables: tables.map(table => trans.objectStore(table)).map(store => {
                    const { keyPath, autoIncrement } = store;
                    const compound = isArray(keyPath);
                    const outbound = keyPath == null;
                    const indexByKeyPath = {};
                    const result = {
                        name: store.name,
                        primaryKey: {
                            name: null,
                            isPrimaryKey: true,
                            outbound,
                            compound,
                            keyPath,
                            autoIncrement,
                            unique: true,
                            extractKey: getKeyExtractor(keyPath)
                        },
                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))
                            .map(index => {
                            const { name, unique, multiEntry, keyPath } = index;
                            const compound = isArray(keyPath);
                            const result = {
                                name,
                                compound,
                                keyPath,
                                unique,
                                multiEntry,
                                extractKey: getKeyExtractor(keyPath)
                            };
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                            return result;
                        }),
                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]
                    };
                    indexByKeyPath[":id"] = result.primaryKey;
                    if (keyPath != null) {
                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                    }
                    return result;
                })
            },
            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&
                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                    !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                    [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
        };
    }
    function makeIDBKeyRange(range) {
        if (range.type === 3 )
            return null;
        if (range.type === 4 )
            throw new Error("Cannot convert never type to IDBKeyRange");
        const { lower, upper, lowerOpen, upperOpen } = range;
        const idbRange = lower === undefined ?
            upper === undefined ?
                null :
                IdbKeyRange.upperBound(upper, !!upperOpen) :
            upper === undefined ?
                IdbKeyRange.lowerBound(lower, !!lowerOpen) :
                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
        return idbRange;
    }
    function createDbCoreTable(tableSchema) {
        const tableName = tableSchema.name;
        function mutate({ trans, type, keys, values, range }) {
            return new Promise((resolve, reject) => {
                resolve = wrap(resolve);
                const store = trans.objectStore(tableName);
                const outbound = store.keyPath == null;
                const isAddOrPut = type === "put" || type === "add";
                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')
                    throw new Error("Invalid operation type: " + type);
                const { length } = keys || values || { length: 1 };
                if (keys && values && keys.length !== values.length) {
                    throw new Error("Given keys array must have same length as given values array.");
                }
                if (length === 0)
                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });
                let req;
                const reqs = [];
                const failures = [];
                let numFailures = 0;
                const errorHandler = event => {
                    ++numFailures;
                    preventDefault(event);
                };
                if (type === 'deleteRange') {
                    if (range.type === 4 )
                        return resolve({ numFailures, failures, results: [], lastResult: undefined });
                    if (range.type === 3 )
                        reqs.push(req = store.clear());
                    else
                        reqs.push(req = store.delete(makeIDBKeyRange(range)));
                }
                else {
                    const [args1, args2] = isAddOrPut ?
                        outbound ?
                            [values, keys] :
                            [values, null] :
                        [keys, null];
                    if (isAddOrPut) {
                        for (let i = 0; i < length; ++i) {
                            reqs.push(req = (args2 && args2[i] !== undefined ?
                                store[type](args1[i], args2[i]) :
                                store[type](args1[i])));
                            req.onerror = errorHandler;
                        }
                    }
                    else {
                        for (let i = 0; i < length; ++i) {
                            reqs.push(req = store[type](args1[i]));
                            req.onerror = errorHandler;
                        }
                    }
                }
                const done = event => {
                    const lastResult = event.target.result;
                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));
                    resolve({
                        numFailures,
                        failures,
                        results: type === "delete" ? keys : reqs.map(req => req.result),
                        lastResult
                    });
                };
                req.onerror = event => {
                    errorHandler(event);
                    done(event);
                };
                req.onsuccess = done;
            });
        }
        function openCursor({ trans, values, query, reverse, unique }) {
            return new Promise((resolve, reject) => {
                resolve = wrap(resolve);
                const { index, range } = query;
                const store = trans.objectStore(tableName);
                const source = index.isPrimaryKey ?
                    store :
                    store.index(index.name);
                const direction = reverse ?
                    unique ?
                        "prevunique" :
                        "prev" :
                    unique ?
                        "nextunique" :
                        "next";
                const req = values || !('openKeyCursor' in source) ?
                    source.openCursor(makeIDBKeyRange(range), direction) :
                    source.openKeyCursor(makeIDBKeyRange(range), direction);
                req.onerror = eventRejectHandler(reject);
                req.onsuccess = wrap(ev => {
                    const cursor = req.result;
                    if (!cursor) {
                        resolve(null);
                        return;
                    }
                    cursor.___id = ++_id_counter;
                    cursor.done = false;
                    const _cursorContinue = cursor.continue.bind(cursor);
                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                    if (_cursorContinuePrimaryKey)
                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                    const _cursorAdvance = cursor.advance.bind(cursor);
                    const doThrowCursorIsNotStarted = () => { throw new Error("Cursor not started"); };
                    const doThrowCursorIsStopped = () => { throw new Error("Cursor not stopped"); };
                    cursor.trans = trans;
                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                    cursor.fail = wrap(reject);
                    cursor.next = function () {
                        let gotOne = 1;
                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
                    };
                    cursor.start = (callback) => {
                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
                            resolveIteration = wrap(resolveIteration);
                            req.onerror = eventRejectHandler(rejectIteration);
                            cursor.fail = rejectIteration;
                            cursor.stop = value => {
                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                resolveIteration(value);
                            };
                        });
                        const guardedCallback = () => {
                            if (req.result) {
                                try {
                                    callback();
                                }
                                catch (err) {
                                    cursor.fail(err);
                                }
                            }
                            else {
                                cursor.done = true;
                                cursor.start = () => { throw new Error("Cursor behind last entry"); };
                                cursor.stop();
                            }
                        };
                        req.onsuccess = wrap(ev => {
                            req.onsuccess = guardedCallback;
                            guardedCallback();
                        });
                        cursor.continue = _cursorContinue;
                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                        cursor.advance = _cursorAdvance;
                        guardedCallback();
                        return iterationPromise;
                    };
                    resolve(cursor);
                }, reject);
            });
        }
        function query(hasGetAll) {
            return (request) => {
                return new Promise((resolve, reject) => {
                    resolve = wrap(resolve);
                    const { trans, values, limit, query } = request;
                    const nonInfinitLimit = limit === Infinity ? undefined : limit;
                    const { index, range } = query;
                    const store = trans.objectStore(tableName);
                    const source = index.isPrimaryKey ? store : store.index(index.name);
                    const idbKeyRange = makeIDBKeyRange(range);
                    if (limit === 0)
                        return resolve({ result: [] });
                    if (hasGetAll) {
                        const req = values ?
                            source.getAll(idbKeyRange, nonInfinitLimit) :
                            source.getAllKeys(idbKeyRange, nonInfinitLimit);
                        req.onsuccess = event => resolve({ result: event.target.result });
                        req.onerror = eventRejectHandler(reject);
                    }
                    else {
                        let count = 0;
                        const req = values || !('openKeyCursor' in source) ?
                            source.openCursor(idbKeyRange) :
                            source.openKeyCursor(idbKeyRange);
                        const result = [];
                        req.onsuccess = event => {
                            const cursor = req.result;
                            if (!cursor)
                                return resolve({ result });
                            result.push(values ? cursor.value : cursor.primaryKey);
                            if (++count === limit)
                                return resolve({ result });
                            cursor.continue();
                        };
                        req.onerror = eventRejectHandler(reject);
                    }
                });
            };
        }
        return {
            name: tableName,
            schema: tableSchema,
            mutate,
            getMany({ trans, keys }) {
                return new Promise((resolve, reject) => {
                    resolve = wrap(resolve);
                    const store = trans.objectStore(tableName);
                    const length = keys.length;
                    const result = new Array(length);
                    let keyCount = 0;
                    let callbackCount = 0;
                    let req;
                    const successHandler = event => {
                        const req = event.target;
                        if ((result[req._pos] = req.result) != null)
                            ;
                        if (++callbackCount === keyCount)
                            resolve(result);
                    };
                    const errorHandler = eventRejectHandler(reject);
                    for (let i = 0; i < length; ++i) {
                        const key = keys[i];
                        if (key != null) {
                            req = store.get(keys[i]);
                            req._pos = i;
                            req.onsuccess = successHandler;
                            req.onerror = errorHandler;
                            ++keyCount;
                        }
                    }
                    if (keyCount === 0)
                        resolve(result);
                });
            },
            get({ trans, key }) {
                return new Promise((resolve, reject) => {
                    resolve = wrap(resolve);
                    const store = trans.objectStore(tableName);
                    const req = store.get(key);
                    req.onsuccess = event => resolve(event.target.result);
                    req.onerror = eventRejectHandler(reject);
                });
            },
            query: query(hasGetAll),
            openCursor,
            count({ query, trans }) {
                const { index, range } = query;
                return new Promise((resolve, reject) => {
                    const store = trans.objectStore(tableName);
                    const source = index.isPrimaryKey ? store : store.index(index.name);
                    const idbKeyRange = makeIDBKeyRange(range);
                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                    req.onsuccess = wrap(ev => resolve(ev.target.result));
                    req.onerror = eventRejectHandler(reject);
                });
            }
        };
    }
    const { schema, hasGetAll } = extractSchema(db, tmpTrans);
    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));
    const tableMap = {};
    tables.forEach(table => tableMap[table.name] = table);
    return {
        stack: "dbcore",
        transaction: db.transaction.bind(db),
        table(name) {
            const result = tableMap[name];
            if (!result)
                throw new Error(`Table '${name}' not found`);
            return tableMap[name];
        },
        MIN_KEY: -Infinity,
        MAX_KEY: getMaxKey(IdbKeyRange),
        schema
    };
}

function createMiddlewareStack(stackImpl, middlewares) {
    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {
    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
    return {
        dbcore
    };
}
function generateMiddlewareStacks({ _novip: db }, tmpTrans) {
    const idbdb = tmpTrans.db;
    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
    db.core = stacks.dbcore;
    db.tables.forEach(table => {
        const tableName = table.name;
        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {
            table.core = db.core.table(tableName);
            if (db[tableName] instanceof db.Table) {
                db[tableName].core = table.core;
            }
        }
    });
}

function setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {
    tableNames.forEach(tableName => {
        const schema = dbschema[tableName];
        objs.forEach(obj => {
            const propDesc = getPropertyDescriptor(obj, tableName);
            if (!propDesc || ("value" in propDesc && propDesc.value === undefined)) {
                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                    setProp(obj, tableName, {
                        get() { return this.table(tableName); },
                        set(value) {
                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                        }
                    });
                }
                else {
                    obj[tableName] = new db.Table(tableName, schema);
                }
            }
        });
    });
}
function removeTablesApi({ _novip: db }, objs) {
    objs.forEach(obj => {
        for (let key in obj) {
            if (obj[key] instanceof db.Table)
                delete obj[key];
        }
    });
}
function lowerVersionFirst(a, b) {
    return a._cfg.version - b._cfg.version;
}
function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
    const globalSchema = db._dbSchema;
    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
    trans.create(idbUpgradeTrans);
    trans._completion.catch(reject);
    const rejectTransaction = trans._reject.bind(trans);
    const transless = PSD.transless || PSD;
    newScope(() => {
        PSD.trans = trans;
        PSD.transless = transless;
        if (oldVersion === 0) {
            keys(globalSchema).forEach(tableName => {
                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
            });
            generateMiddlewareStacks(db, idbUpgradeTrans);
            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
        }
        else
            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
    });
}
function updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {
    const queue = [];
    const versions = db._versions;
    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
    let anyContentUpgraderHasRun = false;
    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);
    versToRun.forEach(version => {
        queue.push(() => {
            const oldSchema = globalSchema;
            const newSchema = version._cfg.dbschema;
            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
            globalSchema = db._dbSchema = newSchema;
            const diff = getSchemaDiff(oldSchema, newSchema);
            diff.add.forEach(tuple => {
                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
            });
            diff.change.forEach(change => {
                if (change.recreate) {
                    throw new exceptions.Upgrade("Not yet support for changing primary key");
                }
                else {
                    const store = idbUpgradeTrans.objectStore(change.name);
                    change.add.forEach(idx => addIndex(store, idx));
                    change.change.forEach(idx => {
                        store.deleteIndex(idx.name);
                        addIndex(store, idx);
                    });
                    change.del.forEach(idxName => store.deleteIndex(idxName));
                }
            });
            const contentUpgrade = version._cfg.contentUpgrade;
            if (contentUpgrade && version._cfg.version > oldVersion) {
                generateMiddlewareStacks(db, idbUpgradeTrans);
                trans._memoizedTables = {};
                anyContentUpgraderHasRun = true;
                let upgradeSchema = shallowClone(newSchema);
                diff.del.forEach(table => {
                    upgradeSchema[table] = oldSchema[table];
                });
                removeTablesApi(db, [db.Transaction.prototype]);
                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);
                trans.schema = upgradeSchema;
                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
                if (contentUpgradeIsAsync) {
                    incrementExpectedAwaits();
                }
                let returnValue;
                const promiseFollowed = DexiePromise.follow(() => {
                    returnValue = contentUpgrade(trans);
                    if (returnValue) {
                        if (contentUpgradeIsAsync) {
                            var decrementor = decrementExpectedAwaits.bind(null, null);
                            returnValue.then(decrementor, decrementor);
                        }
                    }
                });
                return (returnValue && typeof returnValue.then === 'function' ?
                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));
            }
        });
        queue.push(idbtrans => {
            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
                const newSchema = version._cfg.dbschema;
                deleteRemovedTables(newSchema, idbtrans);
            }
            removeTablesApi(db, [db.Transaction.prototype]);
            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
            trans.schema = db._dbSchema;
        });
    });
    function runQueue() {
        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :
            DexiePromise.resolve();
    }
    return runQueue().then(() => {
        createMissingTables(globalSchema, idbUpgradeTrans);
    });
}
function getSchemaDiff(oldSchema, newSchema) {
    const diff = {
        del: [],
        add: [],
        change: []
    };
    let table;
    for (table in oldSchema) {
        if (!newSchema[table])
            diff.del.push(table);
    }
    for (table in newSchema) {
        const oldDef = oldSchema[table], newDef = newSchema[table];
        if (!oldDef) {
            diff.add.push([table, newDef]);
        }
        else {
            const change = {
                name: table,
                def: newDef,
                recreate: false,
                del: [],
                add: [],
                change: []
            };
            if ((
            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||
                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))
             {
                change.recreate = true;
                diff.change.push(change);
            }
            else {
                const oldIndexes = oldDef.idxByName;
                const newIndexes = newDef.idxByName;
                let idxName;
                for (idxName in oldIndexes) {
                    if (!newIndexes[idxName])
                        change.del.push(idxName);
                }
                for (idxName in newIndexes) {
                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                    if (!oldIdx)
                        change.add.push(newIdx);
                    else if (oldIdx.src !== newIdx.src)
                        change.change.push(newIdx);
                }
                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                    diff.change.push(change);
                }
            }
        }
    }
    return diff;
}
function createTable(idbtrans, tableName, primKey, indexes) {
    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?
        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :
        { autoIncrement: primKey.auto });
    indexes.forEach(idx => addIndex(store, idx));
    return store;
}
function createMissingTables(newSchema, idbtrans) {
    keys(newSchema).forEach(tableName => {
        if (!idbtrans.db.objectStoreNames.contains(tableName)) {
            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
        }
    });
}
function deleteRemovedTables(newSchema, idbtrans) {
    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}
function addIndex(store, idx) {
    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
}
function buildGlobalSchema(db, idbdb, tmpTrans) {
    const globalSchema = {};
    const dbStoreNames = slice(idbdb.objectStoreNames, 0);
    dbStoreNames.forEach(storeName => {
        const store = tmpTrans.objectStore(storeName);
        let keyPath = store.keyPath;
        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
        const indexes = [];
        for (let j = 0; j < store.indexNames.length; ++j) {
            const idbindex = store.index(store.indexNames[j]);
            keyPath = idbindex.keyPath;
            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
            indexes.push(index);
        }
        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
    });
    return globalSchema;
}
function readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {
    db.verno = idbdb.version / 10;
    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
    db._storeNames = slice(idbdb.objectStoreNames, 0);
    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
}
function verifyInstalledSchema(db, tmpTrans) {
    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
    const diff = getSchemaDiff(installedSchema, db._dbSchema);
    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));
}
function adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {
    const storeNames = idbtrans.db.objectStoreNames;
    for (let i = 0; i < storeNames.length; ++i) {
        const storeName = storeNames[i];
        const store = idbtrans.objectStore(storeName);
        db._hasGetAll = 'getAll' in store;
        for (let j = 0; j < store.indexNames.length; ++j) {
            const indexName = store.indexNames[j];
            const keyPath = store.index(indexName).keyPath;
            const dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
            if (schema[storeName]) {
                const indexSpec = schema[storeName].idxByName[dexieName];
                if (indexSpec) {
                    indexSpec.name = indexName;
                    delete schema[storeName].idxByName[dexieName];
                    schema[storeName].idxByName[indexName] = indexSpec;
                }
            }
        }
    }
    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
        !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&
        [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
        db._hasGetAll = false;
    }
}
function parseIndexSyntax(primKeyAndIndexes) {
    return primKeyAndIndexes.split(',').map((index, indexNum) => {
        index = index.trim();
        const name = index.replace(/([&*]|\+\+)/g, "");
        const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
        return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
    });
}

class Version {
    _parseStoresSpec(stores, outSchema) {
        keys(stores).forEach(tableName => {
            if (stores[tableName] !== null) {
                var indexes = parseIndexSyntax(stores[tableName]);
                var primKey = indexes.shift();
                if (primKey.multi)
                    throw new exceptions.Schema("Primary key cannot be multi-valued");
                indexes.forEach(idx => {
                    if (idx.auto)
                        throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                    if (!idx.keyPath)
                        throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                });
                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
            }
        });
    }
    stores(stores) {
        const db = this.db;
        this._cfg.storesSource = this._cfg.storesSource ?
            extend(this._cfg.storesSource, stores) :
            stores;
        const versions = db._versions;
        const storesSpec = {};
        let dbschema = {};
        versions.forEach(version => {
            extend(storesSpec, version._cfg.storesSource);
            dbschema = (version._cfg.dbschema = {});
            version._parseStoresSpec(storesSpec, dbschema);
        });
        db._dbSchema = dbschema;
        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
        db._storeNames = keys(dbschema);
        return this;
    }
    upgrade(upgradeFunction) {
        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
        return this;
    }
}

function createVersionConstructor(db) {
    return makeClassConstructor(Version.prototype, function Version(versionNumber) {
        this.db = db;
        this._cfg = {
            version: versionNumber,
            storesSource: null,
            dbschema: {},
            tables: {},
            contentUpgrade: null
        };
    });
}

function getDbNamesTable(indexedDB, IDBKeyRange) {
    let dbNamesDB = indexedDB["_dbNamesDB"];
    if (!dbNamesDB) {
        dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
            addons: [],
            indexedDB,
            IDBKeyRange,
        });
        dbNamesDB.version(1).stores({ dbnames: "name" });
    }
    return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB) {
    return indexedDB && typeof indexedDB.databases === "function";
}
function getDatabaseNames({ indexedDB, IDBKeyRange, }) {
    return hasDatabasesNative(indexedDB)
        ? Promise.resolve(indexedDB.databases()).then((infos) => infos
            .map((info) => info.name)
            .filter((name) => name !== DBNAMES_DB))
        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
}
function _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {
    !hasDatabasesNative(indexedDB) &&
        name !== DBNAMES_DB &&
        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);
}
function _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {
    !hasDatabasesNative(indexedDB) &&
        name !== DBNAMES_DB &&
        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);
}

function vip(fn) {
    return newScope(function () {
        PSD.letThrough = true;
        return fn();
    });
}

function idbReady() {
    var isSafari = !navigator.userAgentData &&
        /Safari\//.test(navigator.userAgent) &&
        !/Chrom(e|ium)\//.test(navigator.userAgent);
    if (!isSafari || !indexedDB.databases)
        return Promise.resolve();
    var intervalId;
    return new Promise(function (resolve) {
        var tryIdb = function () { return indexedDB.databases().finally(resolve); };
        intervalId = setInterval(tryIdb, 100);
        tryIdb();
    }).finally(function () { return clearInterval(intervalId); });
}

function dexieOpen(db) {
    const state = db._state;
    const { indexedDB } = db._deps;
    if (state.isBeingOpened || db.idbdb)
        return state.dbReadyPromise.then(() => state.dbOpenError ?
            rejection(state.dbOpenError) :
            db);
    debug && (state.openCanceller._stackHolder = getErrorWithStack());
    state.isBeingOpened = true;
    state.dbOpenError = null;
    state.openComplete = false;
    const openCanceller = state.openCanceller;
    function throwIfCancelled() {
        if (state.openCanceller !== openCanceller)
            throw new exceptions.DatabaseClosed('db.open() was cancelled');
    }
    let resolveDbReady = state.dbReadyResolve,
    upgradeTransaction = null, wasCreated = false;
    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {
            throwIfCancelled();
            if (!indexedDB)
                throw new exceptions.MissingAPI();
            const dbName = db.name;
            const req = state.autoSchema ?
                indexedDB.open(dbName) :
                indexedDB.open(dbName, Math.round(db.verno * 10));
            if (!req)
                throw new exceptions.MissingAPI();
            req.onerror = eventRejectHandler(reject);
            req.onblocked = wrap(db._fireOnBlocked);
            req.onupgradeneeded = wrap(e => {
                upgradeTransaction = req.transaction;
                if (state.autoSchema && !db._options.allowEmptyDB) {
                    req.onerror = preventDefault;
                    upgradeTransaction.abort();
                    req.result.close();
                    const delreq = indexedDB.deleteDatabase(dbName);
                    delreq.onsuccess = delreq.onerror = wrap(() => {
                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
                    });
                }
                else {
                    upgradeTransaction.onerror = eventRejectHandler(reject);
                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                    wasCreated = oldVer < 1;
                    db._novip.idbdb = req.result;
                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                }
            }, reject);
            req.onsuccess = wrap(() => {
                upgradeTransaction = null;
                const idbdb = db._novip.idbdb = req.result;
                const objectStoreNames = slice(idbdb.objectStoreNames);
                if (objectStoreNames.length > 0)
                    try {
                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                        if (state.autoSchema)
                            readGlobalSchema(db, idbdb, tmpTrans);
                        else {
                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                            if (!verifyInstalledSchema(db, tmpTrans)) {
                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
                            }
                        }
                        generateMiddlewareStacks(db, tmpTrans);
                    }
                    catch (e) {
                    }
                connections.push(db);
                idbdb.onversionchange = wrap(ev => {
                    state.vcFired = true;
                    db.on("versionchange").fire(ev);
                });
                idbdb.onclose = wrap(ev => {
                    db.on("close").fire(ev);
                });
                if (wasCreated)
                    _onDatabaseCreated(db._deps, dbName);
                resolve();
            }, reject);
        }))]).then(() => {
        throwIfCancelled();
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
            if (state.onReadyBeingFired.length > 0) {
                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);
                state.onReadyBeingFired = [];
                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
            }
        });
    }).finally(() => {
        state.onReadyBeingFired = null;
        state.isBeingOpened = false;
    }).then(() => {
        return db;
    }).catch(err => {
        state.dbOpenError = err;
        try {
            upgradeTransaction && upgradeTransaction.abort();
        }
        catch (_a) { }
        if (openCanceller === state.openCanceller) {
            db._close();
        }
        return rejection(err);
    }).finally(() => {
        state.openComplete = true;
        resolveDbReady();
    });
}

function awaitIterator(iterator) {
    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);
    function step(getNext) {
        return (val) => {
            var next = getNext(val), value = next.value;
            return next.done ? value :
                (!value || typeof value.then !== 'function' ?
                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :
                    value.then(onSuccess, onError));
        };
    }
    return step(callNext)();
}

function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
    var i = arguments.length;
    if (i < 2)
        throw new exceptions.InvalidArgument("Too few arguments");
    var args = new Array(i - 1);
    while (--i)
        args[i - 1] = arguments[i];
    scopeFunc = args.pop();
    var tables = flatten(args);
    return [mode, tables, scopeFunc];
}
function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
    return DexiePromise.resolve().then(() => {
        const transless = PSD.transless || PSD;
        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
        const zoneProps = {
            trans: trans,
            transless: transless
        };
        if (parentTransaction) {
            trans.idbtrans = parentTransaction.idbtrans;
        }
        else {
            try {
                trans.create();
                db._state.PR1398_maxLoop = 3;
            }
            catch (ex) {
                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                    console.warn('Dexie: Need to reopen db');
                    db._close();
                    return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
                }
                return rejection(ex);
            }
        }
        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
        if (scopeFuncIsAsync) {
            incrementExpectedAwaits();
        }
        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
            returnValue = scopeFunc.call(trans, trans);
            if (returnValue) {
                if (scopeFuncIsAsync) {
                    var decrementor = decrementExpectedAwaits.bind(null, null);
                    returnValue.then(decrementor, decrementor);
                }
                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                    returnValue = awaitIterator(returnValue);
                }
            }
        }, zoneProps);
        return (returnValue && typeof returnValue.then === 'function' ?
            DexiePromise.resolve(returnValue).then(x => trans.active ?
                x
                : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")))
            : promiseFollowed.then(() => returnValue)).then(x => {
            if (parentTransaction)
                trans._resolve();
            return trans._completion.then(() => x);
        }).catch(e => {
            trans._reject(e);
            return rejection(e);
        });
    });
}

function pad(a, value, count) {
    const result = isArray(a) ? a.slice() : [a];
    for (let i = 0; i < count; ++i)
        result.push(value);
    return result;
}
function createVirtualIndexMiddleware(down) {
    return {
        ...down,
        table(tableName) {
            const table = down.table(tableName);
            const { schema } = table;
            const indexLookup = {};
            const allVirtualIndexes = [];
            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                const keyPathAlias = getKeyPathAlias(keyPath);
                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);
                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                const isVirtual = keyTail > 0;
                const virtualIndex = {
                    ...lowLevelIndex,
                    isVirtual,
                    keyTail,
                    keyLength,
                    extractKey: getKeyExtractor(keyPath),
                    unique: !isVirtual && lowLevelIndex.unique
                };
                indexList.push(virtualIndex);
                if (!virtualIndex.isPrimaryKey) {
                    allVirtualIndexes.push(virtualIndex);
                }
                if (keyLength > 1) {
                    const virtualKeyPath = keyLength === 2 ?
                        keyPath[0] :
                        keyPath.slice(0, keyLength - 1);
                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                }
                indexList.sort((a, b) => a.keyTail - b.keyTail);
                return virtualIndex;
            }
            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
            indexLookup[":id"] = [primaryKey];
            for (const index of schema.indexes) {
                addVirtualIndexes(index.keyPath, 0, index);
            }
            function findBestIndex(keyPath) {
                const result = indexLookup[getKeyPathAlias(keyPath)];
                return result && result[0];
            }
            function translateRange(range, keyTail) {
                return {
                    type: range.type === 1  ?
                        2  :
                        range.type,
                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                    lowerOpen: true,
                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                    upperOpen: true
                };
            }
            function translateRequest(req) {
                const index = req.query.index;
                return index.isVirtual ? {
                    ...req,
                    query: {
                        index,
                        range: translateRange(req.query.range, index.keyTail)
                    }
                } : req;
            }
            const result = {
                ...table,
                schema: {
                    ...schema,
                    primaryKey,
                    indexes: allVirtualIndexes,
                    getIndexByKeyPath: findBestIndex
                },
                count(req) {
                    return table.count(translateRequest(req));
                },
                query(req) {
                    return table.query(translateRequest(req));
                },
                openCursor(req) {
                    const { keyTail, isVirtual, keyLength } = req.query.index;
                    if (!isVirtual)
                        return table.openCursor(req);
                    function createVirtualCursor(cursor) {
                        function _continue(key) {
                            key != null ?
                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :
                                req.unique ?
                                    cursor.continue(cursor.key.slice(0, keyLength)
                                        .concat(req.reverse
                                        ? down.MIN_KEY
                                        : down.MAX_KEY, keyTail)) :
                                    cursor.continue();
                        }
                        const virtualCursor = Object.create(cursor, {
                            continue: { value: _continue },
                            continuePrimaryKey: {
                                value(key, primaryKey) {
                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                }
                            },
                            primaryKey: {
                                get() {
                                    return cursor.primaryKey;
                                }
                            },
                            key: {
                                get() {
                                    const key = cursor.key;
                                    return keyLength === 1 ?
                                        key[0] :
                                        key.slice(0, keyLength);
                                }
                            },
                            value: {
                                get() {
                                    return cursor.value;
                                }
                            }
                        });
                        return virtualCursor;
                    }
                    return table.openCursor(translateRequest(req))
                        .then(cursor => cursor && createVirtualCursor(cursor));
                }
            };
            return result;
        }
    };
}
const virtualIndexMiddleware = {
    stack: "dbcore",
    name: "VirtualIndexMiddleware",
    level: 1,
    create: createVirtualIndexMiddleware
};

function getObjectDiff(a, b, rv, prfx) {
    rv = rv || {};
    prfx = prfx || '';
    keys(a).forEach((prop) => {
        if (!hasOwn(b, prop)) {
            rv[prfx + prop] = undefined;
        }
        else {
            var ap = a[prop], bp = b[prop];
            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                const apTypeName = toStringTag(ap);
                const bpTypeName = toStringTag(bp);
                if (apTypeName !== bpTypeName) {
                    rv[prfx + prop] = b[prop];
                }
                else if (apTypeName === 'Object') {
                    getObjectDiff(ap, bp, rv, prfx + prop + '.');
                }
                else if (ap !== bp) {
                    rv[prfx + prop] = b[prop];
                }
            }
            else if (ap !== bp)
                rv[prfx + prop] = b[prop];
        }
    });
    keys(b).forEach((prop) => {
        if (!hasOwn(a, prop)) {
            rv[prfx + prop] = b[prop];
        }
    });
    return rv;
}

function getEffectiveKeys(primaryKey, req) {
    if (req.type === 'delete')
        return req.keys;
    return req.keys || req.values.map(primaryKey.extractKey);
}

const hooksMiddleware = {
    stack: "dbcore",
    name: "HooksMiddleware",
    level: 2,
    create: (downCore) => ({
        ...downCore,
        table(tableName) {
            const downTable = downCore.table(tableName);
            const { primaryKey } = downTable.schema;
            const tableMiddleware = {
                ...downTable,
                mutate(req) {
                    const dxTrans = PSD.trans;
                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;
                    switch (req.type) {
                        case 'add':
                            if (creating.fire === nop)
                                break;
                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);
                        case 'put':
                            if (creating.fire === nop && updating.fire === nop)
                                break;
                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);
                        case 'delete':
                            if (deleting.fire === nop)
                                break;
                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);
                        case 'deleteRange':
                            if (deleting.fire === nop)
                                break;
                            return dxTrans._promise('readwrite', () => deleteRange(req), true);
                    }
                    return downTable.mutate(req);
                    function addPutOrDelete(req) {
                        const dxTrans = PSD.trans;
                        const keys = req.keys || getEffectiveKeys(primaryKey, req);
                        if (!keys)
                            throw new Error("Keys missing");
                        req = req.type === 'add' || req.type === 'put' ?
                            { ...req, keys } :
                            { ...req };
                        if (req.type !== 'delete')
                            req.values = [...req.values];
                        if (req.keys)
                            req.keys = [...req.keys];
                        return getExistingValues(downTable, req, keys).then(existingValues => {
                            const contexts = keys.map((key, i) => {
                                const existingValue = existingValues[i];
                                const ctx = { onerror: null, onsuccess: null };
                                if (req.type === 'delete') {
                                    deleting.fire.call(ctx, key, existingValue, dxTrans);
                                }
                                else if (req.type === 'add' || existingValue === undefined) {
                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                    if (key == null && generatedPrimaryKey != null) {
                                        key = generatedPrimaryKey;
                                        req.keys[i] = key;
                                        if (!primaryKey.outbound) {
                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                        }
                                    }
                                }
                                else {
                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);
                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                    if (additionalChanges) {
                                        const requestedValue = req.values[i];
                                        Object.keys(additionalChanges).forEach(keyPath => {
                                            if (hasOwn(requestedValue, keyPath)) {
                                                requestedValue[keyPath] = additionalChanges[keyPath];
                                            }
                                            else {
                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                                            }
                                        });
                                    }
                                }
                                return ctx;
                            });
                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {
                                for (let i = 0; i < keys.length; ++i) {
                                    const primKey = results ? results[i] : keys[i];
                                    const ctx = contexts[i];
                                    if (primKey == null) {
                                        ctx.onerror && ctx.onerror(failures[i]);
                                    }
                                    else {
                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?
                                            req.values[i] :
                                            primKey
                                        );
                                    }
                                }
                                return { failures, results, numFailures, lastResult };
                            }).catch(error => {
                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));
                                return Promise.reject(error);
                            });
                        });
                    }
                    function deleteRange(req) {
                        return deleteNextChunk(req.trans, req.range, 10000);
                    }
                    function deleteNextChunk(trans, range, limit) {
                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })
                            .then(({ result }) => {
                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {
                                if (res.numFailures > 0)
                                    return Promise.reject(res.failures[0]);
                                if (result.length < limit) {
                                    return { failures: [], numFailures: 0, lastResult: undefined };
                                }
                                else {
                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);
                                }
                            });
                        });
                    }
                }
            };
            return tableMiddleware;
        },
    })
};
function getExistingValues(table, req, effectiveKeys) {
    return req.type === "add"
        ? Promise.resolve([])
        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
}

function getFromTransactionCache(keys, cache, clone) {
    try {
        if (!cache)
            return null;
        if (cache.keys.length < keys.length)
            return null;
        const result = [];
        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
            if (cmp(cache.keys[i], keys[j]) !== 0)
                continue;
            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
            ++j;
        }
        return result.length === keys.length ? result : null;
    }
    catch (_a) {
        return null;
    }
}
const cacheExistingValuesMiddleware = {
    stack: "dbcore",
    level: -1,
    create: (core) => {
        return {
            table: (tableName) => {
                const table = core.table(tableName);
                return {
                    ...table,
                    getMany: (req) => {
                        if (!req.cache) {
                            return table.getMany(req);
                        }
                        const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                        if (cachedResult) {
                            return DexiePromise.resolve(cachedResult);
                        }
                        return table.getMany(req).then((res) => {
                            req.trans["_cache"] = {
                                keys: req.keys,
                                values: req.cache === "clone" ? deepClone(res) : res,
                            };
                            return res;
                        });
                    },
                    mutate: (req) => {
                        if (req.type !== "add")
                            req.trans["_cache"] = null;
                        return table.mutate(req);
                    },
                };
            },
        };
    },
};

function isEmptyRange(node) {
    return !("from" in node);
}
const RangeSet = function (fromOrTree, to) {
    if (this) {
        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
    }
    else {
        const rv = new RangeSet();
        if (fromOrTree && ("d" in fromOrTree)) {
            extend(rv, fromOrTree);
        }
        return rv;
    }
};
props(RangeSet.prototype, {
    add(rangeSet) {
        mergeRanges(this, rangeSet);
        return this;
    },
    addKey(key) {
        addRange(this, key, key);
        return this;
    },
    addKeys(keys) {
        keys.forEach(key => addRange(this, key, key));
        return this;
    },
    [iteratorSymbol]() {
        return getRangeSetIterator(this);
    }
});
function addRange(target, from, to) {
    const diff = cmp(from, to);
    if (isNaN(diff))
        return;
    if (diff > 0)
        throw RangeError();
    if (isEmptyRange(target))
        return extend(target, { from, to, d: 1 });
    const left = target.l;
    const right = target.r;
    if (cmp(to, target.from) < 0) {
        left
            ? addRange(left, from, to)
            : (target.l = { from, to, d: 1, l: null, r: null });
        return rebalance(target);
    }
    if (cmp(from, target.to) > 0) {
        right
            ? addRange(right, from, to)
            : (target.r = { from, to, d: 1, l: null, r: null });
        return rebalance(target);
    }
    if (cmp(from, target.from) < 0) {
        target.from = from;
        target.l = null;
        target.d = right ? right.d + 1 : 1;
    }
    if (cmp(to, target.to) > 0) {
        target.to = to;
        target.r = null;
        target.d = target.l ? target.l.d + 1 : 1;
    }
    const rightWasCutOff = !target.r;
    if (left && !target.l) {
        mergeRanges(target, left);
    }
    if (right && rightWasCutOff) {
        mergeRanges(target, right);
    }
}
function mergeRanges(target, newSet) {
    function _addRangeSet(target, { from, to, l, r }) {
        addRange(target, from, to);
        if (l)
            _addRangeSet(target, l);
        if (r)
            _addRangeSet(target, r);
    }
    if (!isEmptyRange(newSet))
        _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
    const i1 = getRangeSetIterator(rangeSet2);
    let nextResult1 = i1.next();
    if (nextResult1.done)
        return false;
    let a = nextResult1.value;
    const i2 = getRangeSetIterator(rangeSet1);
    let nextResult2 = i2.next(a.from);
    let b = nextResult2.value;
    while (!nextResult1.done && !nextResult2.done) {
        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
            return true;
        cmp(a.from, b.from) < 0
            ? (a = (nextResult1 = i1.next(b.from)).value)
            : (b = (nextResult2 = i2.next(a.from)).value);
    }
    return false;
}
function getRangeSetIterator(node) {
    let state = isEmptyRange(node) ? null : { s: 0, n: node };
    return {
        next(key) {
            const keyProvided = arguments.length > 0;
            while (state) {
                switch (state.s) {
                    case 0:
                        state.s = 1;
                        if (keyProvided) {
                            while (state.n.l && cmp(key, state.n.from) < 0)
                                state = { up: state, n: state.n.l, s: 1 };
                        }
                        else {
                            while (state.n.l)
                                state = { up: state, n: state.n.l, s: 1 };
                        }
                    case 1:
                        state.s = 2;
                        if (!keyProvided || cmp(key, state.n.to) <= 0)
                            return { value: state.n, done: false };
                    case 2:
                        if (state.n.r) {
                            state.s = 3;
                            state = { up: state, n: state.n.r, s: 0 };
                            continue;
                        }
                    case 3:
                        state = state.up;
                }
            }
            return { done: true };
        },
    };
}
function rebalance(target) {
    var _a, _b;
    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
    const r = diff > 1 ? "r" : diff < -1 ? "l" : "";
    if (r) {
        const l = r === "r" ? "l" : "r";
        const rootClone = { ...target };
        const oldRootRight = target[r];
        target.from = oldRootRight.from;
        target.to = oldRootRight.to;
        target[r] = oldRootRight[r];
        rootClone[r] = oldRootRight[l];
        target[l] = rootClone;
        rootClone.d = computeDepth(rootClone);
    }
    target.d = computeDepth(target);
}
function computeDepth({ r, l }) {
    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;
}

const observabilityMiddleware = {
    stack: "dbcore",
    level: 0,
    create: (core) => {
        const dbName = core.schema.name;
        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
        return {
            ...core,
            table: (tableName) => {
                const table = core.table(tableName);
                const { schema } = table;
                const { primaryKey } = schema;
                const { extractKey, outbound } = primaryKey;
                const tableClone = {
                    ...table,
                    mutate: (req) => {
                        const trans = req.trans;
                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
                        const getRangeSet = (indexName) => {
                            const part = `idb://${dbName}/${tableName}/${indexName}`;
                            return (mutatedParts[part] ||
                                (mutatedParts[part] = new RangeSet()));
                        };
                        const pkRangeSet = getRangeSet("");
                        const delsRangeSet = getRangeSet(":dels");
                        const { type } = req;
                        let [keys, newObjs] = req.type === "deleteRange"
                            ? [req.range]
                            : req.type === "delete"
                                ? [req.keys]
                                : req.values.length < 50
                                    ? [[], req.values]
                                    : [];
                        const oldCache = req.trans["_cache"];
                        return table.mutate(req).then((res) => {
                            if (isArray(keys)) {
                                if (type !== "delete")
                                    keys = res.results;
                                pkRangeSet.addKeys(keys);
                                const oldObjs = getFromTransactionCache(keys, oldCache);
                                if (!oldObjs && type !== "add") {
                                    delsRangeSet.addKeys(keys);
                                }
                                if (oldObjs || newObjs) {
                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                                }
                            }
                            else if (keys) {
                                const range = { from: keys.lower, to: keys.upper };
                                delsRangeSet.add(range);
                                pkRangeSet.add(range);
                            }
                            else {
                                pkRangeSet.add(FULL_RANGE);
                                delsRangeSet.add(FULL_RANGE);
                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));
                            }
                            return res;
                        });
                    },
                };
                const getRange = ({ query: { index, range }, }) => {
                    var _a, _b;
                    return [
                        index,
                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),
                    ];
                };
                const readSubscribers = {
                    get: (req) => [primaryKey, new RangeSet(req.key)],
                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],
                    count: getRange,
                    query: getRange,
                    openCursor: getRange,
                };
                keys(readSubscribers).forEach(method => {
                    tableClone[method] = function (req) {
                        const { subscr } = PSD;
                        if (subscr) {
                            const getRangeSet = (indexName) => {
                                const part = `idb://${dbName}/${tableName}/${indexName}`;
                                return (subscr[part] ||
                                    (subscr[part] = new RangeSet()));
                            };
                            const pkRangeSet = getRangeSet("");
                            const delsRangeSet = getRangeSet(":dels");
                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);
                            getRangeSet(queriedIndex.name || "").add(queriedRanges);
                            if (!queriedIndex.isPrimaryKey) {
                                if (method === "count") {
                                    delsRangeSet.add(FULL_RANGE);
                                }
                                else {
                                    const keysPromise = method === "query" &&
                                        outbound &&
                                        req.values &&
                                        table.query({
                                            ...req,
                                            values: false,
                                        });
                                    return table[method].apply(this, arguments).then((res) => {
                                        if (method === "query") {
                                            if (outbound && req.values) {
                                                return keysPromise.then(({ result: resultingKeys }) => {
                                                    pkRangeSet.addKeys(resultingKeys);
                                                    return res;
                                                });
                                            }
                                            const pKeys = req.values
                                                ? res.result.map(extractKey)
                                                : res.result;
                                            if (req.values) {
                                                pkRangeSet.addKeys(pKeys);
                                            }
                                            else {
                                                delsRangeSet.addKeys(pKeys);
                                            }
                                        }
                                        else if (method === "openCursor") {
                                            const cursor = res;
                                            const wantValues = req.values;
                                            return (cursor &&
                                                Object.create(cursor, {
                                                    key: {
                                                        get() {
                                                            delsRangeSet.addKey(cursor.primaryKey);
                                                            return cursor.key;
                                                        },
                                                    },
                                                    primaryKey: {
                                                        get() {
                                                            const pkey = cursor.primaryKey;
                                                            delsRangeSet.addKey(pkey);
                                                            return pkey;
                                                        },
                                                    },
                                                    value: {
                                                        get() {
                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);
                                                            return cursor.value;
                                                        },
                                                    },
                                                }));
                                        }
                                        return res;
                                    });
                                }
                            }
                        }
                        return table[method].apply(this, arguments);
                    };
                });
                return tableClone;
            },
        };
    },
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
    function addAffectedIndex(ix) {
        const rangeSet = getRangeSet(ix.name || "");
        function extractKey(obj) {
            return obj != null ? ix.extractKey(obj) : null;
        }
        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)
            ? key.forEach(key => rangeSet.addKey(key))
            : rangeSet.addKey(key);
        (oldObjs || newObjs).forEach((_, i) => {
            const oldKey = oldObjs && extractKey(oldObjs[i]);
            const newKey = newObjs && extractKey(newObjs[i]);
            if (cmp(oldKey, newKey) !== 0) {
                if (oldKey != null)
                    addKeyOrKeys(oldKey);
                if (newKey != null)
                    addKeyOrKeys(newKey);
            }
        });
    }
    schema.indexes.forEach(addAffectedIndex);
}

class Dexie$1 {
    constructor(name, options) {
        this._middlewares = {};
        this.verno = 0;
        const deps = Dexie$1.dependencies;
        this._options = options = {
            addons: Dexie$1.addons,
            autoOpen: true,
            indexedDB: deps.indexedDB,
            IDBKeyRange: deps.IDBKeyRange,
            ...options
        };
        this._deps = {
            indexedDB: options.indexedDB,
            IDBKeyRange: options.IDBKeyRange
        };
        const { addons, } = options;
        this._dbSchema = {};
        this._versions = [];
        this._storeNames = [];
        this._allTables = {};
        this.idbdb = null;
        this._novip = this;
        const state = {
            dbOpenError: null,
            isBeingOpened: false,
            onReadyBeingFired: null,
            openComplete: false,
            dbReadyResolve: nop,
            dbReadyPromise: null,
            cancelOpen: nop,
            openCanceller: null,
            autoSchema: true,
            PR1398_maxLoop: 3
        };
        state.dbReadyPromise = new DexiePromise(resolve => {
            state.dbReadyResolve = resolve;
        });
        state.openCanceller = new DexiePromise((_, reject) => {
            state.cancelOpen = reject;
        });
        this._state = state;
        this.name = name;
        this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {
            return (subscriber, bSticky) => {
                Dexie$1.vip(() => {
                    const state = this._state;
                    if (state.openComplete) {
                        if (!state.dbOpenError)
                            DexiePromise.resolve().then(subscriber);
                        if (bSticky)
                            subscribe(subscriber);
                    }
                    else if (state.onReadyBeingFired) {
                        state.onReadyBeingFired.push(subscriber);
                        if (bSticky)
                            subscribe(subscriber);
                    }
                    else {
                        subscribe(subscriber);
                        const db = this;
                        if (!bSticky)
                            subscribe(function unsubscribe() {
                                db.on.ready.unsubscribe(subscriber);
                                db.on.ready.unsubscribe(unsubscribe);
                            });
                    }
                });
            };
        });
        this.Collection = createCollectionConstructor(this);
        this.Table = createTableConstructor(this);
        this.Transaction = createTransactionConstructor(this);
        this.Version = createVersionConstructor(this);
        this.WhereClause = createWhereClauseConstructor(this);
        this.on("versionchange", ev => {
            if (ev.newVersion > 0)
                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
            else
                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
            this.close();
        });
        this.on("blocked", ev => {
            if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                console.warn(`Dexie.delete('${this.name}') was blocked`);
            else
                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
        });
        this._maxKey = getMaxKey(options.IDBKeyRange);
        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
        this._fireOnBlocked = ev => {
            this.on("blocked").fire(ev);
            connections
                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)
                .map(c => c.on("versionchange").fire(ev));
        };
        this.use(virtualIndexMiddleware);
        this.use(hooksMiddleware);
        this.use(observabilityMiddleware);
        this.use(cacheExistingValuesMiddleware);
        this.vip = Object.create(this, { _vip: { value: true } });
        addons.forEach(addon => addon(this));
    }
    version(versionNumber) {
        if (isNaN(versionNumber) || versionNumber < 0.1)
            throw new exceptions.Type(`Given version is not a positive number`);
        versionNumber = Math.round(versionNumber * 10) / 10;
        if (this.idbdb || this._state.isBeingOpened)
            throw new exceptions.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, versionNumber);
        const versions = this._versions;
        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];
        if (versionInstance)
            return versionInstance;
        versionInstance = new this.Version(versionNumber);
        versions.push(versionInstance);
        versions.sort(lowerVersionFirst);
        versionInstance.stores({});
        this._state.autoSchema = false;
        return versionInstance;
    }
    _whenReady(fn) {
        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {
            if (this._state.openComplete) {
                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));
            }
            if (!this._state.isBeingOpened) {
                if (!this._options.autoOpen) {
                    reject(new exceptions.DatabaseClosed());
                    return;
                }
                this.open().catch(nop);
            }
            this._state.dbReadyPromise.then(resolve, reject);
        }).then(fn);
    }
    use({ stack, create, level, name }) {
        if (name)
            this.unuse({ stack, name });
        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
        middlewares.push({ stack, create, level: level == null ? 10 : level, name });
        middlewares.sort((a, b) => a.level - b.level);
        return this;
    }
    unuse({ stack, name, create }) {
        if (stack && this._middlewares[stack]) {
            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :
                name ? mw.name !== name :
                    false);
        }
        return this;
    }
    open() {
        return dexieOpen(this);
    }
    _close() {
        const state = this._state;
        const idx = connections.indexOf(this);
        if (idx >= 0)
            connections.splice(idx, 1);
        if (this.idbdb) {
            try {
                this.idbdb.close();
            }
            catch (e) { }
            this._novip.idbdb = null;
        }
        state.dbReadyPromise = new DexiePromise(resolve => {
            state.dbReadyResolve = resolve;
        });
        state.openCanceller = new DexiePromise((_, reject) => {
            state.cancelOpen = reject;
        });
    }
    close() {
        this._close();
        const state = this._state;
        this._options.autoOpen = false;
        state.dbOpenError = new exceptions.DatabaseClosed();
        if (state.isBeingOpened)
            state.cancelOpen(state.dbOpenError);
    }
    delete() {
        const hasArguments = arguments.length > 0;
        const state = this._state;
        return new DexiePromise((resolve, reject) => {
            const doDelete = () => {
                this.close();
                var req = this._deps.indexedDB.deleteDatabase(this.name);
                req.onsuccess = wrap(() => {
                    _onDatabaseDeleted(this._deps, this.name);
                    resolve();
                });
                req.onerror = eventRejectHandler(reject);
                req.onblocked = this._fireOnBlocked;
            };
            if (hasArguments)
                throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
            if (state.isBeingOpened) {
                state.dbReadyPromise.then(doDelete);
            }
            else {
                doDelete();
            }
        });
    }
    backendDB() {
        return this.idbdb;
    }
    isOpen() {
        return this.idbdb !== null;
    }
    hasBeenClosed() {
        const dbOpenError = this._state.dbOpenError;
        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');
    }
    hasFailed() {
        return this._state.dbOpenError !== null;
    }
    dynamicallyOpened() {
        return this._state.autoSchema;
    }
    get tables() {
        return keys(this._allTables).map(name => this._allTables[name]);
    }
    transaction() {
        const args = extractTransactionArgs.apply(this, arguments);
        return this._transaction.apply(this, args);
    }
    _transaction(mode, tables, scopeFunc) {
        let parentTransaction = PSD.trans;
        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)
            parentTransaction = null;
        const onlyIfCompatible = mode.indexOf('?') !== -1;
        mode = mode.replace('!', '').replace('?', '');
        let idbMode, storeNames;
        try {
            storeNames = tables.map(table => {
                var storeName = table instanceof this.Table ? table.name : table;
                if (typeof storeName !== 'string')
                    throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                return storeName;
            });
            if (mode == "r" || mode === READONLY)
                idbMode = READONLY;
            else if (mode == "rw" || mode == READWRITE)
                idbMode = READWRITE;
            else
                throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
            if (parentTransaction) {
                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                    if (onlyIfCompatible) {
                        parentTransaction = null;
                    }
                    else
                        throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                }
                if (parentTransaction) {
                    storeNames.forEach(storeName => {
                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                            if (onlyIfCompatible) {
                                parentTransaction = null;
                            }
                            else
                                throw new exceptions.SubTransaction("Table " + storeName +
                                    " not included in parent transaction.");
                        }
                    });
                }
                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                    parentTransaction = null;
                }
            }
        }
        catch (e) {
            return parentTransaction ?
                parentTransaction._promise(null, (_, reject) => { reject(e); }) :
                rejection(e);
        }
        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
        return (parentTransaction ?
            parentTransaction._promise(idbMode, enterTransaction, "lock") :
            PSD.trans ?
                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :
                this._whenReady(enterTransaction));
    }
    table(tableName) {
        if (!hasOwn(this._allTables, tableName)) {
            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
        }
        return this._allTables[tableName];
    }
}

const symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol
    ? Symbol.observable
    : "@@observable";
class Observable {
    constructor(subscribe) {
        this._subscribe = subscribe;
    }
    subscribe(x, error, complete) {
        return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
    }
    [symbolObservable]() {
        return this;
    }
}

function extendObservabilitySet(target, newSet) {
    keys(newSet).forEach(part => {
        const rangeSet = target[part] || (target[part] = new RangeSet());
        mergeRanges(rangeSet, newSet[part]);
    });
    return target;
}

function liveQuery(querier) {
    return new Observable((observer) => {
        const scopeFuncIsAsync = isAsyncFunction(querier);
        function execute(subscr) {
            if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
            }
            const exec = () => newScope(querier, { subscr, trans: null });
            const rv = PSD.trans
                ?
                    usePSD(PSD.transless, exec)
                : exec();
            if (scopeFuncIsAsync) {
                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
            }
            return rv;
        }
        let closed = false;
        let accumMuts = {};
        let currentObs = {};
        const subscription = {
            get closed() {
                return closed;
            },
            unsubscribe: () => {
                closed = true;
                globalEvents.storagemutated.unsubscribe(mutationListener);
            },
        };
        observer.start && observer.start(subscription);
        let querying = false, startedListening = false;
        function shouldNotify() {
            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
        }
        const mutationListener = (parts) => {
            extendObservabilitySet(accumMuts, parts);
            if (shouldNotify()) {
                doQuery();
            }
        };
        const doQuery = () => {
            if (querying || closed)
                return;
            accumMuts = {};
            const subscr = {};
            const ret = execute(subscr);
            if (!startedListening) {
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                startedListening = true;
            }
            querying = true;
            Promise.resolve(ret).then((result) => {
                querying = false;
                if (closed)
                    return;
                if (shouldNotify()) {
                    doQuery();
                }
                else {
                    accumMuts = {};
                    currentObs = subscr;
                    observer.next && observer.next(result);
                }
            }, (err) => {
                querying = false;
                observer.error && observer.error(err);
                subscription.unsubscribe();
            });
        };
        doQuery();
        return subscription;
    });
}

let domDeps;
try {
    domDeps = {
        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
    };
}
catch (e) {
    domDeps = { indexedDB: null, IDBKeyRange: null };
}

const Dexie = Dexie$1;
props(Dexie, {
    ...fullNameExceptions,
    delete(databaseName) {
        const db = new Dexie(databaseName, { addons: [] });
        return db.delete();
    },
    exists(name) {
        return new Dexie(name, { addons: [] }).open().then(db => {
            db.close();
            return true;
        }).catch('NoSuchDatabaseError', () => false);
    },
    getDatabaseNames(cb) {
        try {
            return getDatabaseNames(Dexie.dependencies).then(cb);
        }
        catch (_a) {
            return rejection(new exceptions.MissingAPI());
        }
    },
    defineClass() {
        function Class(content) {
            extend(this, content);
        }
        return Class;
    },
    ignoreTransaction(scopeFunc) {
        return PSD.trans ?
            usePSD(PSD.transless, scopeFunc) :
            scopeFunc();
    },
    vip,
    async: function (generatorFn) {
        return function () {
            try {
                var rv = awaitIterator(generatorFn.apply(this, arguments));
                if (!rv || typeof rv.then !== 'function')
                    return DexiePromise.resolve(rv);
                return rv;
            }
            catch (e) {
                return rejection(e);
            }
        };
    },
    spawn: function (generatorFn, args, thiz) {
        try {
            var rv = awaitIterator(generatorFn.apply(thiz, args || []));
            if (!rv || typeof rv.then !== 'function')
                return DexiePromise.resolve(rv);
            return rv;
        }
        catch (e) {
            return rejection(e);
        }
    },
    currentTransaction: {
        get: () => PSD.trans || null
    },
    waitFor: function (promiseOrFunction, optionalTimeout) {
        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?
            Dexie.ignoreTransaction(promiseOrFunction) :
            promiseOrFunction)
            .timeout(optionalTimeout || 60000);
        return PSD.trans ?
            PSD.trans.waitFor(promise) :
            promise;
    },
    Promise: DexiePromise,
    debug: {
        get: () => debug,
        set: value => {
            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);
        }
    },
    derive: derive,
    extend: extend,
    props: props,
    override: override,
    Events: Events,
    on: globalEvents,
    liveQuery,
    extendObservabilitySet,
    getByKeyPath: getByKeyPath,
    setByKeyPath: setByKeyPath,
    delByKeyPath: delByKeyPath,
    shallowClone: shallowClone,
    deepClone: deepClone,
    getObjectDiff: getObjectDiff,
    cmp,
    asap: asap$1,
    minKey: minKey,
    addons: [],
    connections: connections,
    errnames: errnames,
    dependencies: domDeps,
    semVer: DEXIE_VERSION,
    version: DEXIE_VERSION.split('.')
        .map(n => parseInt(n))
        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),
});
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);

if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {
        if (!propagatingLocally) {
            let event;
            if (isIEOrEdge) {
                event = document.createEvent('CustomEvent');
                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
            }
            else {
                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                    detail: updatedParts
                });
            }
            propagatingLocally = true;
            dispatchEvent(event);
            propagatingLocally = false;
        }
    });
    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
        if (!propagatingLocally) {
            propagateLocally(detail);
        }
    });
}
function propagateLocally(updateParts) {
    let wasMe = propagatingLocally;
    try {
        propagatingLocally = true;
        globalEvents.storagemutated.fire(updateParts);
    }
    finally {
        propagatingLocally = wasMe;
    }
}
let propagatingLocally = false;

if (typeof BroadcastChannel !== 'undefined') {
    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
    if (typeof bc.unref === 'function') {
        bc.unref();
    }
    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
        if (!propagatingLocally) {
            bc.postMessage(changedParts);
        }
    });
    bc.onmessage = (ev) => {
        if (ev.data)
            propagateLocally(ev.data);
    };
}
else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {
    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
        try {
            if (!propagatingLocally) {
                if (typeof localStorage !== 'undefined') {
                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
                        trig: Math.random(),
                        changedParts,
                    }));
                }
                if (typeof self['clients'] === 'object') {
                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
                        type: STORAGE_MUTATED_DOM_EVENT_NAME,
                        changedParts,
                    }));
                }
            }
        }
        catch (_a) { }
    });
    if (typeof addEventListener !== 'undefined') {
        addEventListener('storage', (ev) => {
            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
                const data = JSON.parse(ev.newValue);
                if (data)
                    propagateLocally(data.changedParts);
            }
        });
    }
    const swContainer = self.document && navigator.serviceWorker;
    if (swContainer) {
        swContainer.addEventListener('message', propagateMessageLocally);
    }
}
function propagateMessageLocally({ data }) {
    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
        propagateLocally(data.changedParts);
    }
}

DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);


//# sourceMappingURL=dexie.mjs.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ "./src/main.css");
/* harmony import */ var _components_c1_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/c1-table */ "./src/components/c1-table/index.js");
/* harmony import */ var _components_c2_nav__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/c2-nav */ "./src/components/c2-nav/index.js");
/* harmony import */ var _components_l1_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/l1-app */ "./src/components/l1-app/index.js");
/* harmony import */ var _components_l2_main__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/l2-main */ "./src/components/l2-main/index.js");
/* harmony import */ var _components_m0_racer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/m0-racer */ "./src/components/m0-racer/index.js");
/* harmony import */ var _components_m1_dashboard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/m1-dashboard */ "./src/components/m1-dashboard/index.js");
/* harmony import */ var _components_m2_race__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/m2-race */ "./src/components/m2-race/index.js");
/* harmony import */ var _components_m3_runners__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/m3-runners */ "./src/components/m3-runners/index.js");
/* harmony import */ var _libs_event_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./libs/event-service */ "./src/libs/event-service.js");
/* harmony import */ var _components_m4_score__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/m4-score */ "./src/components/m4-score/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }











_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        // layout
        customElements.define('l1-app', _components_l1_app__WEBPACK_IMPORTED_MODULE_3__["default"]);
        customElements.define('l2-main', _components_l2_main__WEBPACK_IMPORTED_MODULE_4__["default"]);
        // main components
        customElements.define('m0-racer', _components_m0_racer__WEBPACK_IMPORTED_MODULE_5__["default"]);
        customElements.define('m1-dashboard', _components_m1_dashboard__WEBPACK_IMPORTED_MODULE_6__["default"]);
        customElements.define('m2-race', _components_m2_race__WEBPACK_IMPORTED_MODULE_7__["default"]);
        customElements.define('m3-runners', _components_m3_runners__WEBPACK_IMPORTED_MODULE_8__["default"]);
        customElements.define('m4-score', _components_m4_score__WEBPACK_IMPORTED_MODULE_10__["default"]);
        // others
        customElements.define('c1-table', _components_c1_table__WEBPACK_IMPORTED_MODULE_1__["default"]);
        customElements.define('c2-nav', _components_c2_nav__WEBPACK_IMPORTED_MODULE_2__["default"]);

        //start event service
        (0,_libs_event_service__WEBPACK_IMPORTED_MODULE_9__.getEventService)().start();
      case 10:
      case "end":
        return _context.stop();
    }
  }, _callee);
}))();
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEI7QUFDNUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxFQUFFLDRCQUE0QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCLEVBQUUsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QixrQkFBa0I7QUFDL0Q7QUFDQSxrQkFBa0I7QUFDbEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLDRCQUE0QiwyQkFBMkIsNEJBQTRCO0FBQzNMO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBeUQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFFBQVE7QUFDakYscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUVBQWlFLDRDQUE0QztBQUM3RyxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwrQkFBK0IsMEJBQTBCLFNBQVM7QUFDbkgscUNBQXFDLFFBQVE7QUFDN0Msb0RBQW9ELHFDQUFxQztBQUN6RjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLG9FQUFvRSw2REFBNkQ7QUFDakk7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBMkQ7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQTBDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFFQUFxRSxJQUFJLE1BQU07QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLHdCQUF3QixhQUFhO0FBQ3JDLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQSxrREFBa0QsT0FBTyxHQUFHLFVBQVUsR0FBRyxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0Esb0NBQW9DLFNBQVMsY0FBYyxHQUFHO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQSxzREFBc0QsT0FBTyxHQUFHLFVBQVUsR0FBRyxVQUFVO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsdUJBQXVCO0FBQ2xHO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQscURBQXFEO0FBQ3JELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrRkFBa0YsK0JBQStCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFVBQVU7QUFDeEY7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSx5Q0FBeUMsVUFBVSxnREFBZ0QsbUJBQW1CO0FBQ3RILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUSxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBLDJCQUEyQix3REFBd0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlF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Tiw0REFBTyxDQUFDO1FBQzFDb1gsY0FBYyxDQUFDcmtCLE1BQU0sQ0FBQyxRQUFRLEVBQUVzUSwwREFBSyxDQUFDOztRQUV0QztRQUNBc0wsb0VBQWUsRUFBRSxDQUFDL25CLEtBQUssRUFBRTtNQUFDO01BQUE7UUFBQTtJQUFBO0VBQUE7QUFBQSxDQUM3QixJQUFHLEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saWdodHBhc3MyLy4uLy4uL2xpYi9oYW5kbGViYXJzLnJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9iYXNlLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2VhY2guanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2hlbHBlci1taXNzaW5nLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvaGVscGVycy9pZi5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4uLy4uLy4uLy4uL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvaGVscGVycy9sb29rdXAuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9oZWxwZXJzL3dpdGguanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9pbnRlcm5hbC9jcmVhdGUtbmV3LWxvb2t1cC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9pbnRlcm5hbC9wcm90by1hY2Nlc3MuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9pbnRlcm5hbC93cmFwSGVscGVyLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvbG9nZ2VyLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy9ydW50aW1lLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi4vLi4vLi4vbGliL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uLi8uLi8uLi9saWIvaGFuZGxlYmFycy91dGlscy5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vbm9kZV9tb2R1bGVzL3BhcGFwYXJzZS9wYXBhcGFyc2UubWluLmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi9zcmMvY29tcG9uZW50cy9jMS10YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2NvbXBvbmVudHMvYzItbmF2L2luZGV4LmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi9zcmMvY29tcG9uZW50cy9sMS1hcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL2wyLW1haW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL20wLXJhY2VyL2luZGV4LmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi9zcmMvY29tcG9uZW50cy9tMS1kYXNoYm9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL20yLXJhY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL20zLXJ1bm5lcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL200LXNjb3JlL2luZGV4LmpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi9zcmMvbGlicy9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9saWJzL2RiLW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9saWJzL2V2ZW50LXNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9saWJzL2Zvcm0tdG8tanNvbi5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2xpYnMvc3RvcmUtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2xpYnMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL2MxLXRhYmxlL3Jvdy10ZW1wbGF0ZS5oYnMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL2MxLXRhYmxlL3RlbXBsYXRlLmhicyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2NvbXBvbmVudHMvYzItbmF2L3RlbXBsYXRlLmhicyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2NvbXBvbmVudHMvbDEtYXBwL3RlbXBsYXRlLmhicyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2NvbXBvbmVudHMvbDItbWFpbi90ZW1wbGF0ZS5oYnMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL20wLXJhY2VyL3RlbXBsYXRlLmhicyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2NvbXBvbmVudHMvbTEtZGFzaGJvYXJkL3RlbXBsYXRlLmhicyIsIndlYnBhY2s6Ly9saWdodHBhc3MyLy4vc3JjL2NvbXBvbmVudHMvbTItcmFjZS90ZW1wbGF0ZS5oYnMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9jb21wb25lbnRzL20zLXJ1bm5lcnMvdGVtcGxhdGUuaGJzIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi9zcmMvY29tcG9uZW50cy9tNC1zY29yZS90ZW1wbGF0ZS5oYnMiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi8uL3NyYy9tYWluLmNzcz8yNTRmIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi9ub2RlX21vZHVsZXMvZGV4aWUvZGlzdC9tb2Rlcm4vZGV4aWUubWpzIiwid2VicGFjazovL2xpZ2h0cGFzczIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9saWdodHBhc3MyL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9saWdodHBhc3MyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vbGlnaHRwYXNzMi93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2xpZ2h0cGFzczIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9saWdodHBhc3MyL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL2xpZ2h0cGFzczIvLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmFzZSBmcm9tICcuL2hhbmRsZWJhcnMvYmFzZSc7XG5cbi8vIEVhY2ggb2YgdGhlc2UgYXVnbWVudCB0aGUgSGFuZGxlYmFycyBvYmplY3QuIE5vIG5lZWQgdG8gc2V0dXAgaGVyZS5cbi8vIChUaGlzIGlzIGRvbmUgdG8gZWFzaWx5IHNoYXJlIGNvZGUgYmV0d2VlbiBjb21tb25qcyBhbmQgYnJvd3NlIGVudnMpXG5pbXBvcnQgU2FmZVN0cmluZyBmcm9tICcuL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2hhbmRsZWJhcnMvZXhjZXB0aW9uJztcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vaGFuZGxlYmFycy91dGlscyc7XG5pbXBvcnQgKiBhcyBydW50aW1lIGZyb20gJy4vaGFuZGxlYmFycy9ydW50aW1lJztcblxuaW1wb3J0IG5vQ29uZmxpY3QgZnJvbSAnLi9oYW5kbGViYXJzL25vLWNvbmZsaWN0JztcblxuLy8gRm9yIGNvbXBhdGliaWxpdHkgYW5kIHVzYWdlIG91dHNpZGUgb2YgbW9kdWxlIHN5c3RlbXMsIG1ha2UgdGhlIEhhbmRsZWJhcnMgb2JqZWN0IGEgbmFtZXNwYWNlXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBoYiA9IG5ldyBiYXNlLkhhbmRsZWJhcnNFbnZpcm9ubWVudCgpO1xuXG4gIFV0aWxzLmV4dGVuZChoYiwgYmFzZSk7XG4gIGhiLlNhZmVTdHJpbmcgPSBTYWZlU3RyaW5nO1xuICBoYi5FeGNlcHRpb24gPSBFeGNlcHRpb247XG4gIGhiLlV0aWxzID0gVXRpbHM7XG4gIGhiLmVzY2FwZUV4cHJlc3Npb24gPSBVdGlscy5lc2NhcGVFeHByZXNzaW9uO1xuXG4gIGhiLlZNID0gcnVudGltZTtcbiAgaGIudGVtcGxhdGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHJ1bnRpbWUudGVtcGxhdGUoc3BlYywgaGIpO1xuICB9O1xuXG4gIHJldHVybiBoYjtcbn1cblxubGV0IGluc3QgPSBjcmVhdGUoKTtcbmluc3QuY3JlYXRlID0gY3JlYXRlO1xuXG5ub0NvbmZsaWN0KGluc3QpO1xuXG5pbnN0WydkZWZhdWx0J10gPSBpbnN0O1xuXG5leHBvcnQgZGVmYXVsdCBpbnN0O1xuIiwiaW1wb3J0IHsgY3JlYXRlRnJhbWUsIGV4dGVuZCwgdG9TdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHsgcmVnaXN0ZXJEZWZhdWx0SGVscGVycyB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzIH0gZnJvbSAnLi9kZWNvcmF0b3JzJztcbmltcG9ydCBsb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgcmVzZXRMb2dnZWRQcm9wZXJ0aWVzIH0gZnJvbSAnLi9pbnRlcm5hbC9wcm90by1hY2Nlc3MnO1xuXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc0LjcuNyc7XG5leHBvcnQgY29uc3QgQ09NUElMRVJfUkVWSVNJT04gPSA4O1xuZXhwb3J0IGNvbnN0IExBU1RfQ09NUEFUSUJMRV9DT01QSUxFUl9SRVZJU0lPTiA9IDc7XG5cbmV4cG9ydCBjb25zdCBSRVZJU0lPTl9DSEFOR0VTID0ge1xuICAxOiAnPD0gMS4wLnJjLjInLCAvLyAxLjAucmMuMiBpcyBhY3R1YWxseSByZXYyIGJ1dCBkb2Vzbid0IHJlcG9ydCBpdFxuICAyOiAnPT0gMS4wLjAtcmMuMycsXG4gIDM6ICc9PSAxLjAuMC1yYy40JyxcbiAgNDogJz09IDEueC54JyxcbiAgNTogJz09IDIuMC4wLWFscGhhLngnLFxuICA2OiAnPj0gMi4wLjAtYmV0YS4xJyxcbiAgNzogJz49IDQuMC4wIDw0LjMuMCcsXG4gIDg6ICc+PSA0LjMuMCdcbn07XG5cbmNvbnN0IG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZXhwb3J0IGZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xuICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzIHx8IHt9O1xuICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XG5cbiAgcmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcbiAgcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyh0aGlzKTtcbn1cblxuSGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZWJhcnNFbnZpcm9ubWVudCxcblxuICBsb2dnZXI6IGxvZ2dlcixcbiAgbG9nOiBsb2dnZXIubG9nLFxuXG4gIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7XG4gICAgICB9XG4gICAgICBleHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWxwZXJzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUsIHBhcnRpYWwpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgZXh0ZW5kKHRoaXMucGFydGlhbHMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXG4gICAgICAgICAgYEF0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGNhbGxlZCBcIiR7bmFtZX1cIiBhcyB1bmRlZmluZWRgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMucGFydGlhbHNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGRlY29yYXRvcnMnKTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xuICB9LFxuICAvKipcbiAgICogUmVzZXQgdGhlIG1lbW9yeSBvZiBpbGxlZ2FsIHByb3BlcnR5IGFjY2Vzc2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gbG9nZ2VkLlxuICAgKiBAZGVwcmVjYXRlZCBzaG91bGQgb25seSBiZSB1c2VkIGluIGhhbmRsZWJhcnMgdGVzdC1jYXNlc1xuICAgKi9cbiAgcmVzZXRMb2dnZWRQcm9wZXJ0eUFjY2Vzc2VzKCkge1xuICAgIHJlc2V0TG9nZ2VkUHJvcGVydGllcygpO1xuICB9XG59O1xuXG5leHBvcnQgbGV0IGxvZyA9IGxvZ2dlci5sb2c7XG5cbmV4cG9ydCB7IGNyZWF0ZUZyYW1lLCBsb2dnZXIgfTtcbiIsImltcG9ydCByZWdpc3RlcklubGluZSBmcm9tICcuL2RlY29yYXRvcnMvaW5saW5lJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMoaW5zdGFuY2UpIHtcbiAgcmVnaXN0ZXJJbmxpbmUoaW5zdGFuY2UpO1xufVxuIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckRlY29yYXRvcignaW5saW5lJywgZnVuY3Rpb24oZm4sIHByb3BzLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmV0ID0gZm47XG4gICAgaWYgKCFwcm9wcy5wYXJ0aWFscykge1xuICAgICAgcHJvcHMucGFydGlhbHMgPSB7fTtcbiAgICAgIHJldCA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcnRpYWxzIHN0YWNrIGZyYW1lIHByaW9yIHRvIGV4ZWMuXG4gICAgICAgIGxldCBvcmlnaW5hbCA9IGNvbnRhaW5lci5wYXJ0aWFscztcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gZXh0ZW5kKHt9LCBvcmlnaW5hbCwgcHJvcHMucGFydGlhbHMpO1xuICAgICAgICBsZXQgcmV0ID0gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9yaWdpbmFsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBwcm9wcy5wYXJ0aWFsc1tvcHRpb25zLmFyZ3NbMF1dID0gb3B0aW9ucy5mbjtcblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuIiwiY29uc3QgZXJyb3JQcm9wcyA9IFtcbiAgJ2Rlc2NyaXB0aW9uJyxcbiAgJ2ZpbGVOYW1lJyxcbiAgJ2xpbmVOdW1iZXInLFxuICAnZW5kTGluZU51bWJlcicsXG4gICdtZXNzYWdlJyxcbiAgJ25hbWUnLFxuICAnbnVtYmVyJyxcbiAgJ3N0YWNrJ1xuXTtcblxuZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UsIG5vZGUpIHtcbiAgbGV0IGxvYyA9IG5vZGUgJiYgbm9kZS5sb2MsXG4gICAgbGluZSxcbiAgICBlbmRMaW5lTnVtYmVyLFxuICAgIGNvbHVtbixcbiAgICBlbmRDb2x1bW47XG5cbiAgaWYgKGxvYykge1xuICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcbiAgICBlbmRMaW5lTnVtYmVyID0gbG9jLmVuZC5saW5lO1xuICAgIGNvbHVtbiA9IGxvYy5zdGFydC5jb2x1bW47XG4gICAgZW5kQ29sdW1uID0gbG9jLmVuZC5jb2x1bW47XG5cbiAgICBtZXNzYWdlICs9ICcgLSAnICsgbGluZSArICc6JyArIGNvbHVtbjtcbiAgfVxuXG4gIGxldCB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFeGNlcHRpb24pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAobG9jKSB7XG4gICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgdGhpcy5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjtcblxuICAgICAgLy8gV29yayBhcm91bmQgaXNzdWUgdW5kZXIgc2FmYXJpIHdoZXJlIHdlIGNhbid0IGRpcmVjdGx5IHNldCB0aGUgY29sdW1uIHZhbHVlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbHVtbicsIHtcbiAgICAgICAgICB2YWx1ZTogY29sdW1uLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZW5kQ29sdW1uJywge1xuICAgICAgICAgIHZhbHVlOiBlbmRDb2x1bW4sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKG5vcCkge1xuICAgIC8qIElnbm9yZSBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IHBhcnRpY3VsYXIgKi9cbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2VwdGlvbjtcbiIsImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUhlbHBlclRvSG9va3MoaW5zdGFuY2UsIGhlbHBlck5hbWUsIGtlZXBIZWxwZXIpIHtcbiAgaWYgKGluc3RhbmNlLmhlbHBlcnNbaGVscGVyTmFtZV0pIHtcbiAgICBpbnN0YW5jZS5ob29rc1toZWxwZXJOYW1lXSA9IGluc3RhbmNlLmhlbHBlcnNbaGVscGVyTmFtZV07XG4gICAgaWYgKCFrZWVwSGVscGVyKSB7XG4gICAgICBkZWxldGUgaW5zdGFuY2UuaGVscGVyc1toZWxwZXJOYW1lXTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGFwcGVuZENvbnRleHRQYXRoLCBjcmVhdGVGcmFtZSwgaXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgIGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZm4odGhpcyk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnMuZWFjaChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGxldCBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCxcbiAgICAgICAgICBvcHRpb25zLm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgb3B0aW9ucyA9IHsgZGF0YTogZGF0YSB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7XG4gIGFwcGVuZENvbnRleHRQYXRoLFxuICBibG9ja1BhcmFtcyxcbiAgY3JlYXRlRnJhbWUsXG4gIGlzQXJyYXksXG4gIGlzRnVuY3Rpb25cbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICBpbnZlcnNlID0gb3B0aW9ucy5pbnZlcnNlLFxuICAgICAgaSA9IDAsXG4gICAgICByZXQgPSAnJyxcbiAgICAgIGRhdGEsXG4gICAgICBjb250ZXh0UGF0aDtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgIGNvbnRleHRQYXRoID1cbiAgICAgICAgYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSkgKyAnLic7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY0l0ZXJhdGlvbihmaWVsZCwgaW5kZXgsIGxhc3QpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEua2V5ID0gZmllbGQ7XG4gICAgICAgIGRhdGEuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xuICAgICAgICBkYXRhLmxhc3QgPSAhIWxhc3Q7XG5cbiAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XG4gICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGNvbnRleHRQYXRoICsgZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID1cbiAgICAgICAgcmV0ICtcbiAgICAgICAgZm4oY29udGV4dFtmaWVsZF0sIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhcbiAgICAgICAgICAgIFtjb250ZXh0W2ZpZWxkXSwgZmllbGRdLFxuICAgICAgICAgICAgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIGlmIChpIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24oaSwgaSwgaSA9PT0gY29udGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsLlN5bWJvbCAmJiBjb250ZXh0W2dsb2JhbC5TeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBjb250ZXh0W2dsb2JhbC5TeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGZvciAobGV0IGl0ID0gaXRlcmF0b3IubmV4dCgpOyAhaXQuZG9uZTsgaXQgPSBpdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICBuZXdDb250ZXh0LnB1c2goaXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQgPSBuZXdDb250ZXh0O1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcmlvcktleTtcblxuICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyB0aGUgaXRlcmF0aW9ucyBvbmUgc3RlcCBvdXQgb2Ygc3luYyBzbyB3ZSBjYW4gZGV0ZWN0XG4gICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxuICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJpb3JLZXkgPSBrZXk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXG4gICAgICAgICdNaXNzaW5nIGhlbHBlcjogXCInICsgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXS5uYW1lICsgJ1wiJ1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgaXNFbXB0eSwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2lmJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCcjaWYgcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7XG4gICAgICBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsKSB8fCBpc0VtcHR5KGNvbmRpdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCcjdW5sZXNzIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHtcbiAgICAgIGZuOiBvcHRpb25zLmludmVyc2UsXG4gICAgICBpbnZlcnNlOiBvcHRpb25zLmZuLFxuICAgICAgaGFzaDogb3B0aW9ucy5oYXNoXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgbGV2ZWwgPSAxO1xuICAgIGlmIChvcHRpb25zLmhhc2gubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmhhc2gubGV2ZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhLmxldmVsICE9IG51bGwpIHtcbiAgICAgIGxldmVsID0gb3B0aW9ucy5kYXRhLmxldmVsO1xuICAgIH1cbiAgICBhcmdzWzBdID0gbGV2ZWw7XG5cbiAgICBpbnN0YW5jZS5sb2coLi4uYXJncyk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uKG9iaiwgZmllbGQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgLy8gTm90ZSBmb3IgNS4wOiBDaGFuZ2UgdG8gXCJvYmogPT0gbnVsbFwiIGluIDUuMFxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMubG9va3VwUHJvcGVydHkob2JqLCBmaWVsZCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtcbiAgYXBwZW5kQ29udGV4dFBhdGgsXG4gIGJsb2NrUGFyYW1zLFxuICBjcmVhdGVGcmFtZSxcbiAgaXNFbXB0eSxcbiAgaXNGdW5jdGlvblxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJyN3aXRoIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIWlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKFxuICAgICAgICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCxcbiAgICAgICAgICBvcHRpb25zLmlkc1swXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRdLCBbZGF0YSAmJiBkYXRhLmNvbnRleHRQYXRoXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscyc7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIFwibnVsbFwiLXByb3RvdHlwZSB0byBhdm9pZCB0cnV0aHkgcmVzdWx0cyBvbiBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqIFRoZSByZXN1bHRpbmcgb2JqZWN0IGNhbiBiZSB1c2VkIHdpdGggXCJvYmplY3RbcHJvcGVydHldXCIgdG8gY2hlY2sgaWYgYSBwcm9wZXJ0eSBleGlzdHNcbiAqIEBwYXJhbSB7Li4ub2JqZWN0fSBzb3VyY2VzIGEgdmFyYXJncyBwYXJhbWV0ZXIgb2Ygc291cmNlIG9iamVjdHMgdGhhdCB3aWxsIGJlIG1lcmdlZFxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5ld0xvb2t1cE9iamVjdCguLi5zb3VyY2VzKSB7XG4gIHJldHVybiBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgLi4uc291cmNlcyk7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVOZXdMb29rdXBPYmplY3QgfSBmcm9tICcuL2NyZWF0ZS1uZXctbG9va3VwLW9iamVjdCc7XG5pbXBvcnQgKiBhcyBsb2dnZXIgZnJvbSAnLi4vbG9nZ2VyJztcblxuY29uc3QgbG9nZ2VkUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm90b0FjY2Vzc0NvbnRyb2wocnVudGltZU9wdGlvbnMpIHtcbiAgbGV0IGRlZmF1bHRNZXRob2RXaGl0ZUxpc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBkZWZhdWx0TWV0aG9kV2hpdGVMaXN0Wydjb25zdHJ1Y3RvciddID0gZmFsc2U7XG4gIGRlZmF1bHRNZXRob2RXaGl0ZUxpc3RbJ19fZGVmaW5lR2V0dGVyX18nXSA9IGZhbHNlO1xuICBkZWZhdWx0TWV0aG9kV2hpdGVMaXN0WydfX2RlZmluZVNldHRlcl9fJ10gPSBmYWxzZTtcbiAgZGVmYXVsdE1ldGhvZFdoaXRlTGlzdFsnX19sb29rdXBHZXR0ZXJfXyddID0gZmFsc2U7XG5cbiAgbGV0IGRlZmF1bHRQcm9wZXJ0eVdoaXRlTGlzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b1xuICBkZWZhdWx0UHJvcGVydHlXaGl0ZUxpc3RbJ19fcHJvdG9fXyddID0gZmFsc2U7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICB3aGl0ZWxpc3Q6IGNyZWF0ZU5ld0xvb2t1cE9iamVjdChcbiAgICAgICAgZGVmYXVsdFByb3BlcnR5V2hpdGVMaXN0LFxuICAgICAgICBydW50aW1lT3B0aW9ucy5hbGxvd2VkUHJvdG9Qcm9wZXJ0aWVzXG4gICAgICApLFxuICAgICAgZGVmYXVsdFZhbHVlOiBydW50aW1lT3B0aW9ucy5hbGxvd1Byb3RvUHJvcGVydGllc0J5RGVmYXVsdFxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgd2hpdGVsaXN0OiBjcmVhdGVOZXdMb29rdXBPYmplY3QoXG4gICAgICAgIGRlZmF1bHRNZXRob2RXaGl0ZUxpc3QsXG4gICAgICAgIHJ1bnRpbWVPcHRpb25zLmFsbG93ZWRQcm90b01ldGhvZHNcbiAgICAgICksXG4gICAgICBkZWZhdWx0VmFsdWU6IHJ1bnRpbWVPcHRpb25zLmFsbG93UHJvdG9NZXRob2RzQnlEZWZhdWx0XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdWx0SXNBbGxvd2VkKHJlc3VsdCwgcHJvdG9BY2Nlc3NDb250cm9sLCBwcm9wZXJ0eU5hbWUpIHtcbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2hlY2tXaGl0ZUxpc3QocHJvdG9BY2Nlc3NDb250cm9sLm1ldGhvZHMsIHByb3BlcnR5TmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNoZWNrV2hpdGVMaXN0KHByb3RvQWNjZXNzQ29udHJvbC5wcm9wZXJ0aWVzLCBwcm9wZXJ0eU5hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrV2hpdGVMaXN0KHByb3RvQWNjZXNzQ29udHJvbEZvclR5cGUsIHByb3BlcnR5TmFtZSkge1xuICBpZiAocHJvdG9BY2Nlc3NDb250cm9sRm9yVHlwZS53aGl0ZWxpc3RbcHJvcGVydHlOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb3RvQWNjZXNzQ29udHJvbEZvclR5cGUud2hpdGVsaXN0W3Byb3BlcnR5TmFtZV0gPT09IHRydWU7XG4gIH1cbiAgaWYgKHByb3RvQWNjZXNzQ29udHJvbEZvclR5cGUuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvdG9BY2Nlc3NDb250cm9sRm9yVHlwZS5kZWZhdWx0VmFsdWU7XG4gIH1cbiAgbG9nVW5leHBlY2VkUHJvcGVydHlBY2Nlc3NPbmNlKHByb3BlcnR5TmFtZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbG9nVW5leHBlY2VkUHJvcGVydHlBY2Nlc3NPbmNlKHByb3BlcnR5TmFtZSkge1xuICBpZiAobG9nZ2VkUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdICE9PSB0cnVlKSB7XG4gICAgbG9nZ2VkUHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gdHJ1ZTtcbiAgICBsb2dnZXIubG9nKFxuICAgICAgJ2Vycm9yJyxcbiAgICAgIGBIYW5kbGViYXJzOiBBY2Nlc3MgaGFzIGJlZW4gZGVuaWVkIHRvIHJlc29sdmUgdGhlIHByb3BlcnR5IFwiJHtwcm9wZXJ0eU5hbWV9XCIgYmVjYXVzZSBpdCBpcyBub3QgYW4gXCJvd24gcHJvcGVydHlcIiBvZiBpdHMgcGFyZW50LlxcbmAgK1xuICAgICAgICBgWW91IGNhbiBhZGQgYSBydW50aW1lIG9wdGlvbiB0byBkaXNhYmxlIHRoZSBjaGVjayBvciB0aGlzIHdhcm5pbmc6XFxuYCArXG4gICAgICAgIGBTZWUgaHR0cHM6Ly9oYW5kbGViYXJzanMuY29tL2FwaS1yZWZlcmVuY2UvcnVudGltZS1vcHRpb25zLmh0bWwjb3B0aW9ucy10by1jb250cm9sLXByb3RvdHlwZS1hY2Nlc3MgZm9yIGRldGFpbHNgXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRMb2dnZWRQcm9wZXJ0aWVzKCkge1xuICBPYmplY3Qua2V5cyhsb2dnZWRQcm9wZXJ0aWVzKS5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgZGVsZXRlIGxvZ2dlZFByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gd3JhcEhlbHBlcihoZWxwZXIsIHRyYW5zZm9ybU9wdGlvbnNGbikge1xuICBpZiAodHlwZW9mIGhlbHBlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCBhcHBhcmVudGx5IGl0IGRvZXMgaW4gaHR0cHM6Ly9naXRodWIuY29tL3d5Y2F0cy9oYW5kbGViYXJzLmpzL2lzc3Vlcy8xNjM5XG4gICAgLy8gV2UgdHJ5IHRvIG1ha2UgdGhlIHdyYXBwZXIgbGVhc3QtaW52YXNpdmUgYnkgbm90IHdyYXBwaW5nIGl0LCBpZiB0aGUgaGVscGVyIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICAgIHJldHVybiBoZWxwZXI7XG4gIH1cbiAgbGV0IHdyYXBwZXIgPSBmdW5jdGlvbigvKiBkeW5hbWljIGFyZ3VtZW50cyAqLykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0gPSB0cmFuc2Zvcm1PcHRpb25zRm4ob3B0aW9ucyk7XG4gICAgcmV0dXJuIGhlbHBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbiIsImltcG9ydCB7IGluZGV4T2YgfSBmcm9tICcuL3V0aWxzJztcblxubGV0IGxvZ2dlciA9IHtcbiAgbWV0aG9kTWFwOiBbJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsICdlcnJvciddLFxuICBsZXZlbDogJ2luZm8nLFxuXG4gIC8vIE1hcHMgYSBnaXZlbiBsZXZlbCB2YWx1ZSB0byB0aGUgYG1ldGhvZE1hcGAgaW5kZXhlcyBhYm92ZS5cbiAgbG9va3VwTGV2ZWw6IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBsZXZlbE1hcCA9IGluZGV4T2YobG9nZ2VyLm1ldGhvZE1hcCwgbGV2ZWwudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAobGV2ZWxNYXAgPj0gMCkge1xuICAgICAgICBsZXZlbCA9IGxldmVsTWFwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWwgPSBwYXJzZUludChsZXZlbCwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsZXZlbDtcbiAgfSxcblxuICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudFxuICBsb2c6IGZ1bmN0aW9uKGxldmVsLCAuLi5tZXNzYWdlKSB7XG4gICAgbGV2ZWwgPSBsb2dnZXIubG9va3VwTGV2ZWwobGV2ZWwpO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBsb2dnZXIubG9va3VwTGV2ZWwobG9nZ2VyLmxldmVsKSA8PSBsZXZlbFxuICAgICkge1xuICAgICAgbGV0IG1ldGhvZCA9IGxvZ2dlci5tZXRob2RNYXBbbGV2ZWxdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7XG4gICAgICAgIG1ldGhvZCA9ICdsb2cnO1xuICAgICAgfVxuICAgICAgY29uc29sZVttZXRob2RdKC4uLm1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2dlcjtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKEhhbmRsZWJhcnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbGV0IHJvb3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcbiAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgSGFuZGxlYmFycy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJvb3QuSGFuZGxlYmFycyA9PT0gSGFuZGxlYmFycykge1xuICAgICAgcm9vdC5IYW5kbGViYXJzID0gJEhhbmRsZWJhcnM7XG4gICAgfVxuICAgIHJldHVybiBIYW5kbGViYXJzO1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vZXhjZXB0aW9uJztcbmltcG9ydCB7XG4gIENPTVBJTEVSX1JFVklTSU9OLFxuICBjcmVhdGVGcmFtZSxcbiAgTEFTVF9DT01QQVRJQkxFX0NPTVBJTEVSX1JFVklTSU9OLFxuICBSRVZJU0lPTl9DSEFOR0VTXG59IGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBtb3ZlSGVscGVyVG9Ib29rcyB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyB3cmFwSGVscGVyIH0gZnJvbSAnLi9pbnRlcm5hbC93cmFwSGVscGVyJztcbmltcG9ydCB7XG4gIGNyZWF0ZVByb3RvQWNjZXNzQ29udHJvbCxcbiAgcmVzdWx0SXNBbGxvd2VkXG59IGZyb20gJy4vaW50ZXJuYWwvcHJvdG8tYWNjZXNzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmV2aXNpb24oY29tcGlsZXJJbmZvKSB7XG4gIGNvbnN0IGNvbXBpbGVyUmV2aXNpb24gPSAoY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSkgfHwgMSxcbiAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICBpZiAoXG4gICAgY29tcGlsZXJSZXZpc2lvbiA+PSBMQVNUX0NPTVBBVElCTEVfQ09NUElMRVJfUkVWSVNJT04gJiZcbiAgICBjb21waWxlclJldmlzaW9uIDw9IENPTVBJTEVSX1JFVklTSU9OXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb21waWxlclJldmlzaW9uIDwgTEFTVF9DT01QQVRJQkxFX0NPTVBJTEVSX1JFVklTSU9OKSB7XG4gICAgY29uc3QgcnVudGltZVZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjdXJyZW50UmV2aXNpb25dLFxuICAgICAgY29tcGlsZXJWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY29tcGlsZXJSZXZpc2lvbl07XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcbiAgICAgICdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICtcbiAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKCcgK1xuICAgICAgICBydW50aW1lVmVyc2lvbnMgK1xuICAgICAgICAnKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKCcgK1xuICAgICAgICBjb21waWxlclZlcnNpb25zICtcbiAgICAgICAgJykuJ1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcbiAgICAgICdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uICgnICtcbiAgICAgICAgY29tcGlsZXJJbmZvWzFdICtcbiAgICAgICAgJykuJ1xuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHRlbXBsYXRlU3BlYywgZW52KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghZW52KSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlJyk7XG4gIH1cbiAgaWYgKCF0ZW1wbGF0ZVNwZWMgfHwgIXRlbXBsYXRlU3BlYy5tYWluKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVW5rbm93biB0ZW1wbGF0ZSBvYmplY3Q6ICcgKyB0eXBlb2YgdGVtcGxhdGVTcGVjKTtcbiAgfVxuXG4gIHRlbXBsYXRlU3BlYy5tYWluLmRlY29yYXRvciA9IHRlbXBsYXRlU3BlYy5tYWluX2Q7XG5cbiAgLy8gTm90ZTogVXNpbmcgZW52LlZNIHJlZmVyZW5jZXMgcmF0aGVyIHRoYW4gbG9jYWwgdmFyIHJlZmVyZW5jZXMgdGhyb3VnaG91dCB0aGlzIHNlY3Rpb24gdG8gYWxsb3dcbiAgLy8gZm9yIGV4dGVybmFsIHVzZXJzIHRvIG92ZXJyaWRlIHRoZXNlIGFzIHBzZXVkby1zdXBwb3J0ZWQgQVBJcy5cbiAgZW52LlZNLmNoZWNrUmV2aXNpb24odGVtcGxhdGVTcGVjLmNvbXBpbGVyKTtcblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgcHJlY29tcGlsZWQgdGVtcGxhdGVzIHdpdGggY29tcGlsZXItdmVyc2lvbiA3ICg8NC4zLjApXG4gIGNvbnN0IHRlbXBsYXRlV2FzUHJlY29tcGlsZWRXaXRoQ29tcGlsZXJWNyA9XG4gICAgdGVtcGxhdGVTcGVjLmNvbXBpbGVyICYmIHRlbXBsYXRlU3BlYy5jb21waWxlclswXSA9PT0gNztcblxuICBmdW5jdGlvbiBpbnZva2VQYXJ0aWFsV3JhcHBlcihwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgICAgY29udGV4dCA9IFV0aWxzLmV4dGVuZCh7fSwgY29udGV4dCwgb3B0aW9ucy5oYXNoKTtcbiAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICBvcHRpb25zLmlkc1swXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIGxldCBleHRlbmRlZE9wdGlvbnMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGhvb2tzOiB0aGlzLmhvb2tzLFxuICAgICAgcHJvdG9BY2Nlc3NDb250cm9sOiB0aGlzLnByb3RvQWNjZXNzQ29udHJvbFxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgcGFydGlhbCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBleHRlbmRlZE9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIGVudi5jb21waWxlKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0gPSBlbnYuY29tcGlsZShcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucyxcbiAgICAgICAgZW52XG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdKGNvbnRleHQsIGV4dGVuZGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsaW5lc1tpXSAmJiBpICsgMSA9PT0gbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXNbaV0gPSBvcHRpb25zLmluZGVudCArIGxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcbiAgICAgICAgJ1RoZSBwYXJ0aWFsICcgK1xuICAgICAgICAgIG9wdGlvbnMubmFtZSArXG4gICAgICAgICAgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBKdXN0IGFkZCB3YXRlclxuICBsZXQgY29udGFpbmVyID0ge1xuICAgIHN0cmljdDogZnVuY3Rpb24ob2JqLCBuYW1lLCBsb2MpIHtcbiAgICAgIGlmICghb2JqIHx8ICEobmFtZSBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1wiJyArIG5hbWUgKyAnXCIgbm90IGRlZmluZWQgaW4gJyArIG9iaiwge1xuICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lci5sb29rdXBQcm9wZXJ0eShvYmosIG5hbWUpO1xuICAgIH0sXG4gICAgbG9va3VwUHJvcGVydHk6IGZ1bmN0aW9uKHBhcmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyZW50W3Byb3BlcnR5TmFtZV07XG4gICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyZW50LCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHRJc0FsbG93ZWQocmVzdWx0LCBjb250YWluZXIucHJvdG9BY2Nlc3NDb250cm9sLCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgbG9va3VwOiBmdW5jdGlvbihkZXB0aHMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBkZXB0aHNbaV0gJiYgY29udGFpbmVyLmxvb2t1cFByb3BlcnR5KGRlcHRoc1tpXSwgbmFtZSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBkZXB0aHNbaV1bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhbWJkYTogZnVuY3Rpb24oY3VycmVudCwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50ID09PSAnZnVuY3Rpb24nID8gY3VycmVudC5jYWxsKGNvbnRleHQpIDogY3VycmVudDtcbiAgICB9LFxuXG4gICAgZXNjYXBlRXhwcmVzc2lvbjogVXRpbHMuZXNjYXBlRXhwcmVzc2lvbixcbiAgICBpbnZva2VQYXJ0aWFsOiBpbnZva2VQYXJ0aWFsV3JhcHBlcixcblxuICAgIGZuOiBmdW5jdGlvbihpKSB7XG4gICAgICBsZXQgcmV0ID0gdGVtcGxhdGVTcGVjW2ldO1xuICAgICAgcmV0LmRlY29yYXRvciA9IHRlbXBsYXRlU3BlY1tpICsgJ19kJ107XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBwcm9ncmFtczogW10sXG4gICAgcHJvZ3JhbTogZnVuY3Rpb24oaSwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgICAgbGV0IHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSxcbiAgICAgICAgZm4gPSB0aGlzLmZuKGkpO1xuICAgICAgaWYgKGRhdGEgfHwgZGVwdGhzIHx8IGJsb2NrUGFyYW1zIHx8IGRlY2xhcmVkQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB3cmFwUHJvZ3JhbShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgZm4sXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZWNsYXJlZEJsb2NrUGFyYW1zLFxuICAgICAgICAgIGJsb2NrUGFyYW1zLFxuICAgICAgICAgIGRlcHRoc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyYW1XcmFwcGVyO1xuICAgIH0sXG5cbiAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlSWZOZWVkZWQ6IGZ1bmN0aW9uKHBhcmFtLCBjb21tb24pIHtcbiAgICAgIGxldCBvYmogPSBwYXJhbSB8fCBjb21tb247XG5cbiAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgcGFyYW0gIT09IGNvbW1vbikge1xuICAgICAgICBvYmogPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgLy8gQW4gZW1wdHkgb2JqZWN0IHRvIHVzZSBhcyByZXBsYWNlbWVudCBmb3IgbnVsbC1jb250ZXh0c1xuICAgIG51bGxDb250ZXh0OiBPYmplY3Quc2VhbCh7fSksXG5cbiAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxuICB9O1xuXG4gIGZ1bmN0aW9uIHJldChjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIHJldC5fc2V0dXAob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgbGV0IGRlcHRocyxcbiAgICAgIGJsb2NrUGFyYW1zID0gdGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zID8gW10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMpIHtcbiAgICAgIGlmIChvcHRpb25zLmRlcHRocykge1xuICAgICAgICBkZXB0aHMgPVxuICAgICAgICAgIGNvbnRleHQgIT0gb3B0aW9ucy5kZXB0aHNbMF1cbiAgICAgICAgICAgID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocylcbiAgICAgICAgICAgIDogb3B0aW9ucy5kZXB0aHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aHMgPSBbY29udGV4dF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFpbihjb250ZXh0IC8qLCBvcHRpb25zKi8pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICcnICtcbiAgICAgICAgdGVtcGxhdGVTcGVjLm1haW4oXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgY29udGFpbmVyLmhlbHBlcnMsXG4gICAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgYmxvY2tQYXJhbXMsXG4gICAgICAgICAgZGVwdGhzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbWFpbiA9IGV4ZWN1dGVEZWNvcmF0b3JzKFxuICAgICAgdGVtcGxhdGVTcGVjLm1haW4sXG4gICAgICBtYWluLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgb3B0aW9ucy5kZXB0aHMgfHwgW10sXG4gICAgICBkYXRhLFxuICAgICAgYmxvY2tQYXJhbXNcbiAgICApO1xuICAgIHJldHVybiBtYWluKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0LmlzVG9wID0gdHJ1ZTtcblxuICByZXQuX3NldHVwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsKSB7XG4gICAgICBsZXQgbWVyZ2VkSGVscGVycyA9IFV0aWxzLmV4dGVuZCh7fSwgZW52LmhlbHBlcnMsIG9wdGlvbnMuaGVscGVycyk7XG4gICAgICB3cmFwSGVscGVyc1RvUGFzc0xvb2t1cFByb3BlcnR5KG1lcmdlZEhlbHBlcnMsIGNvbnRhaW5lcik7XG4gICAgICBjb250YWluZXIuaGVscGVycyA9IG1lcmdlZEhlbHBlcnM7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xuICAgICAgICAvLyBVc2UgbWVyZ2VJZk5lZWRlZCBoZXJlIHRvIHByZXZlbnQgY29tcGlsaW5nIGdsb2JhbCBwYXJ0aWFscyBtdWx0aXBsZSB0aW1lc1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2VJZk5lZWRlZChcbiAgICAgICAgICBvcHRpb25zLnBhcnRpYWxzLFxuICAgICAgICAgIGVudi5wYXJ0aWFsc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsIHx8IHRlbXBsYXRlU3BlYy51c2VEZWNvcmF0b3JzKSB7XG4gICAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gVXRpbHMuZXh0ZW5kKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIGVudi5kZWNvcmF0b3JzLFxuICAgICAgICAgIG9wdGlvbnMuZGVjb3JhdG9yc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb250YWluZXIuaG9va3MgPSB7fTtcbiAgICAgIGNvbnRhaW5lci5wcm90b0FjY2Vzc0NvbnRyb2wgPSBjcmVhdGVQcm90b0FjY2Vzc0NvbnRyb2wob3B0aW9ucyk7XG5cbiAgICAgIGxldCBrZWVwSGVscGVySW5IZWxwZXJzID1cbiAgICAgICAgb3B0aW9ucy5hbGxvd0NhbGxzVG9IZWxwZXJNaXNzaW5nIHx8XG4gICAgICAgIHRlbXBsYXRlV2FzUHJlY29tcGlsZWRXaXRoQ29tcGlsZXJWNztcbiAgICAgIG1vdmVIZWxwZXJUb0hvb2tzKGNvbnRhaW5lciwgJ2hlbHBlck1pc3NpbmcnLCBrZWVwSGVscGVySW5IZWxwZXJzKTtcbiAgICAgIG1vdmVIZWxwZXJUb0hvb2tzKGNvbnRhaW5lciwgJ2Jsb2NrSGVscGVyTWlzc2luZycsIGtlZXBIZWxwZXJJbkhlbHBlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIucHJvdG9BY2Nlc3NDb250cm9sID0gb3B0aW9ucy5wcm90b0FjY2Vzc0NvbnRyb2w7IC8vIGludGVybmFsIG9wdGlvblxuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBvcHRpb25zLmRlY29yYXRvcnM7XG4gICAgICBjb250YWluZXIuaG9va3MgPSBvcHRpb25zLmhvb2tzO1xuICAgIH1cbiAgfTtcblxuICByZXQuX2NoaWxkID0gZnVuY3Rpb24oaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgJiYgIWJsb2NrUGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdtdXN0IHBhc3MgYmxvY2sgcGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBQcm9ncmFtKFxuICAgICAgY29udGFpbmVyLFxuICAgICAgaSxcbiAgICAgIHRlbXBsYXRlU3BlY1tpXSxcbiAgICAgIGRhdGEsXG4gICAgICAwLFxuICAgICAgYmxvY2tQYXJhbXMsXG4gICAgICBkZXB0aHNcbiAgICApO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFByb2dyYW0oXG4gIGNvbnRhaW5lcixcbiAgaSxcbiAgZm4sXG4gIGRhdGEsXG4gIGRlY2xhcmVkQmxvY2tQYXJhbXMsXG4gIGJsb2NrUGFyYW1zLFxuICBkZXB0aHNcbikge1xuICBmdW5jdGlvbiBwcm9nKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xuICAgIGlmIChcbiAgICAgIGRlcHRocyAmJlxuICAgICAgY29udGV4dCAhPSBkZXB0aHNbMF0gJiZcbiAgICAgICEoY29udGV4dCA9PT0gY29udGFpbmVyLm51bGxDb250ZXh0ICYmIGRlcHRoc1swXSA9PT0gbnVsbClcbiAgICApIHtcbiAgICAgIGN1cnJlbnREZXB0aHMgPSBbY29udGV4dF0uY29uY2F0KGRlcHRocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKFxuICAgICAgY29udGFpbmVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzLFxuICAgICAgY29udGFpbmVyLnBhcnRpYWxzLFxuICAgICAgb3B0aW9ucy5kYXRhIHx8IGRhdGEsXG4gICAgICBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSxcbiAgICAgIGN1cnJlbnREZXB0aHNcbiAgICApO1xuICB9XG5cbiAgcHJvZyA9IGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpO1xuXG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSBkZXB0aHMgPyBkZXB0aHMubGVuZ3RoIDogMDtcbiAgcHJvZy5ibG9ja1BhcmFtcyA9IGRlY2xhcmVkQmxvY2tQYXJhbXMgfHwgMDtcbiAgcmV0dXJuIHByb2c7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjdXJyZW50bHkgcGFydCBvZiB0aGUgb2ZmaWNpYWwgQVBJLCB0aGVyZWZvcmUgaW1wbGVtZW50YXRpb24gZGV0YWlscyBzaG91bGQgbm90IGJlIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmICghcGFydGlhbCkge1xuICAgIGlmIChvcHRpb25zLm5hbWUgPT09ICdAcGFydGlhbC1ibG9jaycpIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXBhcnRpYWwuY2FsbCAmJiAhb3B0aW9ucy5uYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGR5bmFtaWMgcGFydGlhbCB0aGF0IHJldHVybmVkIGEgc3RyaW5nXG4gICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcbiAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1twYXJ0aWFsXTtcbiAgfVxuICByZXR1cm4gcGFydGlhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBVc2UgdGhlIGN1cnJlbnQgY2xvc3VyZSBjb250ZXh0IHRvIHNhdmUgdGhlIHBhcnRpYWwtYmxvY2sgaWYgdGhpcyBwYXJ0aWFsXG4gIGNvbnN0IGN1cnJlbnRQYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ107XG4gIG9wdGlvbnMucGFydGlhbCA9IHRydWU7XG4gIGlmIChvcHRpb25zLmlkcykge1xuICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCA9IG9wdGlvbnMuaWRzWzBdIHx8IG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aDtcbiAgfVxuXG4gIGxldCBwYXJ0aWFsQmxvY2s7XG4gIGlmIChvcHRpb25zLmZuICYmIG9wdGlvbnMuZm4gIT09IG5vb3ApIHtcbiAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIC8vIFdyYXBwZXIgZnVuY3Rpb24gdG8gZ2V0IGFjY2VzcyB0byBjdXJyZW50UGFydGlhbEJsb2NrIGZyb20gdGhlIGNsb3N1cmVcbiAgICBsZXQgZm4gPSBvcHRpb25zLmZuO1xuICAgIHBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gZnVuY3Rpb24gcGFydGlhbEJsb2NrV3JhcHBlcihcbiAgICAgIGNvbnRleHQsXG4gICAgICBvcHRpb25zID0ge31cbiAgICApIHtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIHBhcnRpYWwtYmxvY2sgZnJvbSB0aGUgY2xvc3VyZSBmb3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgYmxvY2tcbiAgICAgIC8vIGkuZS4gdGhlIHBhcnQgaW5zaWRlIHRoZSBibG9jayBvZiB0aGUgcGFydGlhbCBjYWxsLlxuICAgICAgb3B0aW9ucy5kYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgIG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gY3VycmVudFBhcnRpYWxCbG9jaztcbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmIChmbi5wYXJ0aWFscykge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFscyA9IFV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucy5wYXJ0aWFscywgZm4ucGFydGlhbHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQgJiYgcGFydGlhbEJsb2NrKSB7XG4gICAgcGFydGlhbCA9IHBhcnRpYWxCbG9jaztcbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgfSBlbHNlIGlmIChwYXJ0aWFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YShjb250ZXh0LCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhKCdyb290JyBpbiBkYXRhKSkge1xuICAgIGRhdGEgPSBkYXRhID8gY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcbiAgICBkYXRhLnJvb3QgPSBjb250ZXh0O1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKSB7XG4gIGlmIChmbi5kZWNvcmF0b3IpIHtcbiAgICBsZXQgcHJvcHMgPSB7fTtcbiAgICBwcm9nID0gZm4uZGVjb3JhdG9yKFxuICAgICAgcHJvZyxcbiAgICAgIHByb3BzLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgZGVwdGhzICYmIGRlcHRoc1swXSxcbiAgICAgIGRhdGEsXG4gICAgICBibG9ja1BhcmFtcyxcbiAgICAgIGRlcHRoc1xuICAgICk7XG4gICAgVXRpbHMuZXh0ZW5kKHByb2csIHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvZztcbn1cblxuZnVuY3Rpb24gd3JhcEhlbHBlcnNUb1Bhc3NMb29rdXBQcm9wZXJ0eShtZXJnZWRIZWxwZXJzLCBjb250YWluZXIpIHtcbiAgT2JqZWN0LmtleXMobWVyZ2VkSGVscGVycykuZm9yRWFjaChoZWxwZXJOYW1lID0+IHtcbiAgICBsZXQgaGVscGVyID0gbWVyZ2VkSGVscGVyc1toZWxwZXJOYW1lXTtcbiAgICBtZXJnZWRIZWxwZXJzW2hlbHBlck5hbWVdID0gcGFzc0xvb2t1cFByb3BlcnR5T3B0aW9uKGhlbHBlciwgY29udGFpbmVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhc3NMb29rdXBQcm9wZXJ0eU9wdGlvbihoZWxwZXIsIGNvbnRhaW5lcikge1xuICBjb25zdCBsb29rdXBQcm9wZXJ0eSA9IGNvbnRhaW5lci5sb29rdXBQcm9wZXJ0eTtcbiAgcmV0dXJuIHdyYXBIZWxwZXIoaGVscGVyLCBvcHRpb25zID0+IHtcbiAgICByZXR1cm4gVXRpbHMuZXh0ZW5kKHsgbG9va3VwUHJvcGVydHkgfSwgb3B0aW9ucyk7XG4gIH0pO1xufVxuIiwiLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbmZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IFNhZmVTdHJpbmcucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJycgKyB0aGlzLnN0cmluZztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNhZmVTdHJpbmc7XG4iLCJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gIHBvc3NpYmxlID0gL1smPD5cIidgPV0vO1xuXG5mdW5jdGlvbiBlc2NhcGVDaGFyKGNocikge1xuICByZXR1cm4gZXNjYXBlW2Nocl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQob2JqIC8qICwgLi4uc291cmNlICovKSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgbGV0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xubGV0IGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcbi8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICApO1xuICB9O1xufVxuZXhwb3J0IHsgaXNGdW5jdGlvbiB9O1xuLyogZXNsaW50LWVuYWJsZSBmdW5jLXN0eWxlICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNBcnJheSA9XG4gIEFycmF5LmlzQXJyYXkgfHxcbiAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgICAgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuLy8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhbWUob2JqZWN0KSB7XG4gIGxldCBmcmFtZSA9IGV4dGVuZCh7fSwgb2JqZWN0KTtcbiAgZnJhbWUuX3BhcmVudCA9IG9iamVjdDtcbiAgcmV0dXJuIGZyYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvY2tQYXJhbXMocGFyYW1zLCBpZHMpIHtcbiAgcGFyYW1zLnBhdGggPSBpZHM7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcbiAgcmV0dXJuIChjb250ZXh0UGF0aCA/IGNvbnRleHRQYXRoICsgJy4nIDogJycpICsgaWQ7XG59XG4iLCIvLyBDcmVhdGUgYSBzaW1wbGUgcGF0aCBhbGlhcyB0byBhbGxvdyBicm93c2VyaWZ5IHRvIHJlc29sdmVcbi8vIHRoZSBydW50aW1lIG9uIGEgc3VwcG9ydGVkIHBhdGguXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9janMvaGFuZGxlYmFycy5ydW50aW1lJylbJ2RlZmF1bHQnXTtcbiIsIi8qIEBsaWNlbnNlXG5QYXBhIFBhcnNlXG52NS4zLjJcbmh0dHBzOi8vZ2l0aHViLmNvbS9taG9sdC9QYXBhUGFyc2VcbkxpY2Vuc2U6IE1JVFxuKi9cbiFmdW5jdGlvbihlLHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9dCgpOmUuUGFwYT10KCl9KHRoaXMsZnVuY3Rpb24gcygpe1widXNlIHN0cmljdFwiO3ZhciBmPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dm9pZCAwIT09Zj9mOnt9O3ZhciBuPSFmLmRvY3VtZW50JiYhIWYucG9zdE1lc3NhZ2Usbz1uJiYvYmxvYjovaS50ZXN0KChmLmxvY2F0aW9ufHx7fSkucHJvdG9jb2wpLGE9e30saD0wLGI9e3BhcnNlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9KHQ9dHx8e30pLmR5bmFtaWNUeXBpbmd8fCExO00oaSkmJih0LmR5bmFtaWNUeXBpbmdGdW5jdGlvbj1pLGk9e30pO2lmKHQuZHluYW1pY1R5cGluZz1pLHQudHJhbnNmb3JtPSEhTSh0LnRyYW5zZm9ybSkmJnQudHJhbnNmb3JtLHQud29ya2VyJiZiLldPUktFUlNfU1VQUE9SVEVEKXt2YXIgcj1mdW5jdGlvbigpe2lmKCFiLldPUktFUlNfU1VQUE9SVEVEKXJldHVybiExO3ZhciBlPShpPWYuVVJMfHxmLndlYmtpdFVSTHx8bnVsbCxyPXMudG9TdHJpbmcoKSxiLkJMT0JfVVJMfHwoYi5CTE9CX1VSTD1pLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXCIoXCIscixcIikoKTtcIl0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKSkpLHQ9bmV3IGYuV29ya2VyKGUpO3ZhciBpLHI7cmV0dXJuIHQub25tZXNzYWdlPV8sdC5pZD1oKyssYVt0LmlkXT10fSgpO3JldHVybiByLnVzZXJTdGVwPXQuc3RlcCxyLnVzZXJDaHVuaz10LmNodW5rLHIudXNlckNvbXBsZXRlPXQuY29tcGxldGUsci51c2VyRXJyb3I9dC5lcnJvcix0LnN0ZXA9TSh0LnN0ZXApLHQuY2h1bms9TSh0LmNodW5rKSx0LmNvbXBsZXRlPU0odC5jb21wbGV0ZSksdC5lcnJvcj1NKHQuZXJyb3IpLGRlbGV0ZSB0Lndvcmtlcix2b2lkIHIucG9zdE1lc3NhZ2Uoe2lucHV0OmUsY29uZmlnOnQsd29ya2VySWQ6ci5pZH0pfXZhciBuPW51bGw7Yi5OT0RFX1NUUkVBTV9JTlBVVCxcInN0cmluZ1wiPT10eXBlb2YgZT9uPXQuZG93bmxvYWQ/bmV3IGwodCk6bmV3IHAodCk6ITA9PT1lLnJlYWRhYmxlJiZNKGUucmVhZCkmJk0oZS5vbik/bj1uZXcgZyh0KTooZi5GaWxlJiZlIGluc3RhbmNlb2YgRmlsZXx8ZSBpbnN0YW5jZW9mIE9iamVjdCkmJihuPW5ldyBjKHQpKTtyZXR1cm4gbi5zdHJlYW0oZSl9LHVucGFyc2U6ZnVuY3Rpb24oZSx0KXt2YXIgbj0hMSxfPSEwLG09XCIsXCIseT1cIlxcclxcblwiLHM9J1wiJyxhPXMrcyxpPSExLHI9bnVsbCxvPSExOyFmdW5jdGlvbigpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXJldHVybjtcInN0cmluZ1wiIT10eXBlb2YgdC5kZWxpbWl0ZXJ8fGIuQkFEX0RFTElNSVRFUlMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybi0xIT09dC5kZWxpbWl0ZXIuaW5kZXhPZihlKX0pLmxlbmd0aHx8KG09dC5kZWxpbWl0ZXIpOyhcImJvb2xlYW5cIj09dHlwZW9mIHQucXVvdGVzfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnF1b3Rlc3x8QXJyYXkuaXNBcnJheSh0LnF1b3RlcykpJiYobj10LnF1b3Rlcyk7XCJib29sZWFuXCIhPXR5cGVvZiB0LnNraXBFbXB0eUxpbmVzJiZcInN0cmluZ1wiIT10eXBlb2YgdC5za2lwRW1wdHlMaW5lc3x8KGk9dC5za2lwRW1wdHlMaW5lcyk7XCJzdHJpbmdcIj09dHlwZW9mIHQubmV3bGluZSYmKHk9dC5uZXdsaW5lKTtcInN0cmluZ1wiPT10eXBlb2YgdC5xdW90ZUNoYXImJihzPXQucXVvdGVDaGFyKTtcImJvb2xlYW5cIj09dHlwZW9mIHQuaGVhZGVyJiYoXz10LmhlYWRlcik7aWYoQXJyYXkuaXNBcnJheSh0LmNvbHVtbnMpKXtpZigwPT09dC5jb2x1bW5zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gY29sdW1ucyBpcyBlbXB0eVwiKTtyPXQuY29sdW1uc312b2lkIDAhPT10LmVzY2FwZUNoYXImJihhPXQuZXNjYXBlQ2hhcitzKTsoXCJib29sZWFuXCI9PXR5cGVvZiB0LmVzY2FwZUZvcm11bGFlfHx0LmVzY2FwZUZvcm11bGFlIGluc3RhbmNlb2YgUmVnRXhwKSYmKG89dC5lc2NhcGVGb3JtdWxhZSBpbnN0YW5jZW9mIFJlZ0V4cD90LmVzY2FwZUZvcm11bGFlOi9eWz0rXFwtQFxcdFxccl0uKiQvKX0oKTt2YXIgaD1uZXcgUmVnRXhwKGoocyksXCJnXCIpO1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1KU09OLnBhcnNlKGUpKTtpZihBcnJheS5pc0FycmF5KGUpKXtpZighZS5sZW5ndGh8fEFycmF5LmlzQXJyYXkoZVswXSkpcmV0dXJuIHUobnVsbCxlLGkpO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlWzBdKXJldHVybiB1KHJ8fE9iamVjdC5rZXlzKGVbMF0pLGUsaSl9ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZS5kYXRhJiYoZS5kYXRhPUpTT04ucGFyc2UoZS5kYXRhKSksQXJyYXkuaXNBcnJheShlLmRhdGEpJiYoZS5maWVsZHN8fChlLmZpZWxkcz1lLm1ldGEmJmUubWV0YS5maWVsZHN8fHIpLGUuZmllbGRzfHwoZS5maWVsZHM9QXJyYXkuaXNBcnJheShlLmRhdGFbMF0pP2UuZmllbGRzOlwib2JqZWN0XCI9PXR5cGVvZiBlLmRhdGFbMF0/T2JqZWN0LmtleXMoZS5kYXRhWzBdKTpbXSksQXJyYXkuaXNBcnJheShlLmRhdGFbMF0pfHxcIm9iamVjdFwiPT10eXBlb2YgZS5kYXRhWzBdfHwoZS5kYXRhPVtlLmRhdGFdKSksdShlLmZpZWxkc3x8W10sZS5kYXRhfHxbXSxpKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc2VyaWFsaXplIHVucmVjb2duaXplZCBpbnB1dFwiKTtmdW5jdGlvbiB1KGUsdCxpKXt2YXIgcj1cIlwiO1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1KU09OLnBhcnNlKGUpKSxcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9SlNPTi5wYXJzZSh0KSk7dmFyIG49QXJyYXkuaXNBcnJheShlKSYmMDxlLmxlbmd0aCxzPSFBcnJheS5pc0FycmF5KHRbMF0pO2lmKG4mJl8pe2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7YSsrKTA8YSYmKHIrPW0pLHIrPXYoZVthXSxhKTswPHQubGVuZ3RoJiYocis9eSl9Zm9yKHZhciBvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBoPW4/ZS5sZW5ndGg6dFtvXS5sZW5ndGgsdT0hMSxmPW4/MD09PU9iamVjdC5rZXlzKHRbb10pLmxlbmd0aDowPT09dFtvXS5sZW5ndGg7aWYoaSYmIW4mJih1PVwiZ3JlZWR5XCI9PT1pP1wiXCI9PT10W29dLmpvaW4oXCJcIikudHJpbSgpOjE9PT10W29dLmxlbmd0aCYmMD09PXRbb11bMF0ubGVuZ3RoKSxcImdyZWVkeVwiPT09aSYmbil7Zm9yKHZhciBkPVtdLGw9MDtsPGg7bCsrKXt2YXIgYz1zP2VbbF06bDtkLnB1c2godFtvXVtjXSl9dT1cIlwiPT09ZC5qb2luKFwiXCIpLnRyaW0oKX1pZighdSl7Zm9yKHZhciBwPTA7cDxoO3ArKyl7MDxwJiYhZiYmKHIrPW0pO3ZhciBnPW4mJnM/ZVtwXTpwO3IrPXYodFtvXVtnXSxwKX1vPHQubGVuZ3RoLTEmJighaXx8MDxoJiYhZikmJihyKz15KX19cmV0dXJuIHJ9ZnVuY3Rpb24gdihlLHQpe2lmKG51bGw9PWUpcmV0dXJuXCJcIjtpZihlLmNvbnN0cnVjdG9yPT09RGF0ZSlyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSkuc2xpY2UoMSwyNSk7dmFyIGk9ITE7byYmXCJzdHJpbmdcIj09dHlwZW9mIGUmJm8udGVzdChlKSYmKGU9XCInXCIrZSxpPSEwKTt2YXIgcj1lLnRvU3RyaW5nKCkucmVwbGFjZShoLGEpO3JldHVybihpPWl8fCEwPT09bnx8XCJmdW5jdGlvblwiPT10eXBlb2YgbiYmbihlLHQpfHxBcnJheS5pc0FycmF5KG4pJiZuW3RdfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKWlmKC0xPGUuaW5kZXhPZih0W2ldKSlyZXR1cm4hMDtyZXR1cm4hMX0ocixiLkJBRF9ERUxJTUlURVJTKXx8LTE8ci5pbmRleE9mKG0pfHxcIiBcIj09PXIuY2hhckF0KDApfHxcIiBcIj09PXIuY2hhckF0KHIubGVuZ3RoLTEpKT9zK3IrczpyfX19O2lmKGIuUkVDT1JEX1NFUD1TdHJpbmcuZnJvbUNoYXJDb2RlKDMwKSxiLlVOSVRfU0VQPVN0cmluZy5mcm9tQ2hhckNvZGUoMzEpLGIuQllURV9PUkRFUl9NQVJLPVwiXFx1ZmVmZlwiLGIuQkFEX0RFTElNSVRFUlM9W1wiXFxyXCIsXCJcXG5cIiwnXCInLGIuQllURV9PUkRFUl9NQVJLXSxiLldPUktFUlNfU1VQUE9SVEVEPSFuJiYhIWYuV29ya2VyLGIuTk9ERV9TVFJFQU1fSU5QVVQ9MSxiLkxvY2FsQ2h1bmtTaXplPTEwNDg1NzYwLGIuUmVtb3RlQ2h1bmtTaXplPTUyNDI4ODAsYi5EZWZhdWx0RGVsaW1pdGVyPVwiLFwiLGIuUGFyc2VyPUUsYi5QYXJzZXJIYW5kbGU9aSxiLk5ldHdvcmtTdHJlYW1lcj1sLGIuRmlsZVN0cmVhbWVyPWMsYi5TdHJpbmdTdHJlYW1lcj1wLGIuUmVhZGFibGVTdHJlYW1TdHJlYW1lcj1nLGYualF1ZXJ5KXt2YXIgZD1mLmpRdWVyeTtkLmZuLnBhcnNlPWZ1bmN0aW9uKG8pe3ZhciBpPW8uY29uZmlnfHx7fSxoPVtdO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oZSl7aWYoIShcIklOUFVUXCI9PT1kKHRoaXMpLnByb3AoXCJ0YWdOYW1lXCIpLnRvVXBwZXJDYXNlKCkmJlwiZmlsZVwiPT09ZCh0aGlzKS5hdHRyKFwidHlwZVwiKS50b0xvd2VyQ2FzZSgpJiZmLkZpbGVSZWFkZXIpfHwhdGhpcy5maWxlc3x8MD09PXRoaXMuZmlsZXMubGVuZ3RoKXJldHVybiEwO2Zvcih2YXIgdD0wO3Q8dGhpcy5maWxlcy5sZW5ndGg7dCsrKWgucHVzaCh7ZmlsZTp0aGlzLmZpbGVzW3RdLGlucHV0RWxlbTp0aGlzLGluc3RhbmNlQ29uZmlnOmQuZXh0ZW5kKHt9LGkpfSl9KSxlKCksdGhpcztmdW5jdGlvbiBlKCl7aWYoMCE9PWgubGVuZ3RoKXt2YXIgZSx0LGkscixuPWhbMF07aWYoTShvLmJlZm9yZSkpe3ZhciBzPW8uYmVmb3JlKG4uZmlsZSxuLmlucHV0RWxlbSk7aWYoXCJvYmplY3RcIj09dHlwZW9mIHMpe2lmKFwiYWJvcnRcIj09PXMuYWN0aW9uKXJldHVybiBlPVwiQWJvcnRFcnJvclwiLHQ9bi5maWxlLGk9bi5pbnB1dEVsZW0scj1zLnJlYXNvbix2b2lkKE0oby5lcnJvcikmJm8uZXJyb3Ioe25hbWU6ZX0sdCxpLHIpKTtpZihcInNraXBcIj09PXMuYWN0aW9uKXJldHVybiB2b2lkIHUoKTtcIm9iamVjdFwiPT10eXBlb2Ygcy5jb25maWcmJihuLmluc3RhbmNlQ29uZmlnPWQuZXh0ZW5kKG4uaW5zdGFuY2VDb25maWcscy5jb25maWcpKX1lbHNlIGlmKFwic2tpcFwiPT09cylyZXR1cm4gdm9pZCB1KCl9dmFyIGE9bi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZTtuLmluc3RhbmNlQ29uZmlnLmNvbXBsZXRlPWZ1bmN0aW9uKGUpe00oYSkmJmEoZSxuLmZpbGUsbi5pbnB1dEVsZW0pLHUoKX0sYi5wYXJzZShuLmZpbGUsbi5pbnN0YW5jZUNvbmZpZyl9ZWxzZSBNKG8uY29tcGxldGUpJiZvLmNvbXBsZXRlKCl9ZnVuY3Rpb24gdSgpe2guc3BsaWNlKDAsMSksZSgpfX19ZnVuY3Rpb24gdShlKXt0aGlzLl9oYW5kbGU9bnVsbCx0aGlzLl9maW5pc2hlZD0hMSx0aGlzLl9jb21wbGV0ZWQ9ITEsdGhpcy5faGFsdGVkPSExLHRoaXMuX2lucHV0PW51bGwsdGhpcy5fYmFzZUluZGV4PTAsdGhpcy5fcGFydGlhbExpbmU9XCJcIix0aGlzLl9yb3dDb3VudD0wLHRoaXMuX3N0YXJ0PTAsdGhpcy5fbmV4dENodW5rPW51bGwsdGhpcy5pc0ZpcnN0Q2h1bms9ITAsdGhpcy5fY29tcGxldGVSZXN1bHRzPXtkYXRhOltdLGVycm9yczpbXSxtZXRhOnt9fSxmdW5jdGlvbihlKXt2YXIgdD13KGUpO3QuY2h1bmtTaXplPXBhcnNlSW50KHQuY2h1bmtTaXplKSxlLnN0ZXB8fGUuY2h1bmt8fCh0LmNodW5rU2l6ZT1udWxsKTt0aGlzLl9oYW5kbGU9bmV3IGkodCksKHRoaXMuX2hhbmRsZS5zdHJlYW1lcj10aGlzKS5fY29uZmlnPXR9LmNhbGwodGhpcyxlKSx0aGlzLnBhcnNlQ2h1bms9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmlzRmlyc3RDaHVuayYmTSh0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuaykpe3ZhciBpPXRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKGUpO3ZvaWQgMCE9PWkmJihlPWkpfXRoaXMuaXNGaXJzdENodW5rPSExLHRoaXMuX2hhbHRlZD0hMTt2YXIgcj10aGlzLl9wYXJ0aWFsTGluZStlO3RoaXMuX3BhcnRpYWxMaW5lPVwiXCI7dmFyIG49dGhpcy5faGFuZGxlLnBhcnNlKHIsdGhpcy5fYmFzZUluZGV4LCF0aGlzLl9maW5pc2hlZCk7aWYoIXRoaXMuX2hhbmRsZS5wYXVzZWQoKSYmIXRoaXMuX2hhbmRsZS5hYm9ydGVkKCkpe3ZhciBzPW4ubWV0YS5jdXJzb3I7dGhpcy5fZmluaXNoZWR8fCh0aGlzLl9wYXJ0aWFsTGluZT1yLnN1YnN0cmluZyhzLXRoaXMuX2Jhc2VJbmRleCksdGhpcy5fYmFzZUluZGV4PXMpLG4mJm4uZGF0YSYmKHRoaXMuX3Jvd0NvdW50Kz1uLmRhdGEubGVuZ3RoKTt2YXIgYT10aGlzLl9maW5pc2hlZHx8dGhpcy5fY29uZmlnLnByZXZpZXcmJnRoaXMuX3Jvd0NvdW50Pj10aGlzLl9jb25maWcucHJldmlldztpZihvKWYucG9zdE1lc3NhZ2Uoe3Jlc3VsdHM6bix3b3JrZXJJZDpiLldPUktFUl9JRCxmaW5pc2hlZDphfSk7ZWxzZSBpZihNKHRoaXMuX2NvbmZpZy5jaHVuaykmJiF0KXtpZih0aGlzLl9jb25maWcuY2h1bmsobix0aGlzLl9oYW5kbGUpLHRoaXMuX2hhbmRsZS5wYXVzZWQoKXx8dGhpcy5faGFuZGxlLmFib3J0ZWQoKSlyZXR1cm4gdm9pZCh0aGlzLl9oYWx0ZWQ9ITApO249dm9pZCAwLHRoaXMuX2NvbXBsZXRlUmVzdWx0cz12b2lkIDB9cmV0dXJuIHRoaXMuX2NvbmZpZy5zdGVwfHx0aGlzLl9jb25maWcuY2h1bmt8fCh0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZGF0YT10aGlzLl9jb21wbGV0ZVJlc3VsdHMuZGF0YS5jb25jYXQobi5kYXRhKSx0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZXJyb3JzPXRoaXMuX2NvbXBsZXRlUmVzdWx0cy5lcnJvcnMuY29uY2F0KG4uZXJyb3JzKSx0aGlzLl9jb21wbGV0ZVJlc3VsdHMubWV0YT1uLm1ldGEpLHRoaXMuX2NvbXBsZXRlZHx8IWF8fCFNKHRoaXMuX2NvbmZpZy5jb21wbGV0ZSl8fG4mJm4ubWV0YS5hYm9ydGVkfHwodGhpcy5fY29uZmlnLmNvbXBsZXRlKHRoaXMuX2NvbXBsZXRlUmVzdWx0cyx0aGlzLl9pbnB1dCksdGhpcy5fY29tcGxldGVkPSEwKSxhfHxuJiZuLm1ldGEucGF1c2VkfHx0aGlzLl9uZXh0Q2h1bmsoKSxufXRoaXMuX2hhbHRlZD0hMH0sdGhpcy5fc2VuZEVycm9yPWZ1bmN0aW9uKGUpe00odGhpcy5fY29uZmlnLmVycm9yKT90aGlzLl9jb25maWcuZXJyb3IoZSk6byYmdGhpcy5fY29uZmlnLmVycm9yJiZmLnBvc3RNZXNzYWdlKHt3b3JrZXJJZDpiLldPUktFUl9JRCxlcnJvcjplLGZpbmlzaGVkOiExfSl9fWZ1bmN0aW9uIGwoZSl7dmFyIHI7KGU9ZXx8e30pLmNodW5rU2l6ZXx8KGUuY2h1bmtTaXplPWIuUmVtb3RlQ2h1bmtTaXplKSx1LmNhbGwodGhpcyxlKSx0aGlzLl9uZXh0Q2h1bms9bj9mdW5jdGlvbigpe3RoaXMuX3JlYWRDaHVuaygpLHRoaXMuX2NodW5rTG9hZGVkKCl9OmZ1bmN0aW9uKCl7dGhpcy5fcmVhZENodW5rKCl9LHRoaXMuc3RyZWFtPWZ1bmN0aW9uKGUpe3RoaXMuX2lucHV0PWUsdGhpcy5fbmV4dENodW5rKCl9LHRoaXMuX3JlYWRDaHVuaz1mdW5jdGlvbigpe2lmKHRoaXMuX2ZpbmlzaGVkKXRoaXMuX2NodW5rTG9hZGVkKCk7ZWxzZXtpZihyPW5ldyBYTUxIdHRwUmVxdWVzdCx0aGlzLl9jb25maWcud2l0aENyZWRlbnRpYWxzJiYoci53aXRoQ3JlZGVudGlhbHM9dGhpcy5fY29uZmlnLndpdGhDcmVkZW50aWFscyksbnx8KHIub25sb2FkPXYodGhpcy5fY2h1bmtMb2FkZWQsdGhpcyksci5vbmVycm9yPXYodGhpcy5fY2h1bmtFcnJvcix0aGlzKSksci5vcGVuKHRoaXMuX2NvbmZpZy5kb3dubG9hZFJlcXVlc3RCb2R5P1wiUE9TVFwiOlwiR0VUXCIsdGhpcy5faW5wdXQsIW4pLHRoaXMuX2NvbmZpZy5kb3dubG9hZFJlcXVlc3RIZWFkZXJzKXt2YXIgZT10aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0SGVhZGVycztmb3IodmFyIHQgaW4gZSlyLnNldFJlcXVlc3RIZWFkZXIodCxlW3RdKX1pZih0aGlzLl9jb25maWcuY2h1bmtTaXplKXt2YXIgaT10aGlzLl9zdGFydCt0aGlzLl9jb25maWcuY2h1bmtTaXplLTE7ci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIixcImJ5dGVzPVwiK3RoaXMuX3N0YXJ0K1wiLVwiK2kpfXRyeXtyLnNlbmQodGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEJvZHkpfWNhdGNoKGUpe3RoaXMuX2NodW5rRXJyb3IoZS5tZXNzYWdlKX1uJiYwPT09ci5zdGF0dXMmJnRoaXMuX2NodW5rRXJyb3IoKX19LHRoaXMuX2NodW5rTG9hZGVkPWZ1bmN0aW9uKCl7ND09PXIucmVhZHlTdGF0ZSYmKHIuc3RhdHVzPDIwMHx8NDAwPD1yLnN0YXR1cz90aGlzLl9jaHVua0Vycm9yKCk6KHRoaXMuX3N0YXJ0Kz10aGlzLl9jb25maWcuY2h1bmtTaXplP3RoaXMuX2NvbmZpZy5jaHVua1NpemU6ci5yZXNwb25zZVRleHQubGVuZ3RoLHRoaXMuX2ZpbmlzaGVkPSF0aGlzLl9jb25maWcuY2h1bmtTaXplfHx0aGlzLl9zdGFydD49ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7aWYobnVsbD09PXQpcmV0dXJuLTE7cmV0dXJuIHBhcnNlSW50KHQuc3Vic3RyaW5nKHQubGFzdEluZGV4T2YoXCIvXCIpKzEpKX0ociksdGhpcy5wYXJzZUNodW5rKHIucmVzcG9uc2VUZXh0KSkpfSx0aGlzLl9jaHVua0Vycm9yPWZ1bmN0aW9uKGUpe3ZhciB0PXIuc3RhdHVzVGV4dHx8ZTt0aGlzLl9zZW5kRXJyb3IobmV3IEVycm9yKHQpKX19ZnVuY3Rpb24gYyhlKXt2YXIgcixuOyhlPWV8fHt9KS5jaHVua1NpemV8fChlLmNodW5rU2l6ZT1iLkxvY2FsQ2h1bmtTaXplKSx1LmNhbGwodGhpcyxlKTt2YXIgcz1cInVuZGVmaW5lZFwiIT10eXBlb2YgRmlsZVJlYWRlcjt0aGlzLnN0cmVhbT1mdW5jdGlvbihlKXt0aGlzLl9pbnB1dD1lLG49ZS5zbGljZXx8ZS53ZWJraXRTbGljZXx8ZS5tb3pTbGljZSxzPygocj1uZXcgRmlsZVJlYWRlcikub25sb2FkPXYodGhpcy5fY2h1bmtMb2FkZWQsdGhpcyksci5vbmVycm9yPXYodGhpcy5fY2h1bmtFcnJvcix0aGlzKSk6cj1uZXcgRmlsZVJlYWRlclN5bmMsdGhpcy5fbmV4dENodW5rKCl9LHRoaXMuX25leHRDaHVuaz1mdW5jdGlvbigpe3RoaXMuX2ZpbmlzaGVkfHx0aGlzLl9jb25maWcucHJldmlldyYmISh0aGlzLl9yb3dDb3VudDx0aGlzLl9jb25maWcucHJldmlldyl8fHRoaXMuX3JlYWRDaHVuaygpfSx0aGlzLl9yZWFkQ2h1bms9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9pbnB1dDtpZih0aGlzLl9jb25maWcuY2h1bmtTaXplKXt2YXIgdD1NYXRoLm1pbih0aGlzLl9zdGFydCt0aGlzLl9jb25maWcuY2h1bmtTaXplLHRoaXMuX2lucHV0LnNpemUpO2U9bi5jYWxsKGUsdGhpcy5fc3RhcnQsdCl9dmFyIGk9ci5yZWFkQXNUZXh0KGUsdGhpcy5fY29uZmlnLmVuY29kaW5nKTtzfHx0aGlzLl9jaHVua0xvYWRlZCh7dGFyZ2V0OntyZXN1bHQ6aX19KX0sdGhpcy5fY2h1bmtMb2FkZWQ9ZnVuY3Rpb24oZSl7dGhpcy5fc3RhcnQrPXRoaXMuX2NvbmZpZy5jaHVua1NpemUsdGhpcy5fZmluaXNoZWQ9IXRoaXMuX2NvbmZpZy5jaHVua1NpemV8fHRoaXMuX3N0YXJ0Pj10aGlzLl9pbnB1dC5zaXplLHRoaXMucGFyc2VDaHVuayhlLnRhcmdldC5yZXN1bHQpfSx0aGlzLl9jaHVua0Vycm9yPWZ1bmN0aW9uKCl7dGhpcy5fc2VuZEVycm9yKHIuZXJyb3IpfX1mdW5jdGlvbiBwKGUpe3ZhciBpO3UuY2FsbCh0aGlzLGU9ZXx8e30pLHRoaXMuc3RyZWFtPWZ1bmN0aW9uKGUpe3JldHVybiBpPWUsdGhpcy5fbmV4dENodW5rKCl9LHRoaXMuX25leHRDaHVuaz1mdW5jdGlvbigpe2lmKCF0aGlzLl9maW5pc2hlZCl7dmFyIGUsdD10aGlzLl9jb25maWcuY2h1bmtTaXplO3JldHVybiB0PyhlPWkuc3Vic3RyaW5nKDAsdCksaT1pLnN1YnN0cmluZyh0KSk6KGU9aSxpPVwiXCIpLHRoaXMuX2ZpbmlzaGVkPSFpLHRoaXMucGFyc2VDaHVuayhlKX19fWZ1bmN0aW9uIGcoZSl7dS5jYWxsKHRoaXMsZT1lfHx7fSk7dmFyIHQ9W10saT0hMCxyPSExO3RoaXMucGF1c2U9ZnVuY3Rpb24oKXt1LnByb3RvdHlwZS5wYXVzZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5faW5wdXQucGF1c2UoKX0sdGhpcy5yZXN1bWU9ZnVuY3Rpb24oKXt1LnByb3RvdHlwZS5yZXN1bWUuYXBwbHkodGhpcyxhcmd1bWVudHMpLHRoaXMuX2lucHV0LnJlc3VtZSgpfSx0aGlzLnN0cmVhbT1mdW5jdGlvbihlKXt0aGlzLl9pbnB1dD1lLHRoaXMuX2lucHV0Lm9uKFwiZGF0YVwiLHRoaXMuX3N0cmVhbURhdGEpLHRoaXMuX2lucHV0Lm9uKFwiZW5kXCIsdGhpcy5fc3RyZWFtRW5kKSx0aGlzLl9pbnB1dC5vbihcImVycm9yXCIsdGhpcy5fc3RyZWFtRXJyb3IpfSx0aGlzLl9jaGVja0lzRmluaXNoZWQ9ZnVuY3Rpb24oKXtyJiYxPT09dC5sZW5ndGgmJih0aGlzLl9maW5pc2hlZD0hMCl9LHRoaXMuX25leHRDaHVuaz1mdW5jdGlvbigpe3RoaXMuX2NoZWNrSXNGaW5pc2hlZCgpLHQubGVuZ3RoP3RoaXMucGFyc2VDaHVuayh0LnNoaWZ0KCkpOmk9ITB9LHRoaXMuX3N0cmVhbURhdGE9dihmdW5jdGlvbihlKXt0cnl7dC5wdXNoKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS50b1N0cmluZyh0aGlzLl9jb25maWcuZW5jb2RpbmcpKSxpJiYoaT0hMSx0aGlzLl9jaGVja0lzRmluaXNoZWQoKSx0aGlzLnBhcnNlQ2h1bmsodC5zaGlmdCgpKSl9Y2F0Y2goZSl7dGhpcy5fc3RyZWFtRXJyb3IoZSl9fSx0aGlzKSx0aGlzLl9zdHJlYW1FcnJvcj12KGZ1bmN0aW9uKGUpe3RoaXMuX3N0cmVhbUNsZWFuVXAoKSx0aGlzLl9zZW5kRXJyb3IoZSl9LHRoaXMpLHRoaXMuX3N0cmVhbUVuZD12KGZ1bmN0aW9uKCl7dGhpcy5fc3RyZWFtQ2xlYW5VcCgpLHI9ITAsdGhpcy5fc3RyZWFtRGF0YShcIlwiKX0sdGhpcyksdGhpcy5fc3RyZWFtQ2xlYW5VcD12KGZ1bmN0aW9uKCl7dGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsdGhpcy5fc3RyZWFtRGF0YSksdGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIix0aGlzLl9zdHJlYW1FbmQpLHRoaXMuX2lucHV0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIix0aGlzLl9zdHJlYW1FcnJvcil9LHRoaXMpfWZ1bmN0aW9uIGkobSl7dmFyIGEsbyxoLHI9TWF0aC5wb3coMiw1Myksbj0tcixzPS9eXFxzKi0/KFxcZCtcXC4/fFxcLlxcZCt8XFxkK1xcLlxcZCspKFtlRV1bLStdP1xcZCspP1xccyokLyx1PS9eKFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkKyhbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpJC8sdD10aGlzLGk9MCxmPTAsZD0hMSxlPSExLGw9W10sYz17ZGF0YTpbXSxlcnJvcnM6W10sbWV0YTp7fX07aWYoTShtLnN0ZXApKXt2YXIgcD1tLnN0ZXA7bS5zdGVwPWZ1bmN0aW9uKGUpe2lmKGM9ZSxfKCkpZygpO2Vsc2V7aWYoZygpLDA9PT1jLmRhdGEubGVuZ3RoKXJldHVybjtpKz1lLmRhdGEubGVuZ3RoLG0ucHJldmlldyYmaT5tLnByZXZpZXc/by5hYm9ydCgpOihjLmRhdGE9Yy5kYXRhWzBdLHAoYyx0KSl9fX1mdW5jdGlvbiB5KGUpe3JldHVyblwiZ3JlZWR5XCI9PT1tLnNraXBFbXB0eUxpbmVzP1wiXCI9PT1lLmpvaW4oXCJcIikudHJpbSgpOjE9PT1lLmxlbmd0aCYmMD09PWVbMF0ubGVuZ3RofWZ1bmN0aW9uIGcoKXtyZXR1cm4gYyYmaCYmKGsoXCJEZWxpbWl0ZXJcIixcIlVuZGV0ZWN0YWJsZURlbGltaXRlclwiLFwiVW5hYmxlIHRvIGF1dG8tZGV0ZWN0IGRlbGltaXRpbmcgY2hhcmFjdGVyOyBkZWZhdWx0ZWQgdG8gJ1wiK2IuRGVmYXVsdERlbGltaXRlcitcIidcIiksaD0hMSksbS5za2lwRW1wdHlMaW5lcyYmKGMuZGF0YT1jLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiF5KGUpfSkpLF8oKSYmZnVuY3Rpb24oKXtpZighYylyZXR1cm47ZnVuY3Rpb24gZShlLHQpe00obS50cmFuc2Zvcm1IZWFkZXIpJiYoZT1tLnRyYW5zZm9ybUhlYWRlcihlLHQpKSxsLnB1c2goZSl9aWYoQXJyYXkuaXNBcnJheShjLmRhdGFbMF0pKXtmb3IodmFyIHQ9MDtfKCkmJnQ8Yy5kYXRhLmxlbmd0aDt0KyspYy5kYXRhW3RdLmZvckVhY2goZSk7Yy5kYXRhLnNwbGljZSgwLDEpfWVsc2UgYy5kYXRhLmZvckVhY2goZSl9KCksZnVuY3Rpb24oKXtpZighY3x8IW0uaGVhZGVyJiYhbS5keW5hbWljVHlwaW5nJiYhbS50cmFuc2Zvcm0pcmV0dXJuIGM7ZnVuY3Rpb24gZShlLHQpe3ZhciBpLHI9bS5oZWFkZXI/e306W107Zm9yKGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49aSxzPWVbaV07bS5oZWFkZXImJihuPWk+PWwubGVuZ3RoP1wiX19wYXJzZWRfZXh0cmFcIjpsW2ldKSxtLnRyYW5zZm9ybSYmKHM9bS50cmFuc2Zvcm0ocyxuKSkscz12KG4scyksXCJfX3BhcnNlZF9leHRyYVwiPT09bj8ocltuXT1yW25dfHxbXSxyW25dLnB1c2gocykpOnJbbl09c31yZXR1cm4gbS5oZWFkZXImJihpPmwubGVuZ3RoP2soXCJGaWVsZE1pc21hdGNoXCIsXCJUb29NYW55RmllbGRzXCIsXCJUb28gbWFueSBmaWVsZHM6IGV4cGVjdGVkIFwiK2wubGVuZ3RoK1wiIGZpZWxkcyBidXQgcGFyc2VkIFwiK2ksZit0KTppPGwubGVuZ3RoJiZrKFwiRmllbGRNaXNtYXRjaFwiLFwiVG9vRmV3RmllbGRzXCIsXCJUb28gZmV3IGZpZWxkczogZXhwZWN0ZWQgXCIrbC5sZW5ndGgrXCIgZmllbGRzIGJ1dCBwYXJzZWQgXCIraSxmK3QpKSxyfXZhciB0PTE7IWMuZGF0YS5sZW5ndGh8fEFycmF5LmlzQXJyYXkoYy5kYXRhWzBdKT8oYy5kYXRhPWMuZGF0YS5tYXAoZSksdD1jLmRhdGEubGVuZ3RoKTpjLmRhdGE9ZShjLmRhdGEsMCk7bS5oZWFkZXImJmMubWV0YSYmKGMubWV0YS5maWVsZHM9bCk7cmV0dXJuIGYrPXQsY30oKX1mdW5jdGlvbiBfKCl7cmV0dXJuIG0uaGVhZGVyJiYwPT09bC5sZW5ndGh9ZnVuY3Rpb24gdihlLHQpe3JldHVybiBpPWUsbS5keW5hbWljVHlwaW5nRnVuY3Rpb24mJnZvaWQgMD09PW0uZHluYW1pY1R5cGluZ1tpXSYmKG0uZHluYW1pY1R5cGluZ1tpXT1tLmR5bmFtaWNUeXBpbmdGdW5jdGlvbihpKSksITA9PT0obS5keW5hbWljVHlwaW5nW2ldfHxtLmR5bmFtaWNUeXBpbmcpP1widHJ1ZVwiPT09dHx8XCJUUlVFXCI9PT10fHxcImZhbHNlXCIhPT10JiZcIkZBTFNFXCIhPT10JiYoZnVuY3Rpb24oZSl7aWYocy50ZXN0KGUpKXt2YXIgdD1wYXJzZUZsb2F0KGUpO2lmKG48dCYmdDxyKXJldHVybiEwfXJldHVybiExfSh0KT9wYXJzZUZsb2F0KHQpOnUudGVzdCh0KT9uZXcgRGF0ZSh0KTpcIlwiPT09dD9udWxsOnQpOnQ7dmFyIGl9ZnVuY3Rpb24gayhlLHQsaSxyKXt2YXIgbj17dHlwZTplLGNvZGU6dCxtZXNzYWdlOml9O3ZvaWQgMCE9PXImJihuLnJvdz1yKSxjLmVycm9ycy5wdXNoKG4pfXRoaXMucGFyc2U9ZnVuY3Rpb24oZSx0LGkpe3ZhciByPW0ucXVvdGVDaGFyfHwnXCInO2lmKG0ubmV3bGluZXx8KG0ubmV3bGluZT1mdW5jdGlvbihlLHQpe2U9ZS5zdWJzdHJpbmcoMCwxMDQ4NTc2KTt2YXIgaT1uZXcgUmVnRXhwKGoodCkrXCIoW15dKj8pXCIraih0KSxcImdtXCIpLHI9KGU9ZS5yZXBsYWNlKGksXCJcIikpLnNwbGl0KFwiXFxyXCIpLG49ZS5zcGxpdChcIlxcblwiKSxzPTE8bi5sZW5ndGgmJm5bMF0ubGVuZ3RoPHJbMF0ubGVuZ3RoO2lmKDE9PT1yLmxlbmd0aHx8cylyZXR1cm5cIlxcblwiO2Zvcih2YXIgYT0wLG89MDtvPHIubGVuZ3RoO28rKylcIlxcblwiPT09cltvXVswXSYmYSsrO3JldHVybiBhPj1yLmxlbmd0aC8yP1wiXFxyXFxuXCI6XCJcXHJcIn0oZSxyKSksaD0hMSxtLmRlbGltaXRlcilNKG0uZGVsaW1pdGVyKSYmKG0uZGVsaW1pdGVyPW0uZGVsaW1pdGVyKGUpLGMubWV0YS5kZWxpbWl0ZXI9bS5kZWxpbWl0ZXIpO2Vsc2V7dmFyIG49ZnVuY3Rpb24oZSx0LGkscixuKXt2YXIgcyxhLG8saDtuPW58fFtcIixcIixcIlxcdFwiLFwifFwiLFwiO1wiLGIuUkVDT1JEX1NFUCxiLlVOSVRfU0VQXTtmb3IodmFyIHU9MDt1PG4ubGVuZ3RoO3UrKyl7dmFyIGY9blt1XSxkPTAsbD0wLGM9MDtvPXZvaWQgMDtmb3IodmFyIHA9bmV3IEUoe2NvbW1lbnRzOnIsZGVsaW1pdGVyOmYsbmV3bGluZTp0LHByZXZpZXc6MTB9KS5wYXJzZShlKSxnPTA7ZzxwLmRhdGEubGVuZ3RoO2crKylpZihpJiZ5KHAuZGF0YVtnXSkpYysrO2Vsc2V7dmFyIF89cC5kYXRhW2ddLmxlbmd0aDtsKz1fLHZvaWQgMCE9PW8/MDxfJiYoZCs9TWF0aC5hYnMoXy1vKSxvPV8pOm89X30wPHAuZGF0YS5sZW5ndGgmJihsLz1wLmRhdGEubGVuZ3RoLWMpLCh2b2lkIDA9PT1hfHxkPD1hKSYmKHZvaWQgMD09PWh8fGg8bCkmJjEuOTk8bCYmKGE9ZCxzPWYsaD1sKX1yZXR1cm57c3VjY2Vzc2Z1bDohIShtLmRlbGltaXRlcj1zKSxiZXN0RGVsaW1pdGVyOnN9fShlLG0ubmV3bGluZSxtLnNraXBFbXB0eUxpbmVzLG0uY29tbWVudHMsbS5kZWxpbWl0ZXJzVG9HdWVzcyk7bi5zdWNjZXNzZnVsP20uZGVsaW1pdGVyPW4uYmVzdERlbGltaXRlcjooaD0hMCxtLmRlbGltaXRlcj1iLkRlZmF1bHREZWxpbWl0ZXIpLGMubWV0YS5kZWxpbWl0ZXI9bS5kZWxpbWl0ZXJ9dmFyIHM9dyhtKTtyZXR1cm4gbS5wcmV2aWV3JiZtLmhlYWRlciYmcy5wcmV2aWV3KyssYT1lLG89bmV3IEUocyksYz1vLnBhcnNlKGEsdCxpKSxnKCksZD97bWV0YTp7cGF1c2VkOiEwfX06Y3x8e21ldGE6e3BhdXNlZDohMX19fSx0aGlzLnBhdXNlZD1mdW5jdGlvbigpe3JldHVybiBkfSx0aGlzLnBhdXNlPWZ1bmN0aW9uKCl7ZD0hMCxvLmFib3J0KCksYT1NKG0uY2h1bmspP1wiXCI6YS5zdWJzdHJpbmcoby5nZXRDaGFySW5kZXgoKSl9LHRoaXMucmVzdW1lPWZ1bmN0aW9uKCl7dC5zdHJlYW1lci5faGFsdGVkPyhkPSExLHQuc3RyZWFtZXIucGFyc2VDaHVuayhhLCEwKSk6c2V0VGltZW91dCh0LnJlc3VtZSwzKX0sdGhpcy5hYm9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIGV9LHRoaXMuYWJvcnQ9ZnVuY3Rpb24oKXtlPSEwLG8uYWJvcnQoKSxjLm1ldGEuYWJvcnRlZD0hMCxNKG0uY29tcGxldGUpJiZtLmNvbXBsZXRlKGMpLGE9XCJcIn19ZnVuY3Rpb24gaihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZyxcIlxcXFwkJlwiKX1mdW5jdGlvbiBFKGUpe3ZhciBTLE89KGU9ZXx8e30pLmRlbGltaXRlcix4PWUubmV3bGluZSxJPWUuY29tbWVudHMsVD1lLnN0ZXAsRD1lLnByZXZpZXcsQT1lLmZhc3RNb2RlLEw9Uz12b2lkIDA9PT1lLnF1b3RlQ2hhcnx8bnVsbD09PWUucXVvdGVDaGFyPydcIic6ZS5xdW90ZUNoYXI7aWYodm9pZCAwIT09ZS5lc2NhcGVDaGFyJiYoTD1lLmVzY2FwZUNoYXIpLChcInN0cmluZ1wiIT10eXBlb2YgT3x8LTE8Yi5CQURfREVMSU1JVEVSUy5pbmRleE9mKE8pKSYmKE89XCIsXCIpLEk9PT1PKXRocm93IG5ldyBFcnJvcihcIkNvbW1lbnQgY2hhcmFjdGVyIHNhbWUgYXMgZGVsaW1pdGVyXCIpOyEwPT09ST9JPVwiI1wiOihcInN0cmluZ1wiIT10eXBlb2YgSXx8LTE8Yi5CQURfREVMSU1JVEVSUy5pbmRleE9mKEkpKSYmKEk9ITEpLFwiXFxuXCIhPT14JiZcIlxcclwiIT09eCYmXCJcXHJcXG5cIiE9PXgmJih4PVwiXFxuXCIpO3ZhciBGPTAsej0hMTt0aGlzLnBhcnNlPWZ1bmN0aW9uKHIsdCxpKXtpZihcInN0cmluZ1wiIT10eXBlb2Ygcil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGEgc3RyaW5nXCIpO3ZhciBuPXIubGVuZ3RoLGU9Ty5sZW5ndGgscz14Lmxlbmd0aCxhPUkubGVuZ3RoLG89TShUKSxoPVtdLHU9W10sZj1bXSxkPUY9MDtpZighcilyZXR1cm4gQygpO2lmKEF8fCExIT09QSYmLTE9PT1yLmluZGV4T2YoUykpe2Zvcih2YXIgbD1yLnNwbGl0KHgpLGM9MDtjPGwubGVuZ3RoO2MrKyl7aWYoZj1sW2NdLEYrPWYubGVuZ3RoLGMhPT1sLmxlbmd0aC0xKUYrPXgubGVuZ3RoO2Vsc2UgaWYoaSlyZXR1cm4gQygpO2lmKCFJfHxmLnN1YnN0cmluZygwLGEpIT09SSl7aWYobyl7aWYoaD1bXSxrKGYuc3BsaXQoTykpLFIoKSx6KXJldHVybiBDKCl9ZWxzZSBrKGYuc3BsaXQoTykpO2lmKEQmJkQ8PWMpcmV0dXJuIGg9aC5zbGljZSgwLEQpLEMoITApfX1yZXR1cm4gQygpfWZvcih2YXIgcD1yLmluZGV4T2YoTyxGKSxnPXIuaW5kZXhPZih4LEYpLF89bmV3IFJlZ0V4cChqKEwpK2ooUyksXCJnXCIpLG09ci5pbmRleE9mKFMsRik7OylpZihyW0ZdIT09UylpZihJJiYwPT09Zi5sZW5ndGgmJnIuc3Vic3RyaW5nKEYsRithKT09PUkpe2lmKC0xPT09ZylyZXR1cm4gQygpO0Y9ZytzLGc9ci5pbmRleE9mKHgsRikscD1yLmluZGV4T2YoTyxGKX1lbHNlIGlmKC0xIT09cCYmKHA8Z3x8LTE9PT1nKSlmLnB1c2goci5zdWJzdHJpbmcoRixwKSksRj1wK2UscD1yLmluZGV4T2YoTyxGKTtlbHNle2lmKC0xPT09ZylicmVhaztpZihmLnB1c2goci5zdWJzdHJpbmcoRixnKSksdyhnK3MpLG8mJihSKCkseikpcmV0dXJuIEMoKTtpZihEJiZoLmxlbmd0aD49RClyZXR1cm4gQyghMCl9ZWxzZSBmb3IobT1GLEYrKzs7KXtpZigtMT09PShtPXIuaW5kZXhPZihTLG0rMSkpKXJldHVybiBpfHx1LnB1c2goe3R5cGU6XCJRdW90ZXNcIixjb2RlOlwiTWlzc2luZ1F1b3Rlc1wiLG1lc3NhZ2U6XCJRdW90ZWQgZmllbGQgdW50ZXJtaW5hdGVkXCIscm93OmgubGVuZ3RoLGluZGV4OkZ9KSxFKCk7aWYobT09PW4tMSlyZXR1cm4gRShyLnN1YnN0cmluZyhGLG0pLnJlcGxhY2UoXyxTKSk7aWYoUyE9PUx8fHJbbSsxXSE9PUwpe2lmKFM9PT1MfHwwPT09bXx8clttLTFdIT09TCl7LTEhPT1wJiZwPG0rMSYmKHA9ci5pbmRleE9mKE8sbSsxKSksLTEhPT1nJiZnPG0rMSYmKGc9ci5pbmRleE9mKHgsbSsxKSk7dmFyIHk9YigtMT09PWc/cDpNYXRoLm1pbihwLGcpKTtpZihyLnN1YnN0cihtKzEreSxlKT09PU8pe2YucHVzaChyLnN1YnN0cmluZyhGLG0pLnJlcGxhY2UoXyxTKSkscltGPW0rMSt5K2VdIT09UyYmKG09ci5pbmRleE9mKFMsRikpLHA9ci5pbmRleE9mKE8sRiksZz1yLmluZGV4T2YoeCxGKTticmVha312YXIgdj1iKGcpO2lmKHIuc3Vic3RyaW5nKG0rMSt2LG0rMSt2K3MpPT09eCl7aWYoZi5wdXNoKHIuc3Vic3RyaW5nKEYsbSkucmVwbGFjZShfLFMpKSx3KG0rMSt2K3MpLHA9ci5pbmRleE9mKE8sRiksbT1yLmluZGV4T2YoUyxGKSxvJiYoUigpLHopKXJldHVybiBDKCk7aWYoRCYmaC5sZW5ndGg+PUQpcmV0dXJuIEMoITApO2JyZWFrfXUucHVzaCh7dHlwZTpcIlF1b3Rlc1wiLGNvZGU6XCJJbnZhbGlkUXVvdGVzXCIsbWVzc2FnZTpcIlRyYWlsaW5nIHF1b3RlIG9uIHF1b3RlZCBmaWVsZCBpcyBtYWxmb3JtZWRcIixyb3c6aC5sZW5ndGgsaW5kZXg6Rn0pLG0rK319ZWxzZSBtKyt9cmV0dXJuIEUoKTtmdW5jdGlvbiBrKGUpe2gucHVzaChlKSxkPUZ9ZnVuY3Rpb24gYihlKXt2YXIgdD0wO2lmKC0xIT09ZSl7dmFyIGk9ci5zdWJzdHJpbmcobSsxLGUpO2kmJlwiXCI9PT1pLnRyaW0oKSYmKHQ9aS5sZW5ndGgpfXJldHVybiB0fWZ1bmN0aW9uIEUoZSl7cmV0dXJuIGl8fCh2b2lkIDA9PT1lJiYoZT1yLnN1YnN0cmluZyhGKSksZi5wdXNoKGUpLEY9bixrKGYpLG8mJlIoKSksQygpfWZ1bmN0aW9uIHcoZSl7Rj1lLGsoZiksZj1bXSxnPXIuaW5kZXhPZih4LEYpfWZ1bmN0aW9uIEMoZSl7cmV0dXJue2RhdGE6aCxlcnJvcnM6dSxtZXRhOntkZWxpbWl0ZXI6TyxsaW5lYnJlYWs6eCxhYm9ydGVkOnosdHJ1bmNhdGVkOiEhZSxjdXJzb3I6ZCsodHx8MCl9fX1mdW5jdGlvbiBSKCl7VChDKCkpLGg9W10sdT1bXX19LHRoaXMuYWJvcnQ9ZnVuY3Rpb24oKXt6PSEwfSx0aGlzLmdldENoYXJJbmRleD1mdW5jdGlvbigpe3JldHVybiBGfX1mdW5jdGlvbiBfKGUpe3ZhciB0PWUuZGF0YSxpPWFbdC53b3JrZXJJZF0scj0hMTtpZih0LmVycm9yKWkudXNlckVycm9yKHQuZXJyb3IsdC5maWxlKTtlbHNlIGlmKHQucmVzdWx0cyYmdC5yZXN1bHRzLmRhdGEpe3ZhciBuPXthYm9ydDpmdW5jdGlvbigpe3I9ITAsbSh0LndvcmtlcklkLHtkYXRhOltdLGVycm9yczpbXSxtZXRhOnthYm9ydGVkOiEwfX0pfSxwYXVzZTp5LHJlc3VtZTp5fTtpZihNKGkudXNlclN0ZXApKXtmb3IodmFyIHM9MDtzPHQucmVzdWx0cy5kYXRhLmxlbmd0aCYmKGkudXNlclN0ZXAoe2RhdGE6dC5yZXN1bHRzLmRhdGFbc10sZXJyb3JzOnQucmVzdWx0cy5lcnJvcnMsbWV0YTp0LnJlc3VsdHMubWV0YX0sbiksIXIpO3MrKyk7ZGVsZXRlIHQucmVzdWx0c31lbHNlIE0oaS51c2VyQ2h1bmspJiYoaS51c2VyQ2h1bmsodC5yZXN1bHRzLG4sdC5maWxlKSxkZWxldGUgdC5yZXN1bHRzKX10LmZpbmlzaGVkJiYhciYmbSh0LndvcmtlcklkLHQucmVzdWx0cyl9ZnVuY3Rpb24gbShlLHQpe3ZhciBpPWFbZV07TShpLnVzZXJDb21wbGV0ZSkmJmkudXNlckNvbXBsZXRlKHQpLGkudGVybWluYXRlKCksZGVsZXRlIGFbZV19ZnVuY3Rpb24geSgpe3Rocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIil9ZnVuY3Rpb24gdyhlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuIGU7dmFyIHQ9QXJyYXkuaXNBcnJheShlKT9bXTp7fTtmb3IodmFyIGkgaW4gZSl0W2ldPXcoZVtpXSk7cmV0dXJuIHR9ZnVuY3Rpb24gdihlLHQpe3JldHVybiBmdW5jdGlvbigpe2UuYXBwbHkodCxhcmd1bWVudHMpfX1mdW5jdGlvbiBNKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV9cmV0dXJuIG8mJihmLm9ubWVzc2FnZT1mdW5jdGlvbihlKXt2YXIgdD1lLmRhdGE7dm9pZCAwPT09Yi5XT1JLRVJfSUQmJnQmJihiLldPUktFUl9JRD10LndvcmtlcklkKTtpZihcInN0cmluZ1wiPT10eXBlb2YgdC5pbnB1dClmLnBvc3RNZXNzYWdlKHt3b3JrZXJJZDpiLldPUktFUl9JRCxyZXN1bHRzOmIucGFyc2UodC5pbnB1dCx0LmNvbmZpZyksZmluaXNoZWQ6ITB9KTtlbHNlIGlmKGYuRmlsZSYmdC5pbnB1dCBpbnN0YW5jZW9mIEZpbGV8fHQuaW5wdXQgaW5zdGFuY2VvZiBPYmplY3Qpe3ZhciBpPWIucGFyc2UodC5pbnB1dCx0LmNvbmZpZyk7aSYmZi5wb3N0TWVzc2FnZSh7d29ya2VySWQ6Yi5XT1JLRVJfSUQscmVzdWx0czppLGZpbmlzaGVkOiEwfSl9fSksKGwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodS5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1sLChjLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHUucHJvdG90eXBlKSkuY29uc3RydWN0b3I9YywocC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShwLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPXAsKGcucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodS5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1nLGJ9KTsiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2xpYnMvY29tcG9uZW50JztcbmltcG9ydCB7IGdldERCTWFuYWdlciB9IGZyb20gJy4uLy4uL2xpYnMvZGItbWFuYWdlcic7XG5pbXBvcnQgeyBkYXRlVG9TdHIsIGRhdGVUb0RpZmZUaW1lU3RyLCBlbXB0eUVsZW1lbnQgfSBmcm9tICcuLi8uLi9saWJzL3V0aWxzJztcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlLmhicyc7XG5pbXBvcnQgcm93VGVtcGxhdGUgZnJvbSAnLi9yb3ctdGVtcGxhdGUuaGJzJztcbmltcG9ydCB7IGZvcm1Ub0pTT04gfSBmcm9tICcuLi8uLi9saWJzL2Zvcm0tdG8tanNvbic7XG5cbmNsYXNzIEMxVGFibGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRiTWFuYWdlciA9IGdldERCTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7fVxuXG4gICAgYXN5bmMgX2luaXQoKSB7XG4gICAgICAgIC8vIHN0YXRpYyBwcm9wc1xuICAgICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbGFiZWxzJykuc3BsaXQoJywnKTtcbiAgICAgICAgY29uc3QgZmlsdGVyS2V5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbHRlcktleScpO1xuICAgICAgICBjb25zdCB0aXRsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xuXG4gICAgICAgIC8vIGdsb2JhbCBwcm9wc1xuICAgICAgICB0aGlzLnJvd3NLZXkgPSB0aGlzLmdldEF0dHJpYnV0ZSgncm93c0tleScpO1xuICAgICAgICB0aGlzLmVkaXRFbmFibGVkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2VkaXRFbmFibGVkJyk7XG4gICAgICAgIHRoaXMuYWN0aW9uRGlzYWJsZWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aW9uRGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5rZXlzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2tleXMnKS5zcGxpdCgnLCcpO1xuICAgICAgICB0aGlzLm9yZGVyQnkgPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JkZXJCeScpO1xuICAgICAgICB0aGlzLm9yZGVyRGlyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yZGVyRGlyJykgfHwgJ2FzYyc7XG5cbiAgICAgICAgLy8gZ2V0IHJvd3MgYW5kIGdlbmVyYXRlXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudCgpO1xuICAgICAgICB0aGlzLnJvd3MgPSBhd2FpdCBwYXJlbnQuZ2V0Um93cyh0aGlzLnJvd3NLZXkpO1xuICAgICAgICBjb25zdCByb3dzSHRtbHMgPSB0aGlzLl9nZW5lcmF0ZVJvd3MoKTtcblxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgbGFiZWxzLFxuICAgICAgICAgICAgcm93c0h0bWxzLFxuICAgICAgICAgICAgZmlsdGVyS2V5LFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBhY3Rpb25EaXNhYmxlZDogdGhpcy5hY3Rpb25EaXNhYmxlZCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXJzZSBodG1sXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgY29uc3QgaHRtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGVtcGxhdGUoZGF0YSksICd0ZXh0L2h0bWwnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChodG1sRG9jLmJvZHkuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgICAgIHRoaXMudGFibGVCb2R5ID0gdGhpcy5fcmVmKCd0Ym9keScpO1xuXG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIF9hZGRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcygnW3JlZj1kZWxldGVSb3ddJykpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJ3RyJyk7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRyLmRhdGFzZXQuaWQ7XG4gICAgICAgICAgICBjb25zdCBvayA9IGF3YWl0IHRoaXMuX3BhcmVudCgpLmRlbGV0ZVJvdyhpZCwgdGhpcy5yb3dzS2V5KTtcbiAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZignY291bnQnKS5pbm5lckhUTUwgPSB0aGlzLl9yZWYoJ2NvdW50JykuaW5uZXJIVE1MIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKCdbcmVmPWVkaXRSb3ddJykpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJ3RyJyk7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRyLmRhdGFzZXQuaWQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYXJlbnQoKS5lZGl0Um93KGlkLCB0aGlzLnJvd3NLZXkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXIgPSBmb3JtVG9KU09OKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZW1wdHlFbGVtZW50KHRoaXMudGFibGVCb2R5KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzSHRtbHNKb2luID0gdGhpcy5fZ2VuZXJhdGVSb3dzKCkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZUJvZHkuaW5uZXJIVE1MID0gcm93c0h0bWxzSm9pbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmlsdGVyJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIF9yb3dNYXAoaXRlbSkge1xuICAgICAgICBjb25zdCByZXMgPSB7IGlkOiBpdGVtLmlkLCBkYXRhOiBbXSwgZWRpdEVuYWJsZWQ6IHRoaXMuZWRpdEVuYWJsZWQsIGFjdGlvbkRpc2FibGVkOiB0aGlzLmFjdGlvbkRpc2FibGVkIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMua2V5cykge1xuICAgICAgICAgICAgaWYgKGtleSA9PSAnc3RhcnQnKSByZXMuZGF0YS5wdXNoKGRhdGVUb1N0cihpdGVtW2tleV0pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PSAndGltZScgfHwga2V5ID09ICdlbmQnIHx8IGtleSA9PSAnYXNzaWduZWRUaW1lJykgcmVzLmRhdGEucHVzaChkYXRlVG9TdHIoaXRlbVtrZXldLCB0cnVlKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT0gJ2RpZmYnKSByZXMuZGF0YS5wdXNoKGRhdGVUb0RpZmZUaW1lU3RyKGl0ZW1ba2V5XSwgdHJ1ZSkpO1xuICAgICAgICAgICAgZWxzZSByZXMuZGF0YS5wdXNoKGl0ZW1ba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGVSb3dzKCkge1xuICAgICAgICBsZXQgZmluYWxSb3dzID0gdGhpcy5yb3dzO1xuICAgICAgICAvLyBmaWx0ZXIgZGF0YVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RmlsdGVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmN1cnJlbnRGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxSb3dzID0gZmluYWxSb3dzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHRoaXMuY3VycmVudEZpbHRlcltrZXldLCAnaScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChpdGVtW2tleV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3JkZXIgZGF0YVxuICAgICAgICBpZiAodGhpcy5vcmRlckJ5KSB7XG4gICAgICAgICAgICBmaW5hbFJvd3Muc29ydCgob25lLCB0d28pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdGhpcy5vcmRlckRpciA9PSAnYXNjJyA/IG9uZSA6IHR3bztcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5vcmRlckRpciA9PSAnYXNjJyA/IHR3byA6IG9uZTtcblxuICAgICAgICAgICAgICAgIGlmIChhW3RoaXMub3JkZXJCeV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJbdGhpcy5vcmRlckJ5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYVt0aGlzLm9yZGVyQnldIDwgYlt0aGlzLm9yZGVyQnldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFbdGhpcy5vcmRlckJ5XSA+PSBiW3RoaXMub3JkZXJCeV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXAgZm9yIGxheW91dFxuICAgICAgICBmaW5hbFJvd3MgPSBmaW5hbFJvd3MubWFwKChpdGVtKSA9PiB0aGlzLl9yb3dNYXAoaXRlbSkpO1xuXG4gICAgICAgIC8vIHJlbmRlciByb3dzXG4gICAgICAgIGNvbnN0IHJvd3NIdG1scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBmaW5hbFJvd3MpIHtcbiAgICAgICAgICAgIHJvd3NIdG1scy5wdXNoKHJvd1RlbXBsYXRlKHJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzSHRtbHM7XG4gICAgfVxuXG4gICAgcmVsb2FkKCkge1xuICAgICAgICBlbXB0eUVsZW1lbnQodGhpcyk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG5cbiAgICBhZGRSb3cocm93KSB7XG4gICAgICAgIC8vIGFkZCB0byByb3dzXG4gICAgICAgIGNvbnN0IG1hcHBlZFJvdyA9IHRoaXMuX3Jvd01hcChyb3cpO1xuICAgICAgICB0aGlzLnJvd3MudW5zaGlmdChtYXBwZWRSb3cpO1xuXG4gICAgICAgIC8vIGFkIHRvIGh0bWxcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBjb25zdCBodG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZygnPHRhYmxlPicgKyByb3dUZW1wbGF0ZShtYXBwZWRSb3cpICsgJzwvdGFibGU+JywgJ3RleHQvaHRtbCcpO1xuICAgICAgICB0aGlzLnRhYmxlQm9keS5pbnNlcnRCZWZvcmUoaHRtbERvYy5ib2R5LnF1ZXJ5U2VsZWN0b3IoJ3RyJyksIHRoaXMudGFibGVCb2R5LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgdGhpcy5fcmVmKCdjb3VudCcpLmlubmVySFRNTCA9IHBhcnNlSW50KHRoaXMuX3JlZignY291bnQnKS5pbm5lckhUTUwpICsgMTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEMxVGFibGU7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2xpYnMvY29tcG9uZW50JztcbmltcG9ydCB7IGdldERCTWFuYWdlciB9IGZyb20gJy4uLy4uL2xpYnMvZGItbWFuYWdlcic7XG5pbXBvcnQgeyBnZXRTdG9yZU1hbmFnZXIgfSBmcm9tICcuLi8uLi9saWJzL3N0b3JlLW1hbmFnZXInO1xuaW1wb3J0IHsgZW1wdHlFbGVtZW50IH0gZnJvbSAnLi4vLi4vbGlicy91dGlscyc7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi90ZW1wbGF0ZS5oYnMnO1xuXG5jbGFzcyBDMk5hdiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGJNYW5hZ2VyID0gZ2V0REJNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgICB0aGlzLl9hZGRTdG9yZUxpc3RlbmVyKCdwc0NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIF9pbml0KCkge1xuICAgICAgICBjb25zdCBkYXRhID0ge307XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSYWNlID0gZ2V0U3RvcmVNYW5hZ2VyKCkuZ2V0KCdzZWxlY3RlZFJhY2UnKTtcbiAgICAgICAgdGhpcy5yYWNlSWQgPSBzZWxlY3RlZFJhY2UucmFjZTtcblxuICAgICAgICBjb25zdCBwcyA9IGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmdldEFsbFBTKHRoaXMucmFjZUlkKTtcbiAgICAgICAgZGF0YVsncHMnXSA9IHBzO1xuXG4gICAgICAgIC8vIHBhcnNlIGh0bWxcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBjb25zdCBodG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZW1wbGF0ZShkYXRhKSwgJ3RleHQvaHRtbCcpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGh0bWxEb2MuYm9keS5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICAgICAgLy8gYWRkIGxpc3RlbmVyIHRvIGJ1dHRvbnNcbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdzZWxlY3RlZFBhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBidXR0b24uZGF0YXNldC5kZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGJ1dHRvbi5kYXRhc2V0LnRpdGxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBY3RpdmVNZW51KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21lbnVJdGVtJ1xuICAgICAgICApO1xuXG4gICAgICAgIC8vY2hlY2sgYWN0aXZlIGJ1dHRvblxuICAgICAgICB0aGlzLmNoZWNrQWN0aXZlTWVudSgpO1xuICAgIH1cblxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgZW1wdHlFbGVtZW50KHRoaXMpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuXG4gICAgY2hlY2tBY3RpdmVNZW51KCkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZFBhZ2UgPSBnZXRTdG9yZU1hbmFnZXIoKS5nZXQoJ3NlbGVjdGVkUGFnZScpO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHNlbGVjdGVkUGFnZT8uZGVzdGluYXRpb24gfHwgJ2Rhc2hib2FyZCc7XG5cbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5fcmVmKCdtZW51SXRlbScsIHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWVudUl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kYXRhc2V0LmRlc3RpbmF0aW9uID09IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktNDAwJyk7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdib3JkZXItdHJhbnNwYXJlbnQnKTtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3RleHQtZ3JheS04MDAnKTtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2JvcmRlci1ncmF5LTUwMCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3RleHQtZ3JheS00MDAnKTtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2JvcmRlci10cmFuc3BhcmVudCcpO1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTgwMCcpO1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYm9yZGVyLWdyYXktNTAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEMyTmF2O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9saWJzL2NvbXBvbmVudCc7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi90ZW1wbGF0ZS5oYnMnO1xuaW1wb3J0IHsgZW1wdHlFbGVtZW50IH0gZnJvbSAnLi4vLi4vbGlicy91dGlscyc7XG5cbmNsYXNzIEwxQXBwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBwYXJzZSBodG1sXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgY29uc3QgaHRtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGVtcGxhdGUoKSwgJ3RleHQvaHRtbCcpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGh0bWxEb2MuYm9keS5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5fcmVmKCdjb250ZW50Jyk7XG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnc3RhcnQnKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0RWxlbWVudENoaWxkLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktMCcpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cblxuICAgIF9hZGRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2FkZFN0b3JlTGlzdGVuZXIoJ3NlbGVjdGVkUmFjZScsIChwYXRoLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgZW1wdHlFbGVtZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICBpZiAodmFsdWUucmFjZSkgdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICc8bDItbWFpbj48L2wyLW1haW4+JztcbiAgICAgICAgICAgIGVsc2UgdGhpcy5jb250ZW50LmlubmVySFRNTCA9ICc8bTAtcmFjZXI+PC9tMC1yYWNlcj4nO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEwxQXBwO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9saWJzL2NvbXBvbmVudCc7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi90ZW1wbGF0ZS5oYnMnO1xuaW1wb3J0IHsgZ2V0REJNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vbGlicy9kYi1tYW5hZ2VyJztcbmltcG9ydCB7IGVtcHR5RWxlbWVudCB9IGZyb20gJy4uLy4uL2xpYnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0U3RvcmVNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vbGlicy9zdG9yZS1tYW5hZ2VyJztcblxuY2xhc3MgTDJNYWluIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmRiTWFuYWdlciA9IGdldERCTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnN0b3JlTWFuYWdlciA9IGdldFN0b3JlTWFuYWdlcigpO1xuXG4gICAgICAgIHRoaXMuX2FkZFN0b3JlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG5cbiAgICBfYWRkU3RvcmVMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2FkZFN0b3JlTGlzdGVuZXIoJ3NlbGVjdGVkUGFnZScsIChwYXRoLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBlbXB0eUVsZW1lbnQodGhpcy5kYXNoYm9hcmRDb250ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0TG9jYXRpb24oZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmRhc2hib2FyZENvbnRlbnQuaW5uZXJIVE1MID0gbG9jYXRpb24uY29udGVudDtcbiAgICAgICAgICAgIHRoaXMuZGFzaGJvYXJkVGl0bGUuaW5uZXJIVE1MID0gbG9jYXRpb24udGl0bGU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIF9pbml0KCkge1xuICAgICAgICBjb25zdCBjdXJyZW50UGFnZSA9IHRoaXMuc3RvcmVNYW5hZ2VyLmdldCgnc2VsZWN0ZWRQYWdlJyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5fZ2V0TG9jYXRpb24oY3VycmVudFBhZ2UpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBhcnNlIGh0bWxcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBjb25zdCBodG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZW1wbGF0ZShkYXRhKSwgJ3RleHQvaHRtbCcpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGh0bWxEb2MuYm9keS5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICAgICAgLy8gZ2V0IGVsZW1lbnRzXG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzLl9yZWYoJ2Nsb3NlUmFjZScpO1xuICAgICAgICB0aGlzLm1lbnVCdG4gPSB0aGlzLl9yZWYoJ21lbnVCdG4nKTtcbiAgICAgICAgdGhpcy5kcmF3ZXJNZW51ID0gdGhpcy5fcmVmKCdkcmF3ZXJNZW51Jyk7XG4gICAgICAgIHRoaXMubmF2ID0gdGhpcy5fcmVmKCduYXYnKTtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRDb250ZW50ID0gdGhpcy5fcmVmKCdkYXNoYm9hcmRDb250ZW50Jyk7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkVGl0bGUgPSB0aGlzLl9yZWYoJ2Rhc2hib2FyZFRpdGxlJyk7XG5cbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kcmF3ZXJNZW51LmNsYXNzTGlzdC5jb250YWlucygnLWxlZnQtODAnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdlck1lbnUuY2xhc3NMaXN0LmFkZCgnLWxlZnQtODAnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdzZWxlY3RlZFJhY2UnLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMuY2xvc2VcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2VyTWVudS5jbGFzc0xpc3QuY29udGFpbnMoJy1sZWZ0LTgwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3ZXJNZW51LmNsYXNzTGlzdC5yZW1vdmUoJy1sZWZ0LTgwJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3ZXJNZW51LmNsYXNzTGlzdC5hZGQoJy1sZWZ0LTgwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtZW51QnRuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIF9nZXRMb2NhdGlvbihjdXJyZW50UGFnZSkge1xuICAgICAgICBpZiAoIWN1cnJlbnRQYWdlKSByZXR1cm4geyB0aXRsZTogJ0Rhc2hib2FyZCcsIGNvbnRlbnQ6ICc8bTEtZGFzaGJvYXJkPjwvbTEtZGFzaGJvYXJkPicgfTtcblxuICAgICAgICBpZiAoY3VycmVudFBhZ2UuZGVzdGluYXRpb24gPT0gJ3JhY2UnKSByZXR1cm4geyB0aXRsZTogY3VycmVudFBhZ2UudGl0bGUsIGNvbnRlbnQ6ICc8bTItcmFjZT48L20yLXJhY2U+JyB9O1xuICAgICAgICBpZiAoY3VycmVudFBhZ2UuZGVzdGluYXRpb24gPT0gJ3J1bm5lcicpXG4gICAgICAgICAgICByZXR1cm4geyB0aXRsZTogY3VycmVudFBhZ2UudGl0bGUsIGNvbnRlbnQ6ICc8bTMtcnVubmVycz48L20zLXJ1bm5lcnM+JyB9O1xuICAgICAgICBpZiAoY3VycmVudFBhZ2UuZGVzdGluYXRpb24uc3RhcnRzV2l0aCgncHMtJykpXG4gICAgICAgICAgICByZXR1cm4geyB0aXRsZTogY3VycmVudFBhZ2UudGl0bGUsIGNvbnRlbnQ6ICc8bTQtc2NvcmU+PC9tNC1zY29yZT4nIH07XG4gICAgICAgIHJldHVybiB7IHRpdGxlOiAnRGFzaGJvYXJkJywgY29udGVudDogJzxtMS1kYXNoYm9hcmQ+PC9tMS1kYXNoYm9hcmQ+JyB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTDJNYWluO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9saWJzL2NvbXBvbmVudCc7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi90ZW1wbGF0ZS5oYnMnO1xuaW1wb3J0IHJhY2UgZnJvbSAnLi4vLi4vYXNzZXRzL3JhY2Uud2VicCc7XG5pbXBvcnQgeyBnZXREQk1hbmFnZXIgfSBmcm9tICcuLi8uLi9saWJzL2RiLW1hbmFnZXInO1xuXG5jbGFzcyBNMFJhY2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmRiTWFuYWdlciA9IGdldERCTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2luaXQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBpbWc6IHJhY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBhd2FpdCB0aGlzLmRiTWFuYWdlci5nZXRBbGxSYWNlKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcGFyc2UgaHRtbFxuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGNvbnN0IGh0bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRlbXBsYXRlKGRhdGEpLCAndGV4dC9odG1sJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaHRtbERvYy5ib2R5LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgICAgICAvLyBnZXQgZWxlbWVudHNcbiAgICAgICAgdGhpcy5mb3JtQ3JlYXRlID0gdGhpcy5fcmVmKCdjcmVhdGVSYWNlJyk7XG4gICAgICAgIHRoaXMuZm9ybVNlbGVjdCA9IHRoaXMuX3JlZignc2VsZWN0UmFjZScpO1xuXG4gICAgICAgIC8vIGFkZCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgX2FkZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5mb3JtQ3JlYXRlLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHJhY2VOYW1lID0gZm9ybURhdGEuZ2V0KCduYW1lJyk7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmNyZWF0ZVJhY2UocmFjZU5hbWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdzZWxlY3RlZFJhY2UnLCB7IHJhY2U6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZvcm1TZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBmb3JtRGF0YS5nZXQoJ25hbWUnKTtcblxuICAgICAgICAgICAgdGhpcy5fZW1pdCgnc2VsZWN0ZWRSYWNlJywgeyByYWNlOiBpZCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNMFJhY2VyO1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi8uLi9saWJzL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBnZXREQk1hbmFnZXIgfSBmcm9tICcuLi8uLi9saWJzL2RiLW1hbmFnZXInO1xuaW1wb3J0IHsgZm9ybVRvSlNPTiwganNvblRvRm9ybSB9IGZyb20gJy4uLy4uL2xpYnMvZm9ybS10by1qc29uJztcbmltcG9ydCB7IGdldFN0b3JlTWFuYWdlciB9IGZyb20gJy4uLy4uL2xpYnMvc3RvcmUtbWFuYWdlcic7XG5pbXBvcnQgeyBkYXRlVG9TdHIgfSBmcm9tICcuLi8uLi9saWJzL3V0aWxzJztcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlLmhicyc7XG5cbmNsYXNzIE0xRGFzaGJvYXJkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmRiTWFuYWdlciA9IGdldERCTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgICAgLy9hZGQgdGFrZSBldmVudCBsaXN0ZW5lclxuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICd0YWtlLWV2ZW50JyxcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX25ld1RpbWUoZXZlbnQuZGV0YWlsLnRpbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBfaW5pdCgpIHtcbiAgICAgICAgLy8gbG9hZCByYWNlSWRcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSYWNlID0gZ2V0U3RvcmVNYW5hZ2VyKCkuZ2V0KCdzZWxlY3RlZFJhY2UnKTtcbiAgICAgICAgdGhpcy5yYWNlSWQgPSBzZWxlY3RlZFJhY2UucmFjZTtcblxuICAgICAgICAvLyBwYXJzZSBodG1sXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgY29uc3QgaHRtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGVtcGxhdGUoe30pLCAndGV4dC9odG1sJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaHRtbERvYy5ib2R5LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgICAgICAvL2dldCB0YWJsZVxuICAgICAgICB0aGlzLnRpbWVUYWJsZSA9IHRoaXMuX3JlZigndGltZVRhYmxlJyk7XG4gICAgICAgIHRoaXMudGFrZVRhYmxlID0gdGhpcy5fcmVmKCd0YWtlVGFibGUnKTtcbiAgICAgICAgdGhpcy5hc3NpZ25UaW1lID0gdGhpcy5fcmVmKCdhc3NpZ25UaW1lJyk7XG5cbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXNzaWduVGltZShmb3JtVG9KU09OKHRoaXMuYXNzaWduVGltZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXMuYXNzaWduVGltZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGFzeW5jIGdldFJvd3ModHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PSAndGFrZScpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiTWFuYWdlci5nZXRBbGxUYWtlSm9pbih0aGlzLnJhY2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYk1hbmFnZXIuZ2V0QWxsVGltZUpvaW4odGhpcy5yYWNlSWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlUm93KGlkLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09ICd0aW1lJykge1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmdldFRpbWVKb2luKGlkKTtcbiAgICAgICAgICAgIGlmICh0aW1lLmFzc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaW1lIGlzIGFzc2lnbmVkLCBjYW5ub3QgcmVtb3ZlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5kYk1hbmFnZXIuZGVsZXRlVGltZSh7IGlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT0gJ3Rha2UnKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRiTWFuYWdlci5kZWxldGVUYWtlKHsgaWQgfSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVUYWJsZS5yZWxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZWRpdFJvdyhpZCwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PSAndGltZScpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBhd2FpdCB0aGlzLmRiTWFuYWdlci5nZXRUaW1lKGlkKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRpbWUodGltZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBfbmV3VGltZSh0aW1lKSB7XG4gICAgICAgIGlmICghdGhpcy50aW1lVGFibGUpIHJldHVybjtcblxuICAgICAgICAvLyBhZGQgdG8gcm93IHRvIHRhYmxlXG4gICAgICAgIHRoaXMudGltZVRhYmxlPy5hZGRSb3codGltZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9jdXNcbiAgICAgICAgaWYgKHRoaXMuYXNzaWduVGltZS5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNvbmZpZ3VyZSBmb3JtXG4gICAgICAgIHRoaXMuX3NldFRpbWUodGltZSk7XG4gICAgfVxuXG4gICAgX3NldFRpbWUodGltZSkge1xuICAgICAgICAvLyBjb21waWxlIGZvcm1cbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSB7XG4gICAgICAgICAgICAuLi50aW1lLFxuICAgICAgICAgICAgdGltZVN0cjogZGF0ZVRvU3RyKG5ldyBEYXRlKHRpbWUudGltZSksIHRydWUpLFxuICAgICAgICB9O1xuICAgICAgICBqc29uVG9Gb3JtKHRoaXMuYXNzaWduVGltZSwgZm9ybURhdGEpO1xuXG4gICAgICAgIC8vIGZvY3VzXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ25UaW1lLmNsYXNzTGlzdC5yZW1vdmUoJ2JnLWJsdWUtMzAwJyk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICB0aGlzLmFzc2lnblRpbWUuY2xhc3NMaXN0LmFkZCgnYmctYmx1ZS0zMDAnKTtcbiAgICAgICAgdGhpcy5hc3NpZ25UaW1lLnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPXJ1bm5lck51bV0nKS5mb2N1cygpO1xuICAgIH1cblxuICAgIGFzeW5jIF9hc3NpZ25UaW1lKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uLmlkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBhc3NpZ24gdGltZSB3aXRob3V0IGEgVGltZSBJRCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHMgPSBhd2FpdCB0aGlzLmRiTWFuYWdlci5nZXRQU0J5KHsgbmFtZToganNvbi5wc05hbWUsIHJhY2U6IHRoaXMucmFjZUlkIH0pO1xuICAgICAgICBjb25zdCBydW5uZXIgPSBhd2FpdCB0aGlzLmRiTWFuYWdlci5nZXRSdW5uZXJCeSh7IG51bWJlcjoganNvbi5ydW5uZXJOdW0sIHJhY2U6IHRoaXMucmFjZUlkIH0pO1xuXG4gICAgICAgIGlmICghcHMgfHwgIXJ1bm5lcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgZmluZCBQUyBvciBSdW5uZXInKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduVGltZS5jbGFzc0xpc3QucmVtb3ZlKCdiZy1yZWQtMzAwJyk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgIHRoaXMuYXNzaWduVGltZS5jbGFzc0xpc3QuYWRkKCdiZy1yZWQtMzAwJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YWtlID0gYXdhaXQgdGhpcy5kYk1hbmFnZXIuZ2V0VGFrZUJ5KHsgcHM6IHBzLmlkLCBydW5uZXI6IHJ1bm5lci5pZCwgcmFjZTogdGhpcy5yYWNlSWQgfSk7XG4gICAgICAgIGlmICh0YWtlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Rha2UgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgUFMgYW5kIFJ1bm5lcicpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25UaW1lLmNsYXNzTGlzdC5yZW1vdmUoJ2JnLXJlZC0zMDAnKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgdGhpcy5hc3NpZ25UaW1lLmNsYXNzTGlzdC5hZGQoJ2JnLXJlZC0zMDAnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmNyZWF0ZVRha2UoeyB0aW1lOiBqc29uLmlkLCBwczogcHMuaWQsIHJ1bm5lcjogcnVubmVyLmlkLCByYWNlOiB0aGlzLnJhY2VJZCB9KTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXNzaWduVGltZS5jbGFzc0xpc3QucmVtb3ZlKCdiZy1ncmVlbi0zMDAnKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIHRoaXMuYXNzaWduVGltZS5jbGFzc0xpc3QuYWRkKCdiZy1ncmVlbi0zMDAnKTtcbiAgICAgICAgdGhpcy5hc3NpZ25UaW1lLnJlc2V0KCk7XG5cbiAgICAgICAgdGhpcy50YWtlVGFibGUucmVsb2FkKCk7XG4gICAgICAgIHRoaXMudGltZVRhYmxlLnJlbG9hZCgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTTFEYXNoYm9hcmQ7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2xpYnMvY29tcG9uZW50JztcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlLmhicyc7XG5pbXBvcnQgeyBnZXREQk1hbmFnZXIgfSBmcm9tICcuLi8uLi9saWJzL2RiLW1hbmFnZXInO1xuaW1wb3J0IHsgZm9ybVRvSlNPTiB9IGZyb20gJy4uLy4uL2xpYnMvZm9ybS10by1qc29uJztcbmltcG9ydCB7IGdldFN0b3JlTWFuYWdlciB9IGZyb20gJy4uLy4uL2xpYnMvc3RvcmUtbWFuYWdlcic7XG5pbXBvcnQgUGFwYSBmcm9tICdwYXBhcGFyc2UnO1xuaW1wb3J0IHsgcmVhZEZpbGVBc3luYyB9IGZyb20gJy4uLy4uL2xpYnMvdXRpbHMnO1xuXG5jbGFzcyBNMlJhY2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuZGJNYW5hZ2VyID0gZ2V0REJNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBfaW5pdCgpIHtcbiAgICAgICAgLy8gbG9hZCByYWNlSWRcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSYWNlID0gZ2V0U3RvcmVNYW5hZ2VyKCkuZ2V0KCdzZWxlY3RlZFJhY2UnKTtcbiAgICAgICAgdGhpcy5yYWNlSWQgPSBzZWxlY3RlZFJhY2UucmFjZTtcblxuICAgICAgICAvLyBwYXJzZSBodG1sXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgY29uc3QgaHRtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGVtcGxhdGUoe30pLCAndGV4dC9odG1sJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaHRtbERvYy5ib2R5LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgICAgICAvL2dldCB0YWJsZVxuICAgICAgICB0aGlzLnRhYmxlID0gdGhpcy5fcmVmKCd0YWJsZScpO1xuXG4gICAgICAgIC8vYWRkIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfYWRkTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVQcyhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjcmVhdGVQcydcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRQcyhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cGxvYWRQcydcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25sb2FkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2Rvd25sb2FkJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGFzeW5jIF9jcmVhdGVQcyhmb3JtKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSBmb3JtVG9KU09OKGZvcm0pO1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5qc29uLCBzdGFydDogbmV3IERhdGUoanNvbi5zdGFydCkuZ2V0VGltZSgpLCByYWNlOiB0aGlzLnJhY2VJZCB9O1xuICAgICAgICBhd2FpdCB0aGlzLmRiTWFuYWdlci5jcmVhdGVPclVwZGF0ZVBTKGRhdGEpO1xuICAgICAgICB0aGlzLnRhYmxlLnJlbG9hZCgpO1xuICAgICAgICBmb3JtLnJlc2V0KCk7XG5cbiAgICAgICAgdGhpcy5fZW1pdCgncHNDaGFuZ2UnLCB0cnVlKTtcbiAgICB9XG5cbiAgICBhc3luYyBfdXBsb2FkUHMoZm9ybSkge1xuICAgICAgICBjb25zdCBmaWxlcyA9IGZvcm0ucXVlcnlTZWxlY3RvcignW3R5cGU9ZmlsZV0nKS5maWxlcztcbiAgICAgICAgaWYgKCFmaWxlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vY2xlYW5cbiAgICAgICAgYXdhaXQgdGhpcy5kYk1hbmFnZXIuY2xlYW5QUyh7IHJhY2U6IHRoaXMucmFjZUlkIH0pO1xuXG4gICAgICAgIC8vcmVhZCBmaWxlXG4gICAgICAgIGNvbnN0IGYgPSBmaWxlc1swXTtcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGYpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICBjb25zdCBjc3YgPSBkZWNvZGVyLmRlY29kZShhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgLy9yZWFkIGNzdlxuICAgICAgICBjb25zdCByZXN1bHRzID0gUGFwYS5wYXJzZShjc3YsIHtcbiAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9hZGQgaXRlbVxuICAgICAgICBjb25zdCByb3dzID0gcmVzdWx0cy5kYXRhO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRiTWFuYWdlci5jcmVhdGVPclVwZGF0ZVBTKHtcbiAgICAgICAgICAgICAgICAuLi5yb3csXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBhcnNlSW50KHJvdy5zdGFydCksXG4gICAgICAgICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFjZTogdGhpcy5yYWNlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFibGUucmVsb2FkKCk7XG4gICAgICAgIGZvcm0ucmVzZXQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRSb3dzKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYk1hbmFnZXIuZ2V0QWxsUFModGhpcy5yYWNlSWQpO1xuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZVJvdyhpZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRiTWFuYWdlci5kZWxldGVQUyh7IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIF9kb3dubG9hZCgpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IHRoaXMuZ2V0Um93cygpO1xuICAgICAgICBjb25zdCBjc3YgPSBQYXBhLnVucGFyc2Uocm93cyk7XG4gICAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSAnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgKyBjc3Y7XG4gICAgICAgIHdpbmRvdy5vcGVuKGVuY29kZVVSSShjc3ZDb250ZW50KSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNMlJhY2U7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2xpYnMvY29tcG9uZW50JztcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlLmhicyc7XG5pbXBvcnQgeyBnZXREQk1hbmFnZXIgfSBmcm9tICcuLi8uLi9saWJzL2RiLW1hbmFnZXInO1xuaW1wb3J0IHsgZm9ybVRvSlNPTiB9IGZyb20gJy4uLy4uL2xpYnMvZm9ybS10by1qc29uJztcbmltcG9ydCB7IGdldFN0b3JlTWFuYWdlciB9IGZyb20gJy4uLy4uL2xpYnMvc3RvcmUtbWFuYWdlcic7XG5pbXBvcnQgUGFwYSBmcm9tICdwYXBhcGFyc2UnO1xuaW1wb3J0IHsgcmVhZEZpbGVBc3luYyB9IGZyb20gJy4uLy4uL2xpYnMvdXRpbHMnO1xuXG5jbGFzcyBNM1J1bm5lcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuZGJNYW5hZ2VyID0gZ2V0REJNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBfaW5pdCgpIHtcbiAgICAgICAgLy8gbG9hZCByYWNlSWRcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSYWNlID0gZ2V0U3RvcmVNYW5hZ2VyKCkuZ2V0KCdzZWxlY3RlZFJhY2UnKTtcbiAgICAgICAgdGhpcy5yYWNlSWQgPSBzZWxlY3RlZFJhY2UucmFjZTtcblxuICAgICAgICAvLyBwYXJzZSBodG1sXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgY29uc3QgaHRtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGVtcGxhdGUoe30pLCAndGV4dC9odG1sJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaHRtbERvYy5ib2R5LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgICAgICAvL2dldCB0YWJsZVxuICAgICAgICB0aGlzLnRhYmxlID0gdGhpcy5fcmVmKCd0YWJsZScpO1xuXG4gICAgICAgIC8vYWRkIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfYWRkTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVSdW5uZXIoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3JlYXRlUnVubmVyJ1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVyKFxuICAgICAgICAgICAgJ3N1Ym1pdCcsXG4gICAgICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZFJ1bm5lcihldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cGxvYWRSdW5uZXInXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb3dubG9hZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkb3dubG9hZCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBfY3JlYXRlUnVubmVyKGZvcm0pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgLi4uZm9ybVRvSlNPTihmb3JtKSwgcmFjZTogdGhpcy5yYWNlSWQgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5kYk1hbmFnZXIuY3JlYXRlT3JVcGRhdGVSdW5uZXIoZGF0YSk7XG4gICAgICAgIHRoaXMudGFibGUucmVsb2FkKCk7XG4gICAgICAgIGZvcm0ucmVzZXQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBfdXBsb2FkUnVubmVyKGZvcm0pIHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoJ1t0eXBlPWZpbGVdJykuZmlsZXM7XG4gICAgICAgIGlmICghZmlsZXMpIHJldHVybjtcblxuICAgICAgICAvL2NsZWFuXG4gICAgICAgIGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmNsZWFuUnVubmVyKHsgcmFjZTogdGhpcy5yYWNlSWQgfSk7XG5cbiAgICAgICAgLy9yZWFkIGZpbGVcbiAgICAgICAgY29uc3QgZiA9IGZpbGVzWzBdO1xuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoZik7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICAgIGNvbnN0IGNzdiA9IGRlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyKTtcblxuICAgICAgICAvL3JlYWQgY3N2XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBQYXBhLnBhcnNlKGNzdiwge1xuICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICAvL2FkZCBpdGVtXG4gICAgICAgIGNvbnN0IHJvd3MgPSByZXN1bHRzLmRhdGE7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmNyZWF0ZU9yVXBkYXRlUnVubmVyKHsgLi4ucm93LCBpZDogbnVsbCwgcmFjZTogdGhpcy5yYWNlSWQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhYmxlLnJlbG9hZCgpO1xuICAgICAgICBmb3JtLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0Um93cygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmdldEFsbFJ1bm5lcih0aGlzLnJhY2VJZCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlUm93KGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmRlbGV0ZVJ1bm5lcih7IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIF9kb3dubG9hZCgpIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IHRoaXMuZ2V0Um93cygpO1xuICAgICAgICBjb25zdCBjc3YgPSBQYXBhLnVucGFyc2Uocm93cyk7XG4gICAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSAnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgKyBjc3Y7XG4gICAgICAgIHdpbmRvdy5vcGVuKGVuY29kZVVSSShjc3ZDb250ZW50KSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNM1J1bm5lcnM7XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uLy4uL2xpYnMvY29tcG9uZW50JztcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlLmhicyc7XG5pbXBvcnQgeyBnZXREQk1hbmFnZXIgfSBmcm9tICcuLi8uLi9saWJzL2RiLW1hbmFnZXInO1xuaW1wb3J0IHsgZ2V0U3RvcmVNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vbGlicy9zdG9yZS1tYW5hZ2VyJztcbmltcG9ydCBQYXBhIGZyb20gJ3BhcGFwYXJzZSc7XG5cbmNsYXNzIE00U2NvcmUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuZGJNYW5hZ2VyID0gZ2V0REJNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBfaW5pdCgpIHtcbiAgICAgICAgLy8gbG9hZCByYWNlSWRcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSYWNlID0gZ2V0U3RvcmVNYW5hZ2VyKCkuZ2V0KCdzZWxlY3RlZFJhY2UnKTtcbiAgICAgICAgdGhpcy5yYWNlSWQgPSBzZWxlY3RlZFJhY2UucmFjZTtcblxuICAgICAgICBjb25zdCBzZWxlY3RlZFBhZ2UgPSBnZXRTdG9yZU1hbmFnZXIoKS5nZXQoJ3NlbGVjdGVkUGFnZScpO1xuICAgICAgICB0aGlzLnBzSWQgPSBzZWxlY3RlZFBhZ2UuZGVzdGluYXRpb24uc3Vic3RyaW5nKDMpO1xuXG4gICAgICAgIC8vIHBhcnNlIGh0bWxcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBjb25zdCBodG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZW1wbGF0ZSh7fSksICd0ZXh0L2h0bWwnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChodG1sRG9jLmJvZHkuZmlyc3RFbGVtZW50Q2hpbGQpO1xuXG4gICAgICAgIC8vZ2V0IHRhYmxlXG4gICAgICAgIHRoaXMudGFibGUgPSB0aGlzLl9yZWYoJ3RhYmxlJyk7XG5cbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb3dubG9hZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkb3dubG9hZCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRSb3dzKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYk1hbmFnZXIuZ2V0U2NvcmUodGhpcy5wc0lkLCB0aGlzLnJhY2VJZCk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2Rvd25sb2FkKCkge1xuICAgICAgICBjb25zdCByb3dzID0gYXdhaXQgdGhpcy5nZXRSb3dzKCk7XG4gICAgICAgIGNvbnN0IGNzdiA9IFBhcGEudW5wYXJzZShyb3dzKTtcbiAgICAgICAgY29uc3QgY3N2Q29udGVudCA9ICdkYXRhOnRleHQvY3N2O2NoYXJzZXQ9dXRmLTgsJyArIGNzdjtcbiAgICAgICAgd2luZG93Lm9wZW4oZW5jb2RlVVJJKGNzdkNvbnRlbnQpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE00U2NvcmU7XG4iLCJpbXBvcnQgeyBnZXRTdG9yZU1hbmFnZXIgfSBmcm9tICcuL3N0b3JlLW1hbmFnZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjb21wb25lbnQnLCB0cnVlKTsgLy8gdGFnIGN1c3RvbSBlbGVtZW50XG4gICAgICAgIHRoaXMuc3RvcmVNYW5hZ2VyID0gZ2V0U3RvcmVNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuc3RvcmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG5cbiAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU3RvcmVMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfYWRkTGlzdGVuZXIoZXYsIGNiLCBlbCA9ICdyb290Jywgc3RhcnRGcm9tID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vbG9hZCBldmVudHNcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIGV2ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBldmVudHMgPSBbZXZdO1xuICAgICAgICB9IGVsc2UgaWYgKGV2IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGFkZExpc3RlbmVyIGNhbGwnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbG9hZCBlbGVtZW50cyBpZiBuZWNlc3NhcnlcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGlmIChlbCA9PSAncm9vdCcpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gW3RoaXNdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLl9yZWYoZWwsIHRydWUsIHN0YXJ0RnJvbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGVsIGluc3RhbmNlb2YgRG9jdW1lbnQgfHwgZWwgaW5zdGFuY2VvZiBXaW5kb3cpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZWxlbWVudFxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ0V2ZW50IGxpc3RlbmVyIG5vdCBhZGRlZCBkdWUgdG8gbWlzc2luZyBlbGVtZW50JywgZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZExpc3RlbmVyVG8oZWxlbWVudCwgZXZlbnQsIGNiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hZGRMaXN0ZW5lclRvKGVsZW1lbnQsIGV2ZW50LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobGlzdGVuZXIuZXZlbnQsIGxpc3RlbmVyLmNhbGxiYWNrLCBsaXN0ZW5lci5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0b3JlXG4gICAgX2VtaXQocGF0aCwgZGF0YSwgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnN0b3JlTWFuYWdlci5lbWl0KHBhdGgsIGRhdGEsIG1lcmdlKTtcbiAgICB9XG5cbiAgICBfYWRkU3RvcmVMaXN0ZW5lcihtYXRjaCwgY2IpIHtcbiAgICAgICAgdGhpcy5zdG9yZU1hbmFnZXIuYWRkTGlzdGVuZXIobWF0Y2gsIGNiKTtcbiAgICAgICAgdGhpcy5zdG9yZUxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlQWxsU3RvcmVMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdG9yZUxpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5zdG9yZU1hbmFnZXIucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIubWF0Y2gsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZWxlbWVudHMgbWV0aG9kc1xuICAgIF9yZWYobmFtZSwgYWxsID0gZmFsc2UsIHN0YXJ0RnJvbSA9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRFbCA9IHN0YXJ0RnJvbSA/IHN0YXJ0RnJvbSA6IHRoaXM7XG4gICAgICAgIGlmIChhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXJ0RWwucXVlcnlTZWxlY3RvckFsbChgW3JlZj0ke25hbWV9XWApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEVsLnF1ZXJ5U2VsZWN0b3IoYFtyZWY9JHtuYW1lfV1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudEVsZW1lbnQuY2xvc2VzdChgW2NvbXBvbmVudD10cnVlXWApO1xuICAgIH1cbn1cbiIsImltcG9ydCBEZXhpZSBmcm9tICdkZXhpZSc7XG5cbmNsYXNzIERCTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGIgPSBuZXcgRGV4aWUoJ0xpZ2h0cGFzcycpO1xuXG4gICAgICAgIC8vIERlY2xhcmUgdGFibGVzLCBJRHMgYW5kIGluZGV4ZXNcbiAgICAgICAgdGhpcy5kYi52ZXJzaW9uKDUpLnN0b3Jlcyh7XG4gICAgICAgICAgICByYWNlOiAnKytpZCwgbmFtZScsXG4gICAgICAgICAgICBydW5uZXI6ICcrK2lkLCBuYW1lLCBudW1iZXIsIGNhdGVnb3J5LCByYWNlJyxcbiAgICAgICAgICAgIHBzOiAnKytpZCwgbmFtZSwgc3RhcnQsIGdhcCwgb3JkZXIsIHJhY2UnLFxuICAgICAgICAgICAgdGltZTogJysraWQsIHRpbWUsIHJhY2UnLFxuICAgICAgICAgICAgdGFrZTogJysraWQsICZ0aW1lLCBwcywgcnVubmVyLCByYWNlJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8vLy8gUkFDRVxuICAgIGFzeW5jIGNyZWF0ZVJhY2UobmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5yYWNlLmFkZCh7IG5hbWUgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsUmFjZSgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIucmFjZS50b0FycmF5KCk7XG4gICAgfVxuXG4gICAgLy8vLy8gUFNcbiAgICBhc3luYyBnZXRBbGxQUyhyYWNlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnBzLndoZXJlKCdyYWNlJykuZXF1YWxzKHBhcnNlSW50KHJhY2UpKS50b0FycmF5KCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JVcGRhdGVQUyh7IG5hbWUsIGdhcCwgb3JkZXIsIHN0YXJ0LCByYWNlLCBpZCB9KSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIucHMudXBkYXRlKHBhcnNlSW50KGlkKSwge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZ2FwLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXJzZUludChzdGFydCksXG4gICAgICAgICAgICAgICAgb3JkZXIsXG4gICAgICAgICAgICAgICAgcmFjZTogcGFyc2VJbnQocmFjZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnBzLmFkZCh7IG5hbWUsIGdhcCwgc3RhcnQ6IHBhcnNlSW50KHN0YXJ0KSwgb3JkZXIsIHJhY2U6IHBhcnNlSW50KHJhY2UpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlUFMoeyBpZCB9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnBzLmRlbGV0ZShwYXJzZUludChpZCkpO1xuICAgIH1cblxuICAgIGFzeW5jIGNsZWFuUFMoeyByYWNlIH0pIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBhd2FpdCB0aGlzLmRiLnBzLndoZXJlKCdyYWNlJykuZXF1YWxzKHBhcnNlSW50KHJhY2UpKS50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IGlkcyA9IGFycmF5Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLmRiLnBzLmJ1bGtEZWxldGUoaWRzKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRQU0J5KHsgbmFtZSwgcmFjZSB9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnBzLmdldCh7IG5hbWUsIHJhY2U6IHBhcnNlSW50KHJhY2UpIH0pO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gUnVubmVyc1xuICAgIGFzeW5jIGdldFJ1bm5lckJ5KHsgbnVtYmVyLCByYWNlIH0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIucnVubmVyLmdldCh7IG51bWJlcjogcGFyc2VJbnQobnVtYmVyKSwgcmFjZTogcGFyc2VJbnQocmFjZSkgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsUnVubmVyKHJhY2UpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIucnVubmVyLndoZXJlKCdyYWNlJykuZXF1YWxzKHBhcnNlSW50KHJhY2UpKS50b0FycmF5KCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JVcGRhdGVSdW5uZXIoeyBuYW1lLCBudW1iZXIsIGNhdGVnb3J5LCByYWNlLCBpZCB9KSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIucnVubmVyLnVwZGF0ZShwYXJzZUludChpZCksIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG51bWJlcjogcGFyc2VJbnQobnVtYmVyKSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgICAgICAgICByYWNlOiBwYXJzZUludChyYWNlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIucnVubmVyLmFkZCh7IG5hbWUsIG51bWJlcjogcGFyc2VJbnQobnVtYmVyKSwgY2F0ZWdvcnksIHJhY2U6IHBhcnNlSW50KHJhY2UpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlUnVubmVyKHsgaWQgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5ydW5uZXIuZGVsZXRlKHBhcnNlSW50KGlkKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2xlYW5SdW5uZXIoeyByYWNlIH0pIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBhd2FpdCB0aGlzLmRiLnJ1bm5lci53aGVyZSgncmFjZScpLmVxdWFscyhwYXJzZUludChyYWNlKSkudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBpZHMgPSBhcnJheS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5kYi5ydW5uZXIuYnVsa0RlbGV0ZShpZHMpO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gdGltZVxuICAgIGFzeW5jIGdldFRpbWUoaWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIudGltZS5nZXQocGFyc2VJbnQoaWQpKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRBbGxUaW1lKHJhY2UpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIudGltZS53aGVyZSgncmFjZScpLmVxdWFscyhwYXJzZUludChyYWNlKSkudG9BcnJheSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGFkZFRpbWUoeyB0aW1lLCByYWNlIH0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZGIudGltZS5hZGQoeyB0aW1lLCByYWNlOiBwYXJzZUludChyYWNlKSB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVUaW1lKHsgaWQgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi50aW1lLmRlbGV0ZShwYXJzZUludChpZCkpO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gdGFrZVxuICAgIGFzeW5jIGdldFRha2VCeSh7IHBzLCBydW5uZXIsIHJhY2UgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi50YWtlLmdldCh7IHBzOiBwYXJzZUludChwcyksIHJ1bm5lcjogcGFyc2VJbnQocnVubmVyKSwgcmFjZTogcGFyc2VJbnQocmFjZSkgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsVGFrZShyYWNlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnRha2Uud2hlcmUoJ3JhY2UnKS5lcXVhbHMocGFyc2VJbnQocmFjZSkpLnRvQXJyYXkoKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVUYWtlKHsgdGltZSwgcHMsIHJ1bm5lciwgcmFjZSB9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLnRha2UuYWRkKHtcbiAgICAgICAgICAgIHRpbWU6IHBhcnNlSW50KHRpbWUpLFxuICAgICAgICAgICAgcHM6IHBhcnNlSW50KHBzKSxcbiAgICAgICAgICAgIHJ1bm5lcjogcGFyc2VJbnQocnVubmVyKSxcbiAgICAgICAgICAgIHJhY2U6IHBhcnNlSW50KHJhY2UpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVUYWtlKHsgaWQgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi50YWtlLmRlbGV0ZShwYXJzZUludChpZCkpO1xuICAgIH1cblxuICAgIGFzeW5jIGNsZWFuVGFrZSh7IHJhY2UgfSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IGF3YWl0IHRoaXMuZGIudGFrZS53aGVyZSgncmFjZScpLmVxdWFscyhwYXJzZUludChyYWNlKSkudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBpZHMgPSBhcnJheS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5kYi50YWtlLmJ1bGtEZWxldGUoaWRzKTtcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIHNwZWNpYWxcbiAgICBhc3luYyBnZXRUaW1lSm9pbihpZCkge1xuICAgICAgICBjb25zdCB0aW1lID0gYXdhaXQgdGhpcy5kYi50aW1lLmdldChwYXJzZUludChpZCkpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZGIudGFrZS53aGVyZSgndGltZScpLmVxdWFscyh0aW1lLmlkKS50b0FycmF5KCk7XG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQubGVuZ3RoID09IDApIHJldHVybiB7IC4uLnRpbWUgfTtcbiAgICAgICAgY29uc3QgcnVubmVyID0gYXdhaXQgdGhpcy5kYi5ydW5uZXIuZ2V0KGZvdW5kWzBdLnJ1bm5lcik7XG4gICAgICAgIGlmICghcnVubmVyKSByZXR1cm4geyAuLi50aW1lIH07XG4gICAgICAgIHJldHVybiB7IC4uLnRpbWUsIGFzc2lnbmVkOiBydW5uZXIubnVtYmVyLCBhc3NpZ25lZE5hbWU6IHJ1bm5lci5uYW1lIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsVGltZUpvaW4ocmFjZSwgb25seU5vdEFzc2lnbmVkID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRpbWVzID0gYXdhaXQgdGhpcy5nZXRBbGxUaW1lKHJhY2UpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0aW1lcy5tYXAoYXN5bmMgKHRpbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZGIudGFrZS53aGVyZSgndGltZScpLmVxdWFscyh0aW1lLmlkKS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5sZW5ndGggPT0gMCkgcmV0dXJuIHRpbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmVyID0gYXdhaXQgdGhpcy5kYi5ydW5uZXIuZ2V0KGZvdW5kWzBdLnJ1bm5lcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcHMgPSBhd2FpdCB0aGlzLmRiLnBzLmdldChmb3VuZFswXS5wcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFydW5uZXIgfHwgIXBzKSByZXR1cm4geyAuLi50aW1lIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4udGltZSwgYXNzaWduZWQ6IHJ1bm5lci5udW1iZXIsIGFzc2lnbmVkTmFtZTogcnVubmVyLm5hbWUsIGFzc2lnbmVkUHM6IHBzLm5hbWUgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9ubHlOb3RBc3NpZ25lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcigoaXRlbSkgPT4gIWl0ZW0uYXNzaWduZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRBbGxUYWtlSm9pbihyYWNlKSB7XG4gICAgICAgIGNvbnN0IHRha2VzID0gYXdhaXQgdGhpcy5nZXRBbGxUYWtlKHJhY2UpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHRha2VzLm1hcChhc3luYyAodGFrZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBhd2FpdCB0aGlzLmRiLnRpbWUuZ2V0KHRha2UudGltZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVubmVyID0gYXdhaXQgdGhpcy5kYi5ydW5uZXIuZ2V0KHRha2UucnVubmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcyA9IGF3YWl0IHRoaXMuZGIucHMuZ2V0KHRha2UucHMpO1xuICAgICAgICAgICAgICAgIGlmICghcnVubmVyIHx8ICFwcyB8fCAhdGltZSkgcmV0dXJuIHsgLi4udGFrZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRha2UsXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkSWRUaW1lOiB0aW1lLmlkLFxuICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZFRpbWU6IHRpbWUudGltZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduZWQ6IHJ1bm5lci5udW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkTmFtZTogcnVubmVyLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkUHM6IHBzLm5hbWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRTY29yZShwc0lkLCByYWNlKSB7XG4gICAgICAgIGNvbnN0IHBzID0gYXdhaXQgdGhpcy5kYi5wcy5nZXQocGFyc2VJbnQocHNJZCkpO1xuICAgICAgICBpZiAoIXBzKSByZXR1cm4gW107XG4gICAgICAgIGxldCBydW5uZXJzID0gYXdhaXQgdGhpcy5kYi5ydW5uZXIud2hlcmUoJ3JhY2UnKS5lcXVhbHMocGFyc2VJbnQocmFjZSkpLnRvQXJyYXkoKTtcbiAgICAgICAgaWYgKCFydW5uZXJzKSByZXR1cm4gW107XG5cbiAgICAgICAgLy8gc29ydCBydW5uZXJzIGJ5IHBzIGRpcmVjdGlvblxuICAgICAgICBydW5uZXJzID0gcnVubmVycy5zb3J0KChvbmUsIHR3bykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBzLmRpcmVjdGlvbiA9PSAnYXNjJyA/IG9uZSA6IHR3bztcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwcy5kaXJlY3Rpb24gPT0gJ2FzYycgPyB0d28gOiBvbmU7XG5cbiAgICAgICAgICAgIGlmIChhLm51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYi5udW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGEubnVtYmVyIDwgYi5udW1iZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYS5udW1iZXIgPj0gYi5udW1iZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9pdGVyYXRlIGFuZCBjcmVhdGUgZmluYWwgb2JqZWN0XG4gICAgICAgIGxldCBzdGFydCA9IG5ldyBEYXRlKHBzLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgZ2FwID0gcGFyc2VJbnQocHMuZ2FwKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcnVubmVyIG9mIHJ1bm5lcnMpIHtcbiAgICAgICAgICAgIC8vIGdldCBkaWZmXG4gICAgICAgICAgICBsZXQgZGlmZiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZW5kID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBhd2FpdCB0aGlzLmdldFRha2VCeSh7IHBzOiBwcy5pZCwgcnVubmVyOiBydW5uZXIuaWQsIHJhY2U6IHJhY2UgfSk7XG4gICAgICAgICAgICBpZiAodGFrZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBhd2FpdCB0aGlzLmdldFRpbWUodGFrZS50aW1lKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZSh0aW1lLnRpbWUpO1xuICAgICAgICAgICAgICAgIGRpZmYgPSBuZXcgRGF0ZShlbmQuZ2V0VGltZSgpIC0gc3RhcnQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgLi4ucnVubmVyLCBwczogcHMubmFtZSwgc3RhcnQ6IHN0YXJ0LmdldFRpbWUoKSwgZW5kOiBlbmQ/LmdldFRpbWUoKSwgZGlmZjogZGlmZj8uZ2V0VGltZSgpIH0pO1xuXG4gICAgICAgICAgICAvLyBuZXh0IHN0YXJ0XG4gICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0LmdldFRpbWUoKSArIGdhcCAqIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vIEdMT0JBTFxuICAgIGFzeW5jIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmRiLnRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICAgICAgdGFibGUuY2xlYXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHtEeW5hbWljUmVnaXN0ZXJ9IHRoZSByZWdpc3RlclxuICovXG5leHBvcnQgY29uc3QgZ2V0REJNYW5hZ2VyID0gKCkgPT4ge1xuICAgIGlmICghd2luZG93LnJjRGJNYW5hZ2VyKSB7XG4gICAgICAgIHdpbmRvdy5yY0RiTWFuYWdlciA9IG5ldyBEQk1hbmFnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5yY0RiTWFuYWdlcjtcbn07XG4iLCJpbXBvcnQgeyBnZXREQk1hbmFnZXIgfSBmcm9tICcuL2RiLW1hbmFnZXInO1xuaW1wb3J0IHsgZ2V0U3RvcmVNYW5hZ2VyIH0gZnJvbSAnLi9zdG9yZS1tYW5hZ2VyJztcblxuY2xhc3MgRXZlbnRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuRXZlbnRTb3VyY2UpIHRocm93ICdDYW5ub3Qgc3RhcnQgbGlnaHRwYXNzIEV2ZW50U2VydmljZSwgd2luZG93LkV2ZW50U291cmNlIG5lZWQgdG8gYmUgZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvZXZlbnRzJyk7XG4gICAgICAgIHRoaXMuaW5pdERhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRNaWxsaXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZGJNYW5hZ2VyID0gZ2V0REJNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuc3RvcmVNYW5hZ2VyID0gZ2V0U3RvcmVNYW5hZ2VyKCk7XG5cbiAgICAgICAgdGhpcy5fYWRkU291cmNlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX2FkZEZha2VMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfYWRkU291cmNlTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ29wZW4nLFxuICAgICAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTGlnaHRwYXNzIHNlbnNvciBDb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBnZXRTdG9yZU1hbmFnZXIoKS5lbWl0KCdldmVudHMnLCB7IG9rOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldC5yZWFkeVN0YXRlICE9IEV2ZW50U291cmNlLk9QRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xpZ2h0cGFzcyBzZW5zb3IgRGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGdldFN0b3JlTWFuYWdlcigpLmVtaXQoJ2V2ZW50cycsIHsgb2s6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAnaW5pdC1ldmVudCcsXG4gICAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRFdmVudChlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAndGFrZS1ldmVudCcsXG4gICAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rha2VFdmVudChlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc3RvcmVNYW5hZ2VyLmFkZExpc3RlbmVyKCdzZWxlY3RlZFJhY2UnLCAocGF0aCwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yYWNlSWQgPSBkYXRhLnJhY2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hZGRGYWtlTGlzdGVuZXJzKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT0gJ0JyYWNrZXRSaWdodCcpIHRoaXMuX3NlbmRFdmVudChuZXcgRGF0ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2luaXRFdmVudChlKSB7XG4gICAgICAgIHRoaXMuaW5pdERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmluaXRNaWxsaXMgPSBlLmRhdGE7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYEluaXRpYWxpemVkIGV2ZW50cyBhdCAke3RoaXMuaW5pdERhdGV9ICgke3RoaXMuaW5pdERhdGUuZ2V0VGltZSgpfSkgd2l0aCBtaWxsaXMgJHt0aGlzLmluaXRNaWxsaXN9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIF90YWtlRXZlbnQoZSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdERhdGUgfHwgIXRoaXMuaW5pdE1pbGxpcykgdGhyb3cgJ01pc3NpbmcgaW5pdCBldmVudCc7XG5cbiAgICAgICAgY29uc3QgbmV3RGF0ZU1pbGxpcyA9IHRoaXMuaW5pdERhdGUuZ2V0VGltZSgpICsgKGUuZGF0YSAtIHRoaXMuaW5pdE1pbGxpcyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUobmV3RGF0ZU1pbGxpcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUYWtlZCBldmVudCBhdCAke2N1cnJlbnREYXRlfSAoJHtjdXJyZW50RGF0ZS5nZXRUaW1lKCl9KSB3aXRoIG1pbGxpcyAke2UuZGF0YX1gKTtcblxuICAgICAgICB0aGlzLl9zZW5kRXZlbnQoY3VycmVudERhdGUpO1xuICAgIH1cblxuICAgIGFzeW5jIF9zZW5kRXZlbnQodGFrZWREYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5yYWNlSWQpIGNvbnNvbGUud2FybignUGxlYXNlIHNlbGVjdCBhIHJhY2UnKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgUHJvcGFnYXRlZCBldmVudCBmb3IgcmFjZSAke3RoaXMucmFjZUlkfSB3aXRoIGRhdGUgJHt0YWtlZERhdGV9ICgke3Rha2VkRGF0ZS5nZXRUaW1lKCl9KWApO1xuICAgICAgICBjb25zdCB0aW1lID0gYXdhaXQgdGhpcy5kYk1hbmFnZXIuYWRkVGltZSh7IHRpbWU6IHRha2VkRGF0ZS5nZXRUaW1lKCksIHJhY2U6IHRoaXMucmFjZUlkIH0pO1xuICAgICAgICBjb25zdCB0aW1lRGF0YSA9IGF3YWl0IHRoaXMuZGJNYW5hZ2VyLmdldFRpbWVKb2luKHRpbWUpO1xuICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgQ3VzdG9tRXZlbnQoJ3Rha2UtZXZlbnQnLCB7IGRldGFpbDogeyB0aW1lOiB0aW1lRGF0YSB9IH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmRpc3BhdGNoRXZlbnQoY3VzdG9tKTtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm5zIHtFdmVudFNlcnZpY2V9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFdmVudFNlcnZpY2UgPSAoKSA9PiB7XG4gICAgaWYgKCF3aW5kb3cucmNFdmVudFNlcnZpY2UpIHtcbiAgICAgICAgd2luZG93LnJjRXZlbnRTZXJ2aWNlID0gbmV3IEV2ZW50U2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LnJjRXZlbnRTZXJ2aWNlO1xufTtcbiIsIi8qKlxuICogQ2hlY2tzIHRoYXQgYW4gZWxlbWVudCBoYXMgYSBub24tZW1wdHkgYG5hbWVgXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtZW50ICB0aGUgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbH0gICAgICAgICAgICAgdHJ1ZSBpZiB0aGUgaGFzIGEgbmFtZVxuICovXG5jb25zdCBpc1ZhbGlkRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuICEhZWxlbWVudC5uYW1lO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCBhbiBlbGVtZW50IGhhcyBhIG5vbi1lbXB0eSBgdmFsdWVgIHByb3BlcnR5LlxuICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCAgdGhlIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2x9ICAgICAgICAgICAgIHRydWUgaWYgdGhlIGVsZW1lbnQgaGFzIGEgbm9uIGVtcHR5IHZhbHVlXG4gKi9cbmNvbnN0IGhhc1ZhbHVlID0gKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gISFlbGVtZW50LnZhbHVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZWxlbWVudOKAmXMgdmFsdWUgY2FuIGJlIHNhdmVkIChlLmcuIG5vdCBhbiB1bnNlbGVjdGVkIGNoZWNrYm94KS5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgIHRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICB0cnVlIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgYWRkZWQsIGZhbHNlIGlmIG5vdFxuICovXG5jb25zdCBpc1ZhbGlkVmFsdWUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiAhWydjaGVja2JveCcsICdyYWRpbyddLmluY2x1ZGVzKGVsZW1lbnQudHlwZSkgfHwgZWxlbWVudC5jaGVja2VkO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gaW5wdXQgaXMgYSBjaGVja2JveCwgYmVjYXVzZSBjaGVja2JveGVzIGFsbG93IG11bHRpcGxlIHZhbHVlcy5cbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgIHRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGEgY2hlY2tib3gsIGZhbHNlIGlmIG5vdFxuICovXG5jb25zdCBpc0NoZWNrYm94ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94JztcblxuY29uc3QgaXNSYWRpbyA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdyYWRpbyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGlucHV0IGlzIGEgYHNlbGVjdGAgd2l0aCB0aGUgYG11bHRpcGxlYCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtZW50ICB0aGUgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBhIG11bHRpc2VsZWN0LCBmYWxzZSBpZiBub3RcbiAqL1xuY29uc3QgaXNNdWx0aVNlbGVjdCA9IChlbGVtZW50KSA9PiBlbGVtZW50Lm9wdGlvbnMgJiYgZWxlbWVudC5tdWx0aXBsZTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNlbGVjdGVkIG9wdGlvbnMgZnJvbSBhIG11bHRpLXNlbGVjdCBhcyBhbiBhcnJheS5cbiAqIEBwYXJhbSAge0hUTUxPcHRpb25zQ29sbGVjdGlvbn0gb3B0aW9ucyAgdGhlIG9wdGlvbnMgZm9yIHRoZSBzZWxlY3RcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2Ygc2VsZWN0ZWQgb3B0aW9uIHZhbHVlc1xuICovXG5jb25zdCBnZXRTZWxlY3RWYWx1ZXMgPSAob3B0aW9ucykgPT5cbiAgICBbXS5yZWR1Y2UuY2FsbChcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKHZhbHVlcywgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLnNlbGVjdGVkID8gdmFsdWVzLmNvbmNhdChvcHRpb24udmFsdWUpIDogdmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBbXVxuICAgICk7XG5cbi8qKlxuICogUmV0cmlldmVzIGlucHV0IGRhdGEgZnJvbSBhIGZvcm0gYW5kIHJldHVybnMgaXQgYXMgYSBKU09OIG9iamVjdC5cbiAqIEBwYXJhbSAge0hUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9ufSBlbGVtZW50cyAgdGhlIGZvcm0gZWxlbWVudHNcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGluY2x1ZGVFbXB0eSAgICAgICAgICAgICAgICAgaW5jbHVkZSBlbXB0eSBmaWVsZHMgZmxhZ1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtIGRhdGEgYXMgYW4gb2JqZWN0IGxpdGVyYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGZvcm1Ub0pTT04gPSAoZWxlbWVudHMsIGluY2x1ZGVFbXB0eSA9IGZhbHNlKSA9PiB7XG4gICAgcmV0dXJuIFtdLnJlZHVjZS5jYWxsKFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgKGRhdGEsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBoYXMgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHNob3VsZCBiZSBhZGRlZC5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChlbGVtZW50KSAmJiAoaGFzVmFsdWUoZWxlbWVudCkgfHwgaW5jbHVkZUVtcHR5KSAmJiBpc1ZhbGlkVmFsdWUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFNvbWUgZmllbGRzIGFsbG93IGZvciBtb3JlIHRoYW4gb25lIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoaXNcbiAgICAgICAgICAgICAgICAgKiBpcyBvbmUgb2YgdGhvc2UgZmllbGRzIGFuZCwgaWYgc28sIHN0b3JlIHRoZSB2YWx1ZXMgYXMgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tib3goZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LnZhbHVlID09ICd0cnVlJyA/IHRydWUgOiBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbZWxlbWVudC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtlbGVtZW50Lm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2VsZW1lbnQubmFtZV0gPSBbdmFsdWVdLnB1c2goZGF0YVtlbGVtZW50Lm5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSYWRpbyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2VsZW1lbnQubmFtZV0gPSBlbGVtZW50LnZhbHVlID09ICd0cnVlJyA/IHRydWUgOiBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNdWx0aVNlbGVjdChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2VsZW1lbnQubmFtZV0gPSBnZXRTZWxlY3RWYWx1ZXMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtlbGVtZW50Lm5hbWVdID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAge31cbiAgICApO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgaW5wdXQgZGF0YSBmcm9tIGEgZm9ybSBhbmQgcmV0dXJucyBpdCBhcyBhIEpTT04gb2JqZWN0LlxuICogQHBhcmFtICB7SFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb259IGVsZW1lbnRzICB0aGUgZm9ybSBlbGVtZW50c1xuICogQHBhcm0ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbiBkYXRhIGFzIGFuIG9iamVjdCBsaXRlcmFsXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IGlnbm9yZSBlbGVtZW50cyB0byBpZ25vcmUgZHVyaW5nIGZvcm0gc2V0XG4gKi9cbmV4cG9ydCBjb25zdCBqc29uVG9Gb3JtID0gKGZvcm0sIGpzb24sIGlnbm9yZSkgPT4ge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBmb3JtLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaWdub3JlICYmIGlnbm9yZS5pbmRleE9mKGVsZW1lbnQpID49IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgICAgIGNvbnN0IHZhbHVlID1cbiAgICAgICAgICAgIHR5cGVvZiBqc29uW25hbWVdID09ICdib29sZWFuJyA/ICcnICsganNvbltuYW1lXSA6IHR5cGVvZiBqc29uW25hbWVdID09ICd1bmRlZmluZWQnID8gJycgOiBqc29uW25hbWVdO1xuICAgICAgICBpZiAoaXNDaGVja2JveChlbGVtZW50KSkge1xuICAgICAgICAgICAgZWxlbWVudC5jaGVja2VkID0gdmFsdWUgJiYgZWxlbWVudC52YWx1ZSAmJiAodmFsdWUgPT0gZWxlbWVudC52YWx1ZSB8fCB2YWx1ZS5pbmRleE9mKGVsZW1lbnQudmFsdWUpID49IDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmFkaW8oZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IHZhbHVlICYmIGVsZW1lbnQudmFsdWUgJiYgKHZhbHVlID09IGVsZW1lbnQudmFsdWUgfHwgdmFsdWUuaW5kZXhPZihlbGVtZW50LnZhbHVlKSA+PSAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc011bHRpU2VsZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBlbGVtZW50Lm9wdGlvbnMuZWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUgPT0gZWxlbWVudC52YWx1ZSB8fCB2YWx1ZS5pbmRleE9mKG9wdGlvbi52YWx1ZSkgPj0gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImV4cG9ydCBjbGFzcyBTdG9yZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJvb3RFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5zdG9yZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jYnMgPSB7fTtcbiAgICB9XG5cbiAgICBfY2hlY2tJbml0KGluaXRpYWxTdG9yZSkge1xuICAgICAgICBpZiAoIWluaXRpYWxTdG9yZSB8fCBpbml0aWFsU3RvcmUgPT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc3RvcmVzID0gdHlwZW9mIGluaXRpYWxTdG9yZSA9PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoaW5pdGlhbFN0b3JlKSA6IGluaXRpYWxTdG9yZTtcbiAgICAgICAgZm9yICh2YXIgc3Qgb2YgT2JqZWN0LmtleXMoc3RvcmVzKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHN0LCBzdG9yZXNbc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6YXRlZCBzdG9yZSBtYW5hZ2VyJyk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXIobWF0Y2gsIGNiKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHAgPyBtYXRjaCA6IG5ldyBSZWdFeHAoJ14nICsgbWF0Y2ggKyAnLiokJyk7XG4gICAgICAgIGNvbnN0IGZGbiA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0aENoYW5nZWQgPSBldmVudC5kZXRhaWwucGF0aDtcbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHBhdGhDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIGNiKHBhdGhDaGFuZ2VkLCBldmVudC5kZXRhaWwubmV3RGF0YSwgZXZlbnQuZGV0YWlsLm9sZERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucm9vdEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2VjU3RvcmVDaGFuZ2UnLCBmRm4pO1xuICAgICAgICB0aGlzLmNic1tjYl0gPSBmRm47XG5cbiAgICAgICAgLy8gY2hlY2sgcHJlLWluaXRcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgT2JqZWN0LmtleXModGhpcy5zdG9yZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3Qoc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKHN0LCB0aGlzLnN0b3Jlc1tzdF0sIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlTGlzdGVuZXIobWF0Y2gsIGNiKSB7XG4gICAgICAgIGNvbnN0IGZGbiA9IHRoaXMuY2JzW2NiXTtcbiAgICAgICAgdGhpcy5yb290RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZWNTdG9yZUNoYW5nZScsIGZGbik7XG4gICAgfVxuXG4gICAgZW1pdEluY3JlbWVudChwYXRoKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmVjTG9va3VwKHRoaXMuc3RvcmVzLCBwYXRoKTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gMDtcbiAgICAgICAgaWYgKCFvbGRWYWx1ZSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdWYWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvbGRWYWx1ZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQocGF0aCwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIGVtaXREZWNyZW1lbnQocGF0aCkge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3JlY0xvb2t1cCh0aGlzLnN0b3JlcywgcGF0aCk7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IDA7XG4gICAgICAgIGlmICghb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld1ZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdChwYXRoLCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgZW1pdFRvZ2dsZShwYXRoKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmVjTG9va3VwKHRoaXMuc3RvcmVzLCBwYXRoKTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gIW9sZFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KHBhdGgsIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICBlbWl0KHBhdGgsIGRhdGEsIG1lcmdlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb2xkRGF0YSA9IHRoaXMuX3JlY0xvb2t1cCh0aGlzLnN0b3JlcywgcGF0aCkgfHwge307XG4gICAgICAgIGxldCBuZXdEYXRhID0gZGF0YTtcbiAgICAgICAgaWYgKG1lcmdlICYmIHR5cGVvZiBkYXRhID09ICdvYmplY3QnICYmIHR5cGVvZiBvbGREYXRhID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBuZXdEYXRhID0geyAuLi5vbGREYXRhLCAuLi5kYXRhIH07XG4gICAgICAgIH1cblxuICAgICAgICAvL3NldCBzdG9yZVxuICAgICAgICB0aGlzLnN0b3JlcyA9IHRoaXMuX3JlY1NldHVwKHRoaXMuc3RvcmVzLCBwYXRoLCBuZXdEYXRhKTtcblxuICAgICAgICAvL3NlbmQgZXZlbnRcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdlY1N0b3JlQ2hhbmdlJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBvbGREYXRhLFxuICAgICAgICAgICAgICAgIG5ld0RhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb290RWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoYENoYW5nZWQgc3RvcmUgXCIke3BhdGh9XCIgdG9gLCBuZXdEYXRhKTtcbiAgICB9XG5cbiAgICBnZXQocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjTG9va3VwKHRoaXMuc3RvcmVzLCBwYXRoKTtcbiAgICB9XG5cbiAgICBfcmVjTG9va3VwKG9iaiwgcGF0aCkge1xuICAgICAgICBpZiAoIW9iaikgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbcGFydHNbMF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWNMb29rdXAob2JqW3BhcnRzWzBdXSwgcGFydHMuc2xpY2UoMSkuam9pbignLycpKTtcbiAgICB9XG5cbiAgICBfcmVjU2V0dXAob2JqLCBwYXRoLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IG5PYmogPSBvYmo7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBsZXQgaU9iaiA9IG9ialtwYXJ0c1swXV0gPyBvYmpbcGFydHNbMF1dIDoge307XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBuT2JqW3BhcnRzWzBdXSA9IHRoaXMuX3JlY1NldHVwKGlPYmosIHBhcnRzLnNsaWNlKDEpLmpvaW4oJy8nKSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuT2JqW3BhcnRzWzBdXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5PYmo7XG4gICAgfVxufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJucyB7U3RvcmVNYW5hZ2VyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0U3RvcmVNYW5hZ2VyID0gKCkgPT4ge1xuICAgIGlmICghd2luZG93LnJjU3RvcmVNYW5hZ2VyKSB7XG4gICAgICAgIHdpbmRvdy5yY1N0b3JlTWFuYWdlciA9IG5ldyBTdG9yZU1hbmFnZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5yY1N0b3JlTWFuYWdlcjtcbn07XG4iLCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLyBQUk9NSVNJRlkgRVZFTlRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGJ1aWxkV2FpdEZvckV2ZW50ID0gKGV2ZW50TmFtZSkgPT4gKG5vZGUsIGZ1bmMpID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyByZWplY3QgZm9yIGludmFsaWQgbm9kZVxuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCd0YWlsLWVuZDogYW4gSFRNTCBvciBTVkcgZWxlbWVudCBpcyByZXF1aXJlZC4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHVuYmluZCB0aGUgaGFuZGxlclxuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAvLyByZXNvbHZlIHRoZSAobm93IGNsZWFuKSBub2RlXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShub2RlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBiaW5kIHRoZSBoYW5kbGVyXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuXG4gICAgICAgIC8vIGlmIGl0IGV4aXN0cywgY2FsbCB0aGUgZnVuY3Rpb24gcGFzc2luZyBpbiB0aGUgbm9kZVxuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZnVuYyhub2RlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8gUFJPTUlTSUZZIEFOSU1BVElPTkVORCAtIFRSQU5TSVRJT05FTkRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbkVuZCA9IGJ1aWxkV2FpdEZvckV2ZW50KCdhbmltYXRpb25lbmQnKTtcbmV4cG9ydCBjb25zdCB0cmFuc2l0aW9uRW5kID0gYnVpbGRXYWl0Rm9yRXZlbnQoJ3RyYW5zaXRpb25lbmQnKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8gREVMQVlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGRlbGF5ID0gKG1zKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLyBORVhUIFBSRVYgU0lCTElOR1Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGdldE5leHRTaWJsaW5nID0gZnVuY3Rpb24gKGVsZW0sIHNlbGVjdG9yKSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IHNpYmxpbmcgZWxlbWVudFxuICAgIHZhciBzaWJsaW5nID0gZWxlbS5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIHNlbGVjdG9yLCByZXR1cm4gdGhlIGZpcnN0IHNpYmxpbmdcbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gc2libGluZztcblxuICAgIC8vIElmIHRoZSBzaWJsaW5nIG1hdGNoZXMgb3VyIHNlbGVjdG9yLCB1c2UgaXRcbiAgICAvLyBJZiBub3QsIGp1bXAgdG8gdGhlIG5leHQgc2libGluZyBhbmQgY29udGludWUgdGhlIGxvb3BcbiAgICB3aGlsZSAoc2libGluZykge1xuICAgICAgICBpZiAoc2libGluZy5tYXRjaGVzICYmIHNpYmxpbmcubWF0Y2hlcyhzZWxlY3RvcikpIHJldHVybiBzaWJsaW5nO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFByZXZTaWJsaW5nID0gZnVuY3Rpb24gKGVsZW0sIHNlbGVjdG9yKSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IHNpYmxpbmcgZWxlbWVudFxuICAgIHZhciBzaWJsaW5nID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBzZWxlY3RvciwgcmV0dXJuIHRoZSBmaXJzdCBzaWJsaW5nXG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIHNpYmxpbmc7XG5cbiAgICAvLyBJZiB0aGUgc2libGluZyBtYXRjaGVzIG91ciBzZWxlY3RvciwgdXNlIGl0XG4gICAgLy8gSWYgbm90LCBqdW1wIHRvIHRoZSBuZXh0IHNpYmxpbmcgYW5kIGNvbnRpbnVlIHRoZSBsb29wXG4gICAgd2hpbGUgKHNpYmxpbmcpIHtcbiAgICAgICAgaWYgKHNpYmxpbmcubWF0Y2hlcyAmJiBzaWJsaW5nLm1hdGNoZXMoc2VsZWN0b3IpKSByZXR1cm4gc2libGluZztcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0TmV4dFNpYmxpbmdBbGwgPSBmdW5jdGlvbiAoZWxlbSwgc2VsZWN0b3IpIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgc2libGluZyBlbGVtZW50XG4gICAgbGV0IHNpYmxpbmcgPSBlbGVtLm5leHRFbGVtZW50U2libGluZztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgLy8gSWYgdGhlIHNpYmxpbmcgbWF0Y2hlcyBvdXIgc2VsZWN0b3IsIHVzZSBpdFxuICAgIC8vIElmIG5vdCwganVtcCB0byB0aGUgbmV4dCBzaWJsaW5nIGFuZCBjb250aW51ZSB0aGUgbG9vcFxuICAgIHdoaWxlIChzaWJsaW5nKSB7XG4gICAgICAgIGlmIChzaWJsaW5nLm1hdGNoZXMgJiYgc2libGluZy5tYXRjaGVzKHNlbGVjdG9yKSkgcmVzdWx0LnB1c2goc2libGluZyk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRQcmV2U2libGluZ0FsbCA9IGZ1bmN0aW9uIChlbGVtLCBzZWxlY3Rvcikge1xuICAgIC8vIEdldCB0aGUgbmV4dCBzaWJsaW5nIGVsZW1lbnRcbiAgICBsZXQgc2libGluZyA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgLy8gSWYgdGhlIHNpYmxpbmcgbWF0Y2hlcyBvdXIgc2VsZWN0b3IsIHVzZSBpdFxuICAgIC8vIElmIG5vdCwganVtcCB0byB0aGUgbmV4dCBzaWJsaW5nIGFuZCBjb250aW51ZSB0aGUgbG9vcFxuICAgIHdoaWxlIChzaWJsaW5nKSB7XG4gICAgICAgIGlmIChzaWJsaW5nLm1hdGNoZXMgJiYgc2libGluZy5tYXRjaGVzKHNlbGVjdG9yKSkgcmVzdWx0LnB1c2goc2libGluZyk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLyBGSVJTVCBBTkQgTEFTVCBDSElMRFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY29uc3QgZ2V0Rmlyc3RDaGlsZCA9IGZ1bmN0aW9uIChlbGVtLCBzZWxlY3Rvcikge1xuICAgIC8vIEdldCB0aGUgZmlyc3QgY2hpbGQgZWxlbWVudFxuICAgIHZhciBub2RlcyA9IGVsZW0uY2hpbGRyZW47XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA8PSAwKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIHNlbGVjdG9yLCByZXR1cm4gdGhlIGZpcnN0IHNpYmxpbmdcbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gbm9kZXNbMF07XG5cbiAgICAvLyBJZiB0aGUgY2hpbGQgbm9kZSBtYXRjaGVzIG91ciBzZWxlY3RvciwgdXNlIGl0XG4gICAgLy8gSWYgbm90LCBqdW1wIHRvIHRoZSBuZXh0IGNoaWxkIGFuZCBjb250aW51ZSB0aGUgbG9vcFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGVzW2ldLm1hdGNoZXMgJiYgbm9kZXNbaV0ubWF0Y2hlcyhzZWxlY3RvcikpIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0TGFzdENoaWxkID0gZnVuY3Rpb24gKGVsZW0sIHNlbGVjdG9yKSB7XG4gICAgLy8gR2V0IHRoZSBsYXN0IGNoaWxkIGVsZW1lbnRcbiAgICB2YXIgbm9kZXMgPSBlbGVtLmNoaWxkcmVuO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPD0gMCkgcmV0dXJuO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBzZWxlY3RvciwgcmV0dXJuIHRoZSBsYXN0IHNpYmxpbmdcbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBJZiB0aGUgY2hpbGQgbm9kZSBtYXRjaGVzIG91ciBzZWxlY3RvciwgdXNlIGl0XG4gICAgLy8gSWYgbm90LCBqdW1wIHRvIHRoZSBwcmV2IGNoaWxkIGFuZCBjb250aW51ZSB0aGUgbG9vcFxuICAgIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAobm9kZXNbaV0ubWF0Y2hlcyAmJiBub2Rlc1tpXS5tYXRjaGVzKHNlbGVjdG9yKSkgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDbG9zZXN0QWxsID0gZnVuY3Rpb24gKGVsZW0sIHNlbGVjdG9yKSB7XG4gICAgY29uc3QgY2xvc2VzdE9uZSA9IChlbCwgYXJyKSA9PiB7XG4gICAgICAgIGlmICghZWwpIHJldHVybiBhcnI7XG5cbiAgICAgICAgY29uc3QgY2xvID0gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgIGlmICghY2xvKSByZXR1cm4gYXJyO1xuXG4gICAgICAgIHJldHVybiBjbG9zZXN0T25lKGNsby5wYXJlbnRFbGVtZW50LCBbY2xvLCAuLi5hcnJdKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNsb3Nlc3RPbmUoZWxlbSwgW10pO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8gQ1JFQVRFIFFVRVJZIFBBUkFNRVRFUlNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGJ1aWxkUXVlcnkgPSAob2JqKSA9PlxuICAgIE9iamVjdC5lbnRyaWVzKG9iailcbiAgICAgICAgLm1hcCgocGFpcikgPT4gcGFpci5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKCc9JykpXG4gICAgICAgIC5qb2luKCcmJyk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vIEhUTUwgRUxFTUVOVFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGh0bWxUb0VsZW1lbnQgPSAoaHRtbCkgPT4ge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgaHRtbCA9IGh0bWwudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkO1xufTtcblxuZXhwb3J0IGNvbnN0IGVtcHR5RWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQubGFzdENoaWxkKTtcbiAgICB9XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLyBPVEhFUlNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGlzUG9zaXRpdmUgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gdHJ1ZSB8fCB2YWx1ZSA9PSAndHJ1ZScgfHwgdmFsdWUgPT0gJ1MnIHx8IHZhbHVlID09ICdzJyB8fCB2YWx1ZSA9PSAnMScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIG51bGwgb3IgZW1wdHlcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgY29uc3QgaXNPYmplY3RFbXB0eSA9IChvYmopID0+IHtcbiAgICByZXR1cm4gIW9iaiB8fCAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUpO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8gREVCT1VOQ0Vcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGRlYm91bmNlID0gKGNiLCBkZWxheSA9IDEwMDApID0+IHtcbiAgICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNiLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfTtcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vIE1BS0UgSURcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IG1ha2VpZCA9IChsZW5ndGgpID0+IHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGNoYXJhY3RlcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgIHZhciBjaGFyYWN0ZXJzTGVuZ3RoID0gY2hhcmFjdGVycy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gY2hhcmFjdGVycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcmFjdGVyc0xlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8gVElNRSBJTlNUQU5UXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjb25zdCB0aW1lSW5zdGFudCA9IChmb3JtYXR0ZWRIb3VyKSA9PiB7XG4gICAgbGV0IHQwID0gbmV3IERhdGUoKTtcbiAgICBsZXQgdDBzcGxpdCA9IGZvcm1hdHRlZEhvdXIuc3BsaXQoJzonKTtcbiAgICB0MC5zZXRIb3VycyhwYXJzZUludCh0MHNwbGl0WzBdKSk7XG4gICAgdDAuc2V0TWludXRlcyhwYXJzZUludCh0MHNwbGl0WzFdKSk7XG4gICAgcmV0dXJuIHQwO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIENvbnZlcnQgYSB0ZXh0IHRvIHVybCBmcmllbmRseVxuICovXG5leHBvcnQgY29uc3QgdG9VcmxGcmllbmRseSA9ICh0ZXh0KSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IHRleHRcbiAgICAgICAgLm5vcm1hbGl6ZSgnTkZEJylcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZUFsbCgvXFxzfFsvL186XS9nLCAnLScpXG4gICAgICAgIC5yZXBsYWNlQWxsKCdbXmEtejAtOS1dJywgJycpO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMTUwID8gcmVzdWx0LnN1YnN0cmluZygwLCAxNTApIDogcmVzdWx0O1xufTtcblxuLyoqXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiByZWZlcnJlciBjb21lcyBmcm9tIGN1cnJlbnQgZG9tYWluXG4gKi9cbmV4cG9ydCBjb25zdCBpc1JlZmVycmVyQ3VycmVudERvbWFpbiA9ICgpID0+IHtcbiAgICBpZiAoIWRvY3VtZW50LnJlZmVycmVyKSByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVmZXJyZXIgPSBuZXcgVVJMKGRvY3VtZW50LnJlZmVycmVyKTtcbiAgICAgICAgcmV0dXJuIHJlZmVycmVyLm9yaWdpbiA9PT0gbG9jYXRpb24ub3JpZ2luO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdDYW5ub3QgY2hlY2sgcmVmZXJyZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gKFxuICAgICAgICByZWN0LnRvcCA+PSAwICYmXG4gICAgICAgIHJlY3QubGVmdCA+PSAwICYmXG4gICAgICAgIHJlY3QuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiZcbiAgICAgICAgcmVjdC5yaWdodCA8PSAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKVxuICAgICk7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLyBDQUxDVUxBVEUgT1ZFUkxBWSBQT1NJVElPTlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY29uc3QgY2FsY1RvcCA9IChzZWxmLCB0YXJnZXQsIG9mZnNldCA9IDApID0+IHtcbiAgICBjb25zdCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBvcEhlaWdodCA9IHNlbGYuY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGxldCB0b3AgPSByZWN0LnRvcCArIHNjcm9sbFRvcCArIHJlY3QuaGVpZ2h0ICsgODtcbiAgICBpZiAodG9wICsgcG9wSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCkge1xuICAgICAgICBjb25zdCBkaWZmID0gdG9wICsgcG9wSGVpZ2h0IC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICAgICAgdG9wID0gdG9wIC0gZGlmZiAtIDg7XG4gICAgICAgIHRvcCA9IHRvcCA+PSAwID8gdG9wIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHRvcCArIG9mZnNldCArICdweCc7XG59O1xuXG5leHBvcnQgY29uc3QgY2FsY0xlZnQgPSAoc2VsZiwgdGFyZ2V0LCBvZmZzZXQgPSAwKSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwb3BXaWR0aCA9IHNlbGYuY2xpZW50V2lkdGg7XG4gICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBsZXQgbGVmdCA9IHJlY3QubGVmdCArIHNjcm9sbExlZnQ7XG4gICAgaWYgKGxlZnQgKyBwb3BXaWR0aCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCkge1xuICAgICAgICBjb25zdCBkaWZmID0gbGVmdCArIHBvcFdpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICBsZWZ0ID0gbGVmdCAtIGRpZmYgLSA4O1xuICAgICAgICBsZWZ0ID0gbGVmdCA+PSAwID8gbGVmdCA6IDA7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0ICsgb2Zmc2V0ICsgJ3B4Jztcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vIERFRVAgTUVSR0Vcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKGl0ZW0pID0+IHtcbiAgICByZXR1cm4gaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSk7XG59O1xuXG5leHBvcnQgY29uc3QgbWVyZ2VEZWVwID0gKHRhcmdldCwgLi4uc291cmNlcykgPT4ge1xuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2tleV06IHt9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgW2tleV06IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBGSUxFIFJFQURcbmV4cG9ydCBjb25zdCByZWFkRmlsZUFzeW5jID0gKGZpbGUpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcblxuICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XG4gICAgfSk7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY29uc3QgZGF0ZVRvU3RyID0gKG1zLCB3aXRoTXMgPSBmYWxzZSkgPT4ge1xuICAgIGlmICghbXMpIHJldHVybjtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUobXMpO1xuICAgIGNvbnN0IHN0ciA9IGRhdGUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICBpZiAod2l0aE1zKSB7XG4gICAgICAgIHJldHVybiBzdHIgKyAnICcgKyBTdHJpbmcoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSkucGFkU3RhcnQoMywgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbmV4cG9ydCBjb25zdCBkYXRlVG9EaWZmVGltZVN0ciA9IChtcywgd2l0aE1zID0gZmFsc2UpID0+IHtcbiAgICBpZiAoIW1zKSByZXR1cm47XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUobXMpO1xuICAgIGNvbnN0IHN0ciA9IGAke1N0cmluZyhkYXRlLmdldFVUQ0hvdXJzKCkpLnBhZFN0YXJ0KDIsICcwJyl9OiR7U3RyaW5nKGRhdGUuZ2V0TWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKClcbiAgICApLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICBpZiAod2l0aE1zKSB7XG4gICAgICAgIHJldHVybiBzdHIgKyAnICcgKyBTdHJpbmcoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSkucGFkU3RhcnQoMywgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG4iLCJ2YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzXCIpO1xuZnVuY3Rpb24gX19kZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIChvYmouX19lc01vZHVsZSA/IG9ialtcImRlZmF1bHRcIl0gOiBvYmopOyB9XG5tb2R1bGUuZXhwb3J0cyA9IChIYW5kbGViYXJzW1wiZGVmYXVsdFwiXSB8fCBIYW5kbGViYXJzKS50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCIgICAgICAgIDx0ZCBjbGFzcz1cXFwicHgtNSBweS0zIHRleHQtc20gYmctd2hpdGUgYm9yZGVyLWIgYm9yZGVyLWdyYXktMjAwXFxcIj5cXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwidGV4dC1ncmF5LTkwMCB3aGl0ZXNwYWNlLW5vLXdyYXBcXFwiPlxcbiAgICAgICAgICAgICAgICBcIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oY29udGFpbmVyLmxhbWJkYShkZXB0aDAsIGRlcHRoMCkpXG4gICAgKyBcIlxcbiAgICAgICAgICAgIDwvcD5cXG4gICAgICAgIDwvdGQ+XFxuXCI7XG59LFwiM1wiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgbG9va3VwUHJvcGVydHkgPSBjb250YWluZXIubG9va3VwUHJvcGVydHkgfHwgZnVuY3Rpb24ocGFyZW50LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnQsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50W3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG5cbiAgcmV0dXJuIFwiICAgICAgICA8dGQgY2xhc3M9XFxcInB4LTUgcHktMyB0ZXh0LXNtIGJnLXdoaXRlIGJvcmRlci1iIGJvcmRlci1ncmF5LTIwMFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmxleCBmbGV3LXJvdyBqdXN0aWZ5LWVuZFxcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImlmXCIpLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiAoY29udGFpbmVyLm51bGxDb250ZXh0IHx8IHt9KSwoZGVwdGgwICE9IG51bGwgPyBsb29rdXBQcm9wZXJ0eShkZXB0aDAsXCJlZGl0RW5hYmxlZFwiKSA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNCwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjEyLFwiY29sdW1uXCI6MTZ9LFwiZW5kXCI6e1wibGluZVwiOjMzLFwiY29sdW1uXCI6MjN9fX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiICAgICAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJmbGV4IGl0ZW1zLWNlbnRlciBwLTEgdGV4dC13aGl0ZSBiZy1ncmF5LTUwMCByb3VuZGVkLWZ1bGwgc2hhZG93IGhvdmVyOnRleHQtd2hpdGUtNzAwIHRleHQtbWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cXFwiQ2FuY2VsbGFcXFwiXFxuICAgICAgICAgICAgICAgICAgICByZWY9XFxcImRlbGV0ZVJvd1xcXCJcXG4gICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgPHN2Z1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LTQgaC00IHBvaW50ZXItZXZlbnRzLW5vbmVcXFwiXFxuICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbC1ydWxlPVxcXCJldmVub2RkXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVxcXCJNNS40NyA1LjQ3YS43NS43NSAwIDAxMS4wNiAwTDEyIDEwLjk0bDUuNDctNS40N2EuNzUuNzUgMCAxMTEuMDYgMS4wNkwxMy4wNiAxMmw1LjQ3IDUuNDdhLjc1Ljc1IDAgMTEtMS4wNiAxLjA2TDEyIDEzLjA2bC01LjQ3IDUuNDdhLjc1Ljc1IDAgMDEtMS4wNi0xLjA2TDEwLjk0IDEyIDUuNDcgNi41M2EuNzUuNzUgMCAwMTAtMS4wNnpcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAtcnVsZT1cXFwiZXZlbm9kZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC90ZD5cXG5cIjtcbn0sXCI0XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiZmxleCBpdGVtcy1jZW50ZXIgcC0xIHRleHQtd2hpdGUgYmctZ3JheS01MDAgcm91bmRlZC1mdWxsIHNoYWRvdyBob3Zlcjp0ZXh0LXdoaXRlLTcwMCB0ZXh0LW1kIG1yLTFcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XFxcIk1vZGlmaWNhXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj1cXFwiZWRpdFJvd1xcXCJcXG4gICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3ZnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cXFwibm9uZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2Utd2lkdGg9XFxcIjEuNVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVxcXCJjdXJyZW50Q29sb3JcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LTQgaC00IHBvaW50ZXItZXZlbnRzLW5vbmVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ9XFxcIk0xNi44NjIgNC40ODdsMS42ODctMS42ODhhMS44NzUgMS44NzUgMCAxMTIuNjUyIDIuNjUyTDEwLjU4MiAxNi4wN2E0LjUgNC41IDAgMDEtMS44OTcgMS4xM0w2IDE4bC44LTIuNjg1YTQuNSA0LjUgMCAwMTEuMTMtMS44OTdsOC45MzItOC45MzF6bTAgMEwxOS41IDcuMTI1TTE4IDE0djQuNzVBMi4yNSAyLjI1IDAgMDExNS43NSAyMUg1LjI1QTIuMjUgMi4yNSAwIDAxMyAxOC43NVY4LjI1QTIuMjUgMi4yNSAwIDAxNS4yNSA2SDEwXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbOCxcIj49IDQuMy4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiAoY29udGFpbmVyLm51bGxDb250ZXh0IHx8IHt9KSwgbG9va3VwUHJvcGVydHkgPSBjb250YWluZXIubG9va3VwUHJvcGVydHkgfHwgZnVuY3Rpb24ocGFyZW50LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnQsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50W3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG5cbiAgcmV0dXJuIFwiPHRyIGRhdGEtaWQ9XFxcIlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwiaWRcIikgfHwgKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwiaWRcIikgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogY29udGFpbmVyLmhvb2tzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6MSxcImNvbHVtblwiOjEzfSxcImVuZFwiOntcImxpbmVcIjoxLFwiY29sdW1uXCI6MTl9fX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImVhY2hcIikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwiZGF0YVwiKSA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6MixcImNvbHVtblwiOjR9LFwiZW5kXCI6e1wibGluZVwiOjgsXCJjb2x1bW5cIjoxM319fSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgKChzdGFjazEgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwidW5sZXNzXCIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcImFjdGlvbkRpc2FibGVkXCIpIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJ1bmxlc3NcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjksXCJjb2x1bW5cIjo0fSxcImVuZFwiOntcImxpbmVcIjo1NCxcImNvbHVtblwiOjE1fX19KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvdHI+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTsiLCJ2YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzXCIpO1xuZnVuY3Rpb24gX19kZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIChvYmouX19lc01vZHVsZSA/IG9ialtcImRlZmF1bHRcIl0gOiBvYmopOyB9XG5tb2R1bGUuZXhwb3J0cyA9IChIYW5kbGViYXJzW1wiZGVmYXVsdFwiXSB8fCBIYW5kbGViYXJzKS50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyLCBsb29rdXBQcm9wZXJ0eSA9IGNvbnRhaW5lci5sb29rdXBQcm9wZXJ0eSB8fCBmdW5jdGlvbihwYXJlbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudCwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfTtcblxuICByZXR1cm4gXCI8aDIgY2xhc3M9XFxcImZvbnQtc2VtaWJvbGQgdGV4dC1sZyBtci00XFxcIj5cIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcInRpdGxlXCIpIHx8IChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcInRpdGxlXCIpIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGNvbnRhaW5lci5ob29rcy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiAoY29udGFpbmVyLm51bGxDb250ZXh0IHx8IHt9KSx7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGEsXCJsb2NcIjp7XCJzdGFydFwiOntcImxpbmVcIjo0LFwiY29sdW1uXCI6NjR9LFwiZW5kXCI6e1wibGluZVwiOjQsXCJjb2x1bW5cIjo3M319fSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9oMj5cIjtcbn0sXCIzXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyLCBsb29rdXBQcm9wZXJ0eSA9IGNvbnRhaW5lci5sb29rdXBQcm9wZXJ0eSB8fCBmdW5jdGlvbihwYXJlbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudCwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfTtcblxuICByZXR1cm4gXCIgICAgICAgICAgICA8Zm9ybSBjbGFzcz1cXFwibXQtNCBtZDptdC0wIGZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgbWItMFxcXCIgcmVmPVxcXCJmaWx0ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkPVxcXCImcXVvdDtmb3JtLXN1YnNjcmliZS1GaWx0ZXJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInJvdW5kZWQtbGcgYm9yZGVyLXRyYW5zcGFyZW50IGZsZXgtMSBhcHBlYXJhbmNlLW5vbmUgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCB3LWZ1bGwgcHktMiBweC00IGJnLXdoaXRlIHRleHQtZ3JheS03MDAgcGxhY2Vob2xkZXItZ3JheS00MDAgc2hhZG93LXNtIHRleHQtYmFzZSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS02MDAgZm9jdXM6Ym9yZGVyLXRyYW5zcGFyZW50XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XFxcIlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwiZmlsdGVyS2V5XCIpIHx8IChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcImZpbHRlcktleVwiKSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBjb250YWluZXIuaG9va3MuaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IFwiZnVuY3Rpb25cIiA/IGhlbHBlci5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSkse1wibmFtZVwiOlwiZmlsdGVyS2V5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjE3LFwiY29sdW1uXCI6MzB9LFwiZW5kXCI6e1wibGluZVwiOjE3LFwiY29sdW1uXCI6NDN9fX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiRmlsdHJhLi4uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJzZWxmLWVuZCBtdC0xIG1kOm10LTAgbWQ6bWwtMSBmbGV4LXNocmluay0wIHB4LTQgcHktMiB0ZXh0LWJhc2UgZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlIGJnLWdyYXktNTAwIHJvdW5kZWQtbGcgc2hhZG93LW1kIGhvdmVyOmJnLWdyYXktNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTUwMCBmb2N1czpyaW5nLW9mZnNldC0yIGZvY3VzOnJpbmctb2Zmc2V0LWdyYXktMjAwXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwic3VibWl0XFxcIlxcbiAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICBGaWx0cmFcXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgPC9mb3JtPlxcblwiO1xufSxcIjVcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlPVxcXCJjb2xcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwicHgtNSBweS0zIHRleHQtc20gZm9udC1ub3JtYWwgdGV4dC1sZWZ0IHRleHQtZ3JheS04MDAgdXBwZXJjYXNlIGJnLXdoaXRlIGJvcmRlci1iIGJvcmRlci1ncmF5LTIwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKGNvbnRhaW5lci5sYW1iZGEoZGVwdGgwLCBkZXB0aDApKVxuICAgICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aD5cXG5cIjtcbn0sXCI3XCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZT1cXFwiY29sXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInB4LTUgcHktMyB0ZXh0LXNtIGZvbnQtbm9ybWFsIHRleHQtbGVmdCB0ZXh0LWdyYXktODAwIHVwcGVyY2FzZSBiZy13aGl0ZSBib3JkZXItYiBib3JkZXItZ3JheS0yMDAgdGV4dC1yaWdodFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXppb25pXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGg+XFxuXCI7XG59LFwiOVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMTtcblxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICsgKChzdGFjazEgPSBjb250YWluZXIubGFtYmRhKGRlcHRoMCwgZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcblwiO1xufSxcIjExXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBsb29rdXBQcm9wZXJ0eSA9IGNvbnRhaW5lci5sb29rdXBQcm9wZXJ0eSB8fCBmdW5jdGlvbihwYXJlbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudCwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfTtcblxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgcHgtNSBweS01IGJnLXdoaXRlIHhzOmZsZXgtcm93IHhzOmp1c3RpZnktYmV0d2VlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4IGl0ZW1zLWNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LWZ1bGwgcC00IHRleHQtYmFzZSB0ZXh0LWdyYXktNjAwIGJnLXdoaXRlIGJvcmRlciByb3VuZGVkLWwteGwgaG92ZXI6YmctZ3JheS0xMDBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdmFsdWU9XFxcInByZXZcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZj1cXFwicGFnZUJ0blxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmdcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVxcXCI5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PVxcXCI4XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcIlxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g9XFxcIjAgMCAxNzkyIDE3OTJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cXFwiTTE0MjcgMzAxbC01MzEgNTMxIDUzMSA1MzFxMTkgMTkgMTkgNDV0LTE5IDQ1bC0xNjYgMTY2cS0xOSAxOS00NSAxOXQtNDUtMTlsLTc0Mi03NDJxLTE5LTE5LTE5LTQ1dDE5LTQ1bDc0Mi03NDJxMTktMTkgNDUtMTl0NDUgMTlsMTY2IDE2NnExOSAxOSAxOSA0NXQtMTkgNDV6XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wYXRoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwiZWFjaFwiKS5jYWxsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSksKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwicGFnaW5hdGlvblwiKSA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxMiwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjgyLFwiY29sdW1uXCI6MjR9LFwiZW5kXCI6e1wibGluZVwiOjkxLFwiY29sdW1uXCI6MzN9fX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LWZ1bGwgcC00IHRleHQtYmFzZSB0ZXh0LWdyYXktNjAwIGJnLXdoaXRlIGJvcmRlci10IGJvcmRlci1iIGJvcmRlci1yIHJvdW5kZWQtci14bCBob3ZlcjpiZy1ncmF5LTEwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS12YWx1ZT1cXFwibmV4dFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPVxcXCJwYWdlQnRuXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2Z1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XFxcIjlcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9XFxcIjhcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cXFwiMCAwIDE3OTIgMTc5MlxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVxcXCJNMTM2MyA4NzdsLTc0MiA3NDJxLTE5IDE5LTQ1IDE5dC00NS0xOWwtMTY2LTE2NnEtMTktMTktMTktNDV0MTktNDVsNTMxLTUzMS01MzEtNTMxcS0xOS0xOS0xOS00NXQxOS00NWwxNjYtMTY2cTE5LTE5IDQ1LTE5dDQ1IDE5bDc0MiA3NDJxMTkgMTkgMTkgNDV0LTE5IDQ1elxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcGF0aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuXCI7XG59LFwiMTJcIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXIsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBhbGlhczI9Y29udGFpbmVyLmhvb2tzLmhlbHBlck1pc3NpbmcsIGFsaWFzMz1cImZ1bmN0aW9uXCIsIGFsaWFzND1jb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbiwgbG9va3VwUHJvcGVydHkgPSBjb250YWluZXIubG9va3VwUHJvcGVydHkgfHwgZnVuY3Rpb24ocGFyZW50LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnQsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50W3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG5cbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LWZ1bGwgcHgtNCBweS0yIHRleHQtYmFzZSB0ZXh0LWluZGlnby01MDAgYmctd2hpdGUgYm9yZGVyLXQgYm9yZGVyLWIgaG92ZXI6YmctZ3JheS0xMDBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXZhbHVlPVxcXCJcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGxvb2t1cFByb3BlcnR5KGhlbHBlcnMsXCJ2YWx1ZVwiKSB8fCAoZGVwdGgwICE9IG51bGwgPyBsb29rdXBQcm9wZXJ0eShkZXB0aDAsXCJ2YWx1ZVwiKSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwidmFsdWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6ODYsXCJjb2x1bW5cIjo0NH0sXCJlbmRcIjp7XCJsaW5lXCI6ODYsXCJjb2x1bW5cIjo1M319fSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPVxcXCJwYWdlQnRuXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICsgYWxpYXM0KCgoaGVscGVyID0gKGhlbHBlciA9IGxvb2t1cFByb3BlcnR5KGhlbHBlcnMsXCJsYWJlbFwiKSB8fCAoZGVwdGgwICE9IG51bGwgPyBsb29rdXBQcm9wZXJ0eShkZXB0aDAsXCJsYWJlbFwiKSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwibGFiZWxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6ODksXCJjb2x1bW5cIjozMn0sXCJlbmRcIjp7XCJsaW5lXCI6ODksXCJjb2x1bW5cIjo0MX19fSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcblwiO1xufSxcImNvbXBpbGVyXCI6WzgsXCI+PSA0LjMuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGFsaWFzMT1kZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLCBsb29rdXBQcm9wZXJ0eSA9IGNvbnRhaW5lci5sb29rdXBQcm9wZXJ0eSB8fCBmdW5jdGlvbihwYXJlbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudCwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfTtcblxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4IGZsZXgtY29sIG1kOmZsZXgtcm93IGp1c3RpZnktYmV0d2VlbiBtZDppdGVtcy1jZW50ZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXJcXFwiPlxcbiAgICAgICAgICAgIFwiXG4gICAgKyAoKHN0YWNrMSA9IGxvb2t1cFByb3BlcnR5KGhlbHBlcnMsXCJpZlwiKS5jYWxsKGFsaWFzMSwoZGVwdGgwICE9IG51bGwgPyBsb29rdXBQcm9wZXJ0eShkZXB0aDAsXCJ0aXRsZVwiKSA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMSwgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjQsXCJjb2x1bW5cIjoxMn0sXCJlbmRcIjp7XCJsaW5lXCI6NCxcImNvbHVtblwiOjg1fX19KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGZvbnQtc2VtaWJvbGQgcC0yIHRleHQtZ3JheS02MDAgYmctd2hpdGUgcm91bmRlZC1mdWxsIHNoYWRvdyBob3Zlcjp0ZXh0LWdyYXktNzAwIHRleHQtbWQgc2hyaW5rLTAgdy0xMCBoLTEwXFxcIlxcbiAgICAgICAgICAgICAgICByZWY9XFxcImNvdW50XFxcIlxcbiAgICAgICAgICAgID4gXCJcbiAgICArIGNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uKGNvbnRhaW5lci5sYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBsb29rdXBQcm9wZXJ0eShkZXB0aDAsXCJyb3dzSHRtbHNcIikgOiBkZXB0aDApKSAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoc3RhY2sxLFwibGVuZ3RoXCIpIDogc3RhY2sxKSwgZGVwdGgwKSlcbiAgICArIFwiIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXCJcbiAgICArICgoc3RhY2sxID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImlmXCIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcImZpbHRlcktleVwiKSA6IGRlcHRoMCkse1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oMywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjEwLFwiY29sdW1uXCI6OH0sXCJlbmRcIjp7XCJsaW5lXCI6MjgsXCJjb2x1bW5cIjoxNX19fSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCIgICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInB5LTQgb3ZlcmZsb3cteC1hdXRvXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlubGluZS1ibG9jayBtaW4tdy1mdWxsIG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLWxnIHNoYWRvd1xcXCI+XFxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJtaW4tdy1mdWxsIGxlYWRpbmctbm9ybWFsXFxcIj5cXG4gICAgICAgICAgICAgICAgPHRoZWFkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRyPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGxvb2t1cFByb3BlcnR5KGhlbHBlcnMsXCJlYWNoXCIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcImxhYmVsc1wiKSA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSg1LCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6MzUsXCJjb2x1bW5cIjoyNH0sXCJlbmRcIjp7XCJsaW5lXCI6NDIsXCJjb2x1bW5cIjozM319fSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgKChzdGFjazEgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwidW5sZXNzXCIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcImFjdGlvbkRpc2FibGVkXCIpIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJ1bmxlc3NcIixcImhhc2hcIjp7fSxcImZuXCI6Y29udGFpbmVyLnByb2dyYW0oNywgZGF0YSwgMCksXCJpbnZlcnNlXCI6Y29udGFpbmVyLm5vb3AsXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjQzLFwiY29sdW1uXCI6MjR9LFwiZW5kXCI6e1wibGluZVwiOjUwLFwiY29sdW1uXCI6MzV9fX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiICAgICAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxcbiAgICAgICAgICAgICAgICA8dGJvZHkgcmVmPVxcXCJ0Ym9keVxcXCI+XFxuXCJcbiAgICArICgoc3RhY2sxID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImVhY2hcIikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwicm93c0h0bWxzXCIpIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDksIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGEsXCJsb2NcIjp7XCJzdGFydFwiOntcImxpbmVcIjo1NCxcImNvbHVtblwiOjIwfSxcImVuZFwiOntcImxpbmVcIjo1NixcImNvbHVtblwiOjI5fX19KSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIiAgICAgICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgICAgIDwvdGFibGU+XFxuXCJcbiAgICArICgoc3RhY2sxID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImlmXCIpLmNhbGwoYWxpYXMxLChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcInBhZ2luYXRpb25cIikgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDExLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6NTksXCJjb2x1bW5cIjoxMn0sXCJlbmRcIjp7XCJsaW5lXCI6MTE0LFwiY29sdW1uXCI6MTl9fX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTsiLCJ2YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzXCIpO1xuZnVuY3Rpb24gX19kZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIChvYmouX19lc01vZHVsZSA/IG9ialtcImRlZmF1bHRcIl0gOiBvYmopOyB9XG5tb2R1bGUuZXhwb3J0cyA9IChIYW5kbGViYXJzW1wiZGVmYXVsdFwiXSB8fCBIYW5kbGViYXJzKS50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgaGVscGVyLCBhbGlhczE9ZGVwdGgwICE9IG51bGwgPyBkZXB0aDAgOiAoY29udGFpbmVyLm51bGxDb250ZXh0IHx8IHt9KSwgYWxpYXMyPWNvbnRhaW5lci5ob29rcy5oZWxwZXJNaXNzaW5nLCBhbGlhczM9XCJmdW5jdGlvblwiLCBhbGlhczQ9Y29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24sIGxvb2t1cFByb3BlcnR5ID0gY29udGFpbmVyLmxvb2t1cFByb3BlcnR5IHx8IGZ1bmN0aW9uKHBhcmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyZW50LCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9O1xuXG4gIHJldHVybiBcIiAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktc3RhcnQgdy1mdWxsIHAtMiBwbC02IG15LTIgdGV4dC1ncmF5LTQwMCB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgYm9yZGVyLWwtNCBib3JkZXItdHJhbnNwYXJlbnQgaG92ZXI6dGV4dC1ncmF5LTgwMFxcXCJcXG4gICAgICAgICAgICAgICAgcmVmPVxcXCJtZW51SXRlbVxcXCJcXG4gICAgICAgICAgICAgICAgZGF0YS1kZXN0aW5hdGlvbj1cXFwicHMtXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwiaWRcIikgfHwgKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwiaWRcIikgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogYWxpYXMyKSwodHlwZW9mIGhlbHBlciA9PT0gYWxpYXMzID8gaGVscGVyLmNhbGwoYWxpYXMxLHtcIm5hbWVcIjpcImlkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjMxLFwiY29sdW1uXCI6Mzd9LFwiZW5kXCI6e1wibGluZVwiOjMxLFwiY29sdW1uXCI6NDN9fX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCJcXG4gICAgICAgICAgICAgICAgZGF0YS10aXRsZT1cXFwiXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwibmFtZVwiKSB8fCAoZGVwdGgwICE9IG51bGwgPyBsb29rdXBQcm9wZXJ0eShkZXB0aDAsXCJuYW1lXCIpIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjMyLFwiY29sdW1uXCI6Mjh9LFwiZW5kXCI6e1wibGluZVwiOjMyLFwiY29sdW1uXCI6MzZ9fX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0ZXh0LWxlZnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHN2Z1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVxcXCJub25lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2Utd2lkdGg9XFxcIjEuNVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidy02IGgtNlxcXCJcXG4gICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2UtbGluZWNhcD1cXFwicm91bmRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ9XFxcIk00LjUgMTJhNy41IDcuNSAwIDAwMTUgMG0tMTUgMGE3LjUgNy41IDAgMTExNSAwbS0xNSAwSDNtMTYuNSAwSDIxbS0xLjUgMEgxMm0tOC40NTcgMy4wNzdsMS40MS0uNTEzbTE0LjA5NS01LjEzbDEuNDEtLjUxM001LjEwNiAxNy43ODVsMS4xNS0uOTY0bTExLjQ5LTkuNjQybDEuMTQ5LS45NjRNNy41MDEgMTkuNzk1bC43NS0xLjNtNy41LTEyLjk5bC43NS0xLjNtLTYuMDYzIDE2LjY1OGwuMjYtMS40NzdtMi42MDUtMTQuNzcybC4yNi0xLjQ3N20wIDE3LjcyNmwtLjI2LTEuNDc3TTEwLjY5OCA0LjYxNGwtLjI2LTEuNDc3TTE2LjUgMTkuNzk0bC0uNzUtMS4yOTlNNy41IDQuMjA1TDEyIDEybTYuODk0IDUuNzg1bC0xLjE0OS0uOTY0TTYuMjU2IDcuMTc4bC0xLjE1LS45NjRtMTUuMzUyIDguODY0bC0xLjQxLS41MTNNNC45NTQgOS40MzVsLTEuNDEtLjUxNE0xMi4wMDIgMTJsLTMuNzUgNi40OTVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxcblxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJteC0yIHRleHQtc20gZm9udC1ub3JtYWxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgXCJcbiAgICArIGFsaWFzNCgoKGhlbHBlciA9IChoZWxwZXIgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwibmFtZVwiKSB8fCAoZGVwdGgwICE9IG51bGwgPyBsb29rdXBQcm9wZXJ0eShkZXB0aDAsXCJuYW1lXCIpIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YSxcImxvY1wiOntcInN0YXJ0XCI6e1wibGluZVwiOjUyLFwiY29sdW1uXCI6MjB9LFwiZW5kXCI6e1wibGluZVwiOjUyLFwiY29sdW1uXCI6Mjh9fX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbOCxcIj49IDQuMy4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgbG9va3VwUHJvcGVydHkgPSBjb250YWluZXIubG9va3VwUHJvcGVydHkgfHwgZnVuY3Rpb24ocGFyZW50LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnQsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50W3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH07XG5cbiAgcmV0dXJuIFwiPG5hdiBjbGFzcz1cXFwibXQtNlxcXCI+XFxuICAgIDxkaXY+XFxuICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktc3RhcnQgdy1mdWxsIHAtMiBwbC02IG15LTIgdGV4dC1ncmF5LTQwMCB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgYm9yZGVyLWwtNCBib3JkZXItdHJhbnNwYXJlbnQgaG92ZXI6dGV4dC1ncmF5LTgwMCBhY3RpdmU6dGV4dC1ncmF5LTgwMFxcXCJcXG4gICAgICAgICAgICByZWY9XFxcIm1lbnVJdGVtXFxcIlxcbiAgICAgICAgICAgIGRhdGEtZGVzdGluYXRpb249XFxcImRhc2hib2FyZFxcXCJcXG4gICAgICAgICAgICBkYXRhLXRpdGxlPVxcXCJEYXNoYm9hcmRcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRleHQtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzdmdcXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoPVxcXCIyMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD1cXFwiMjBcXFwiXFxuICAgICAgICAgICAgICAgICAgICBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiXFxuICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVxcXCIwIDAgMTc5MiAxNzkyXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ9XFxcIk0xNDcyIDk5MnY0ODBxMCAyNi0xOSA0NXQtNDUgMTloLTM4NHYtMzg0aC0yNTZ2Mzg0aC0zODRxLTI2IDAtNDUtMTl0LTE5LTQ1di00ODBxMC0xIC41LTN0LjUtM2w1NzUtNDc0IDU3NSA0NzRxMSAyIDEgNnptMjIzLTY5bC02MiA3NHEtOCA5LTIxIDExaC0zcS0xMyAwLTIxLTdsLTY5Mi01NzctNjkyIDU3N3EtMTIgOC0yNCA3LTEzLTItMjEtMTFsLTYyLTc0cS04LTEwLTctMjMuNXQxMS0yMS41bDcxOS01OTlxMzItMjYgNzYtMjZ0NzYgMjZsMjQ0IDIwNHYtMTk1cTAtMTQgOS0yM3QyMy05aDE5MnExNCAwIDIzIDl0OSAyM3Y0MDhsMjE5IDE4MnExMCA4IDExIDIxLjV0LTcgMjMuNXpcXFwiXFxuICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICA8L3BhdGg+XFxuICAgICAgICAgICAgICAgIDwvc3ZnPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibXgtMiB0ZXh0LXNtIGZvbnQtbm9ybWFsXFxcIj5cXG4gICAgICAgICAgICAgICAgRGFzaGJvYXJkXFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPC9idXR0b24+XFxuXCJcbiAgICArICgoc3RhY2sxID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImVhY2hcIikuY2FsbChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMCA6IChjb250YWluZXIubnVsbENvbnRleHQgfHwge30pLChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcInBzXCIpIDogZGVwdGgwKSx7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOmNvbnRhaW5lci5wcm9ncmFtKDEsIGRhdGEsIDApLFwiaW52ZXJzZVwiOmNvbnRhaW5lci5ub29wLFwiZGF0YVwiOmRhdGEsXCJsb2NcIjp7XCJzdGFydFwiOntcImxpbmVcIjoyNyxcImNvbHVtblwiOjh9LFwiZW5kXCI6e1wibGluZVwiOjU1LFwiY29sdW1uXCI6MTd9fX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgICAgY2xhc3M9XFxcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktc3RhcnQgdy1mdWxsIHAtMiBwbC02IG15LTIgdGV4dC1ncmF5LTQwMCB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgYm9yZGVyLWwtNCBib3JkZXItdHJhbnNwYXJlbnQgaG92ZXI6dGV4dC1ncmF5LTgwMFxcXCJcXG4gICAgICAgICAgICByZWY9XFxcIm1lbnVJdGVtXFxcIlxcbiAgICAgICAgICAgIGRhdGEtZGVzdGluYXRpb249XFxcInJ1bm5lclxcXCJcXG4gICAgICAgICAgICBkYXRhLXRpdGxlPVxcXCJDb3JyaWRvcmlcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRleHQtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgY2xhc3M9XFxcInctNiBoLTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVxcXCJNNC41IDYuMzc1YTQuMTI1IDQuMTI1IDAgMTE4LjI1IDAgNC4xMjUgNC4xMjUgMCAwMS04LjI1IDB6TTE0LjI1IDguNjI1YTMuMzc1IDMuMzc1IDAgMTE2Ljc1IDAgMy4zNzUgMy4zNzUgMCAwMS02Ljc1IDB6TTEuNSAxOS4xMjVhNy4xMjUgNy4xMjUgMCAwMTE0LjI1IDB2LjAwM2wtLjAwMS4xMTlhLjc1Ljc1IDAgMDEtLjM2My42MyAxMy4wNjcgMTMuMDY3IDAgMDEtNi43NjEgMS44NzNjLTIuNDcyIDAtNC43ODYtLjY4NC02Ljc2LTEuODczYS43NS43NSAwIDAxLS4zNjQtLjYzbC0uMDAxLS4xMjJ6TTE3LjI1IDE5LjEyOGwtLjAwMS4xNDRhMi4yNSAyLjI1IDAgMDEtLjIzMy45NiAxMC4wODggMTAuMDg4IDAgMDA1LjA2LTEuMDEuNzUuNzUgMCAwMC40Mi0uNjQzIDQuODc1IDQuODc1IDAgMDAtNi45NTctNC42MTEgOC41ODYgOC41ODYgMCAwMTEuNzEgNS4xNTd2LjAwM3pcXFwiXFxuICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICA8L3N2Zz5cXG5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm14LTIgdGV4dC1zbSBmb250LW5vcm1hbFxcXCI+XFxuICAgICAgICAgICAgICAgIENvcnJpZG9yaVxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LXN0YXJ0IHctZnVsbCBwLTIgcGwtNiBteS0yIHRleHQtZ3JheS00MDAgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGJvcmRlci1sLTQgYm9yZGVyLXRyYW5zcGFyZW50IGhvdmVyOnRleHQtZ3JheS04MDBcXFwiXFxuICAgICAgICAgICAgcmVmPVxcXCJtZW51SXRlbVxcXCJcXG4gICAgICAgICAgICBkYXRhLWRlc3RpbmF0aW9uPVxcXCJyYWNlXFxcIlxcbiAgICAgICAgICAgIGRhdGEtdGl0bGU9XFxcIkdhcmFcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRleHQtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgY2xhc3M9XFxcInctNiBoLTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcXG4gICAgICAgICAgICAgICAgICAgICAgICBkPVxcXCJNMTcuMDA0IDEwLjQwN2MuMTM4LjQzNS0uMjE2Ljg0Mi0uNjcyLjg0MmgtMy40NjVhLjc1Ljc1IDAgMDEtLjY1LS4zNzVsLTEuNzMyLTNjLS4yMjktLjM5Ni0uMDUzLS45MDcuMzkzLTEuMDA0YTUuMjUyIDUuMjUyIDAgMDE2LjEyNiAzLjUzN3pNOC4xMiA4LjQ2NGMuMzA3LS4zMzguODM4LS4yMzUgMS4wNjYuMTZsMS43MzIgM2EuNzUuNzUgMCAwMTAgLjc1bC0xLjczMiAzLjAwMWMtLjIyOS4zOTYtLjc2LjQ5OC0xLjA2Ny4xNkE1LjIzMSA1LjIzMSAwIDAxNi43NSAxMmMwLTEuMzYyLjUxOS0yLjYwMyAxLjM3LTMuNTM2ek0xMC44NzggMTcuMTNjLS40NDctLjA5Ny0uNjIzLS42MDgtLjM5NC0xLjAwM2wxLjczMy0zLjAwM2EuNzUuNzUgMCAwMS42NS0uMzc1aDMuNDY1Yy40NTcgMCAuODEuNDA4LjY3Mi44NDNhNS4yNTIgNS4yNTIgMCAwMS02LjEyNiAzLjUzOHpcXFwiXFxuICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsLXJ1bGU9XFxcImV2ZW5vZGRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgZD1cXFwiTTIxIDEyLjc1YS43NS43NSAwIDAwMC0xLjVoLS43ODNhOC4yMiA4LjIyIDAgMDAtLjIzNy0xLjM1N2wuNzM0LS4yNjdhLjc1Ljc1IDAgMTAtLjUxMy0xLjQxbC0uNzM1LjI2OGE4LjI0IDguMjQgMCAwMC0uNjg5LTEuMTkxbC42LS41MDRhLjc1Ljc1IDAgMTAtLjk2NC0xLjE0OWwtLjYuNTA0YTguMyA4LjMgMCAwMC0xLjA1NC0uODg1bC4zOTEtLjY3OGEuNzUuNzUgMCAxMC0xLjI5OS0uNzVsLS4zOS42NzdhOC4xODggOC4xODggMCAwMC0xLjI5NS0uNDcxbC4xMzYtLjc3YS43NS43NSAwIDAwLTEuNDc3LS4yNmwtLjEzNi43N2E4LjM2NCA4LjM2NCAwIDAwLTEuMzc3IDBsLS4xMzYtLjc3YS43NS43NSAwIDEwLTEuNDc3LjI2bC4xMzYuNzdjLS40NDguMTIxLS44OC4yOC0xLjI5NC40N2wtLjM5LS42NzZhLjc1Ljc1IDAgMDAtMS4zLjc1bC4zOTIuNjc4YTguMjkgOC4yOSAwIDAwLTEuMDU0Ljg4NWwtLjYtLjUwNGEuNzUuNzUgMCAwMC0uOTY1IDEuMTQ5bC42LjUwM2E4LjI0MyA4LjI0MyAwIDAwLS42ODkgMS4xOTJMMy44IDguMjE3YS43NS43NSAwIDEwLS41MTMgMS40MWwuNzM1LjI2N2E4LjIyMiA4LjIyMiAwIDAwLS4yMzggMS4zNTVoLS43ODNhLjc1Ljc1IDAgMDAwIDEuNWguNzgzYy4wNDIuNDY0LjEyMi45MTcuMjM4IDEuMzU2bC0uNzM1LjI2OGEuNzUuNzUgMCAxMC41MTMgMS40MWwuNzM1LS4yNjhjLjE5Ny40MTcuNDI4LjgxNi42OSAxLjE5MmwtLjYuNTA0YS43NS43NSAwIDEwLjk2MyAxLjE0OWwuNjAxLS41MDVjLjMyNi4zMjMuNjc5LjYyIDEuMDU0Ljg4NWwtLjM5Mi42OGEuNzUuNzUgMCAxMDEuMy43NWwuMzktLjY3OWMuNDE0LjE5Mi44NDcuMzUgMS4yOTQuNDcxbC0uMTM2Ljc3MWEuNzUuNzUgMCAxMDEuNDc3LjI2bC4xMzctLjc3MmE4LjM3NiA4LjM3NiAwIDAwMS4zNzYgMGwuMTM2Ljc3M2EuNzUuNzUgMCAxMDEuNDc3LS4yNmwtLjEzNi0uNzcyYTguMTkgOC4xOSAwIDAwMS4yOTQtLjQ3bC4zOTEuNjc3YS43NS43NSAwIDEwMS4zLS43NWwtLjM5My0uNjc5YTguMjgyIDguMjgyIDAgMDAxLjA1NC0uODg1bC42MDEuNTA0YS43NS43NSAwIDEwLjk2NC0xLjE1bC0uNi0uNTAzYTguMjQgOC4yNCAwIDAwLjY5LTEuMTkxbC43MzUuMjY4YS43NS43NSAwIDEwLjUxMi0xLjQxbC0uNzM0LS4yNjhjLjExNS0uNDM4LjE5NS0uODkyLjIzNy0xLjM1NmguNzg0em0tMi42NTctMy4wNmE2Ljc0NCA2Ljc0NCAwIDAwLTEuMTktMi4wNTMgNi43ODQgNi43ODQgMCAwMC0xLjgyLTEuNTFBNi43MDQgNi43MDQgMCAwMDEyIDUuMjVhNi44MDEgNi44MDEgMCAwMC0xLjIyNS4xMTEgNi43IDYuNyAwIDAwLTIuMTUuNzkyIDYuNzg0IDYuNzg0IDAgMDAtMi45NTIgMy40ODkuNzU4Ljc1OCAwIDAxLS4wMzYuMDk5QTYuNzQgNi43NCAwIDAwNS4yNTEgMTJhNi43MzkgNi43MzkgMCAwMDMuMzU1IDUuODM1bC4wMS4wMDYuMDEuMDA1YTYuNzA2IDYuNzA2IDAgMDAyLjIwMy44MDJjLjAwNyAwIC4wMTQuMDAyLjAyMS4wMDRhNi43OTIgNi43OTIgMCAwMDIuMzAxIDBsLjAyMi0uMDA0YTYuNzA3IDYuNzA3IDAgMDAyLjIyOC0uODE2IDYuNzgxIDYuNzgxIDAgMDAxLjc2Mi0xLjQ4M2wuMDA5LS4wMS4wMDktLjAxMmE2Ljc0NCA2Ljc0NCAwIDAwMS4xOC0yLjA2NGMuMjUzLS43MDguMzktMS40Ny4zOS0yLjI2NGE2Ljc0IDYuNzQgMCAwMC0uNDA4LTIuMzA4elxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwLXJ1bGU9XFxcImV2ZW5vZGRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm14LTIgdGV4dC1zbSBmb250LW5vcm1hbFxcXCI+XFxuICAgICAgICAgICAgICAgIEdhcmFcXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgPC9kaXY+XFxuPC9uYXY+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTsiLCJ2YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzXCIpO1xuZnVuY3Rpb24gX19kZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIChvYmouX19lc01vZHVsZSA/IG9ialtcImRlZmF1bHRcIl0gOiBvYmopOyB9XG5tb2R1bGUuZXhwb3J0cyA9IChIYW5kbGViYXJzW1wiZGVmYXVsdFwiXSB8fCBIYW5kbGViYXJzKS50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls4LFwiPj0gNC4zLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8ZGl2IHJlZj1cXFwiY29udGVudFxcXCI+XFxuICAgIDxtMC1yYWNlcj48L20wLXJhY2VyPlxcbjwvZGl2PlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7IiwidmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qc1wiKTtcbmZ1bmN0aW9uIF9fZGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiAob2JqLl9fZXNNb2R1bGUgPyBvYmpbXCJkZWZhdWx0XCJdIDogb2JqKTsgfVxubW9kdWxlLmV4cG9ydHMgPSAoSGFuZGxlYmFyc1tcImRlZmF1bHRcIl0gfHwgSGFuZGxlYmFycykudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbOCxcIj49IDQuMy4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgYWxpYXMxPWNvbnRhaW5lci5sYW1iZGEsIGxvb2t1cFByb3BlcnR5ID0gY29udGFpbmVyLmxvb2t1cFByb3BlcnR5IHx8IGZ1bmN0aW9uKHBhcmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyZW50LCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9O1xuXG4gIHJldHVybiBcIjxtYWluIGNsYXNzPVxcXCJyZWxhdGl2ZSBoLXNjcmVlbiBvdmVyZmxvdy1oaWRkZW4gYmctZ3JheS0xMDAgZGFyazpiZy1ncmF5LTgwMFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZsZXggaXRlbXMtc3RhcnQganVzdGlmeS1iZXR3ZWVuXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgICBjbGFzcz1cXFwiLWxlZnQtODAgbGc6bGVmdC0wIHRyYW5zaXRpb24tYWxsIGFic29sdXRlIGxnOnJlbGF0aXZlIGgtc2NyZWVuIHNoYWRvdy1sZyBsZzpibG9jayB3LTgwIHotNTAgc2hyaW5rLTBcXFwiXFxuICAgICAgICAgICAgcmVmPVxcXCJkcmF3ZXJNZW51XFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImgtZnVsbCBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1zdGFydCBwdC02IG1sLThcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcInRleHQtMnhsIGZvbnQtYm9sZCBkYXJrOnRleHQtd2hpdGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIExpZ2hwYXNzIFYyXFxuICAgICAgICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8YzItbmF2IHJlZj1cXFwibmF2XFxcIj48L2MyLW5hdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmxleCBmbGV4LWNvbCB3LWZ1bGwgc3BhY2UteS0yIG1kOnNwYWNlLXktNFxcXCI+XFxuICAgICAgICAgICAgPGhlYWRlciBjbGFzcz1cXFwiei00MCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gdy1mdWxsIGgtMTZcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4IGZsZXgtY29sIGp1c3RpZnktZW5kIGgtZnVsbCBweC0zIGxnOmhpZGRlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWVuZCB3LWZ1bGwgcC0xIHNwYWNlLXgtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiZmxleCBpdGVtcy1jZW50ZXIgcC0yIHRleHQtZ3JheS01MDAgYmctd2hpdGUgcm91bmRlZC1mdWxsIHNoYWRvdyB0ZXh0LW1kXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9XFxcIm1lbnVCdG5cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidy02IGgtNlxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ0ZXh0LWdyYXktNDAwXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cXFwiMCAwIDE3OTIgMTc5MlxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVxcXCJNMTY2NCAxMzQ0djEyOHEwIDI2LTE5IDQ1dC00NSAxOWgtMTQwOHEtMjYgMC00NS0xOXQtMTktNDV2LTEyOHEwLTI2IDE5LTQ1dDQ1LTE5aDE0MDhxMjYgMCA0NSAxOXQxOSA0NXptMC01MTJ2MTI4cTAgMjYtMTkgNDV0LTQ1IDE5aC0xNDA4cS0yNiAwLTQ1LTE5dC0xOS00NXYtMTI4cTAtMjYgMTktNDV0NDUtMTloMTQwOHEyNiAwIDQ1IDE5dDE5IDQ1em0wLTUxMnYxMjhxMCAyNi0xOSA0NXQtNDUgMTloLTE0MDhxLTI2IDAtNDUtMTl0LTE5LTQ1di0xMjhxMC0yNiAxOS00NXQ0NS0xOWgxNDA4cTI2IDAgNDUgMTl0MTkgNDV6XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wYXRoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVsYXRpdmUgei0yMCBmbGV4IGZsZXgtY29sIGp1c3RpZnktZW5kIGgtZnVsbCBweC0zIG1kOnctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWVuZCB3LWZ1bGwgcC0xIHNwYWNlLXgtNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiZmxleCBpdGVtcy1jZW50ZXIgcC0yIHRleHQtcmVkLTYwMCBiZy13aGl0ZSByb3VuZGVkLWZ1bGwgc2hhZG93IGhvdmVyOnRleHQtZ3JheS03MDAgdGV4dC1tZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9XFxcIkNoaXVkaSBHYXJhXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9XFxcImNsb3NlUmFjZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmdcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LTYgaC02XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwtcnVsZT1cXFwiZXZlbm9kZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPVxcXCJNNS40NyA1LjQ3YS43NS43NSAwIDAxMS4wNiAwTDEyIDEwLjk0bDUuNDctNS40N2EuNzUuNzUgMCAxMTEuMDYgMS4wNkwxMy4wNiAxMmw1LjQ3IDUuNDdhLjc1Ljc1IDAgMTEtMS4wNiAxLjA2TDEyIDEzLjA2bC01LjQ3IDUuNDdhLjc1Ljc1IDAgMDEtMS4wNi0xLjA2TDEwLjk0IDEyIDUuNDcgNi41M2EuNzUuNzUgMCAwMTAtMS4wNnpcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcC1ydWxlPVxcXCJldmVub2RkXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9oZWFkZXI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaC1zY3JlZW4gcHgtNCBwYi0yNCBvdmVyZmxvdy1hdXRvIG1kOnB4LTZcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XFxcInRleHQtNHhsIGZvbnQtc2VtaWJvbGQgdGV4dC1ncmF5LTgwMCBkYXJrOnRleHQtd2hpdGUgbWItNFxcXCIgcmVmPVxcXCJkYXNoYm9hcmRUaXRsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICsgY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24oYWxpYXMxKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwibG9jYXRpb25cIikgOiBkZXB0aDApKSAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoc3RhY2sxLFwidGl0bGVcIikgOiBzdGFjazEpLCBkZXB0aDApKVxuICAgICsgXCJcXG4gICAgICAgICAgICAgICAgPC9oMT5cXG4gICAgICAgICAgICAgICAgPGRpdiByZWY9XFxcImRhc2hib2FyZENvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgXCJcbiAgICArICgoc3RhY2sxID0gYWxpYXMxKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwibG9jYXRpb25cIikgOiBkZXB0aDApKSAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoc3RhY2sxLFwiY29udGVudFwiKSA6IHN0YWNrMSksIGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9tYWluPlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7IiwidmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qc1wiKTtcbmZ1bmN0aW9uIF9fZGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiAob2JqLl9fZXNNb2R1bGUgPyBvYmpbXCJkZWZhdWx0XCJdIDogb2JqKTsgfVxubW9kdWxlLmV4cG9ydHMgPSAoSGFuZGxlYmFyc1tcImRlZmF1bHRcIl0gfHwgSGFuZGxlYmFycykudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSksIGFsaWFzMj1jb250YWluZXIuaG9va3MuaGVscGVyTWlzc2luZywgYWxpYXMzPVwiZnVuY3Rpb25cIiwgYWxpYXM0PWNvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uLCBsb29rdXBQcm9wZXJ0eSA9IGNvbnRhaW5lci5sb29rdXBQcm9wZXJ0eSB8fCBmdW5jdGlvbihwYXJlbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudCwgcHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfTtcblxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImlkXCIpIHx8IChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcImlkXCIpIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMiksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMyA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJpZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGEsXCJsb2NcIjp7XCJzdGFydFwiOntcImxpbmVcIjoxOSxcImNvbHVtblwiOjQ3fSxcImVuZFwiOntcImxpbmVcIjoxOSxcImNvbHVtblwiOjUzfX19KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgKyBhbGlhczQoKChoZWxwZXIgPSAoaGVscGVyID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcIm5hbWVcIikgfHwgKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwibmFtZVwiKSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczIpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczMgPyBoZWxwZXIuY2FsbChhbGlhczEse1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGEsXCJsb2NcIjp7XCJzdGFydFwiOntcImxpbmVcIjoyMCxcImNvbHVtblwiOjM2fSxcImVuZFwiOntcImxpbmVcIjoyMCxcImNvbHVtblwiOjQ0fX19KSA6IGhlbHBlcikpKVxuICAgICsgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxcblwiO1xufSxcImNvbXBpbGVyXCI6WzgsXCI+PSA0LjMuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBzdGFjazEsIGhlbHBlciwgYWxpYXMxPWRlcHRoMCAhPSBudWxsID8gZGVwdGgwIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSksIGxvb2t1cFByb3BlcnR5ID0gY29udGFpbmVyLmxvb2t1cFByb3BlcnR5IHx8IGZ1bmN0aW9uKHBhcmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyZW50LCBwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9O1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcImZsZXggZmxleC13cmFwIHctZnVsbFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZsZXggZmxleC1jb2wgdy1mdWxsIG1kOnctMS8yIGp1c3RpZnktY2VudGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgcHgtOCBwdC04IG15LTQgbWQ6cHQtMCBtZDpweC0yNCBsZzpweC0zMlxcXCI+XFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcInRleHQtM3hsIHRleHQtY2VudGVyXFxcIj5cXG4gICAgICAgICAgICAgICAgU2VsZXppb25lIHVuYSBHYXJhXFxuICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgIDxmb3JtIGNsYXNzPVxcXCJmbGV4IGZsZXgtY29sIHB0LTNcXFwiIHJlZj1cXFwic2VsZWN0UmFjZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZsZXggZmxleC1jb2wgcHQtNCBwYi00XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZsZXggcmVsYXRpdmVcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3RcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInctZnVsbCBibG9jayBweC0zIHB5LTIgdGV4dC1ncmF5LTcwMCBiZy13aGl0ZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQtbWQgc2hhZG93LXNtIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLXByaW1hcnktNTAwIGZvY3VzOmJvcmRlci1wcmltYXJ5LTUwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWxlemlvbmEgdW5hIGdhcmFcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9vcHRpb24+XFxuXCJcbiAgICArICgoc3RhY2sxID0gbG9va3VwUHJvcGVydHkoaGVscGVycyxcImVhY2hcIikuY2FsbChhbGlhczEsKGRlcHRoMCAhPSBudWxsID8gbG9va3VwUHJvcGVydHkoZGVwdGgwLFwib3B0aW9uc1wiKSA6IGRlcHRoMCkse1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjpjb250YWluZXIucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjpjb250YWluZXIubm9vcCxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6MTgsXCJjb2x1bW5cIjoyOH0sXCJlbmRcIjp7XCJsaW5lXCI6MjIsXCJjb2x1bW5cIjozN319fSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCIgICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwic3VibWl0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInctZnVsbCBweC00IHB5LTIgdGV4dC1iYXNlIGZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSBiZy1ncmF5LTUwMCByb3VuZGVkLWxnIHNoYWRvdy1tZCBob3ZlcjpiZy1ncmF5LTcwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS01MDAgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLW9mZnNldC1ncmF5LTIwMFxcXCJcXG4gICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgU2VsZXppb25hXFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZm9ybT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcXFwiPlxcbiAgICAgICAgICAgIDxociBjbGFzcz1cXFwidy0xNlxcXCIgLz5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJweC01XFxcIj5PPC9kaXY+XFxuICAgICAgICAgICAgPGhyIGNsYXNzPVxcXCJ3LTE2XFxcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIHB4LTggcHQtOCBteS00IG1kOnB0LTAgbWQ6cHgtMjQgbGc6cHgtMzJcXFwiPlxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ0ZXh0LTN4bCB0ZXh0LWNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgIENyZWEgdW5hIEdhcmFcXG4gICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgPGZvcm0gY2xhc3M9XFxcImZsZXggZmxleC1jb2wgcHQtMyBtZDpwdC04XFxcIiByZWY9XFxcImNyZWF0ZVJhY2VcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4IGZsZXgtY29sIHB0LTQgcGItNFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4IHJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImZsZXgtMSBhcHBlYXJhbmNlLW5vbmUgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCB3LWZ1bGwgcHktMiBweC00IGJnLXdoaXRlIHRleHQtZ3JheS03MDAgcGxhY2Vob2xkZXItZ3JheS00MDAgc2hhZG93LXNtIHRleHQtYmFzZSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctcHVycGxlLTYwMCBmb2N1czpib3JkZXItdHJhbnNwYXJlbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJlczogRSBCZW4gU2EgR2hlIDIwMjNcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImZsZXgtc2hyaW5rLTAgcHgtNCBweS0yIHRleHQtYmFzZSBmb250LXNlbWlib2xkIHRleHQtd2hpdGUgYmctZ3JheS01MDAgcm91bmRlZC1sZyBzaGFkb3ctbWQgaG92ZXI6YmctZ3JheS03MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNTAwIGZvY3VzOnJpbmctb2Zmc2V0LTIgZm9jdXM6cmluZy1vZmZzZXQtZ3JheS0yMDBcXFwiXFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJzdWJtaXRcXFwiXFxuICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ3LWZ1bGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIENyZWFcXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgPC9mb3JtPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ3LTEvMiBzaGFkb3ctMnhsXFxcIj5cXG4gICAgICAgIDxpbWcgY2xhc3M9XFxcImhpZGRlbiBvYmplY3QtY292ZXIgdy1mdWxsIGgtc2NyZWVuIG1kOmJsb2NrXFxcIiBzcmM9XFxcIlwiXG4gICAgKyBjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBsb29rdXBQcm9wZXJ0eShoZWxwZXJzLFwiaW1nXCIpIHx8IChkZXB0aDAgIT0gbnVsbCA/IGxvb2t1cFByb3BlcnR5KGRlcHRoMCxcImltZ1wiKSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBjb250YWluZXIuaG9va3MuaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IFwiZnVuY3Rpb25cIiA/IGhlbHBlci5jYWxsKGFsaWFzMSx7XCJuYW1lXCI6XCJpbWdcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhLFwibG9jXCI6e1wic3RhcnRcIjp7XCJsaW5lXCI6NjksXCJjb2x1bW5cIjo3MX0sXCJlbmRcIjp7XCJsaW5lXCI6NjksXCJjb2x1bW5cIjo3OH19fSkgOiBoZWxwZXIpKSlcbiAgICArIFwiXFxcIiAvPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pOyIsInZhciBIYW5kbGViYXJzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL3J1bnRpbWUuanNcIik7XG5mdW5jdGlvbiBfX2RlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgKG9iai5fX2VzTW9kdWxlID8gb2JqW1wiZGVmYXVsdFwiXSA6IG9iaik7IH1cbm1vZHVsZS5leHBvcnRzID0gKEhhbmRsZWJhcnNbXCJkZWZhdWx0XCJdIHx8IEhhbmRsZWJhcnMpLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzgsXCI+PSA0LjMuMFwiXSxcIm1haW5cIjpmdW5jdGlvbihjb250YWluZXIsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcImxnOmZsZXggdy1mdWxsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsIGxnOnctMi8zIGxnOnByLTJcXFwiPlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWItOFxcXCI+XFxuICAgICAgICAgICAgPGMxLXRhYmxlXFxuICAgICAgICAgICAgICAgIGxhYmVscz1cXFwiaWQsRGF0YVxcXCJcXG4gICAgICAgICAgICAgICAga2V5cz1cXFwiaWQsdGltZVxcXCJcXG4gICAgICAgICAgICAgICAgb3JkZXJCeT1cXFwidGltZVxcXCJcXG4gICAgICAgICAgICAgICAgcm93c0tleT1cXFwidGltZVxcXCJcXG4gICAgICAgICAgICAgICAgb3JkZXJEaXI9XFxcImRlc2NcXFwiXFxuICAgICAgICAgICAgICAgIGVkaXRFbmFibGVkPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICAgICAgICB0aXRsZT1cXFwiVGVtcGkgbm9uIGFzc2VnbmF0aVxcXCJcXG4gICAgICAgICAgICAgICAgcmVmPVxcXCJ0aW1lVGFibGVcXFwiXFxuICAgICAgICAgICAgPjwvYzEtdGFibGU+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgPGMxLXRhYmxlXFxuICAgICAgICAgICAgICAgIGxhYmVscz1cXFwiSUQsVGltZSxQUyxEYXRhLE5vbWUsTnVtXFxcIlxcbiAgICAgICAgICAgICAgICBrZXlzPVxcXCJpZCxhc3NpZ25lZElkVGltZSxhc3NpZ25lZFBzLGFzc2lnbmVkVGltZSxhc3NpZ25lZE5hbWUsYXNzaWduZWRcXFwiXFxuICAgICAgICAgICAgICAgIGZpbHRlcktleT1cXFwiYXNzaWduZWROYW1lXFxcIlxcbiAgICAgICAgICAgICAgICBvcmRlckJ5PVxcXCJhc3NpZ25lZFxcXCJcXG4gICAgICAgICAgICAgICAgcm93c0tleT1cXFwidGFrZVxcXCJcXG4gICAgICAgICAgICAgICAgdGl0bGU9XFxcIlRlbXBpIGFzc2VnbmF0aVxcXCJcXG4gICAgICAgICAgICAgICAgcmVmPVxcXCJ0YWtlVGFibGVcXFwiXFxuICAgICAgICAgICAgPjwvYzEtdGFibGU+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBsZzp3LTEvM1xcXCI+XFxuICAgICAgICA8Zm9ybVxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdyBzbTptYXgtdy1tZCBzbTp3LWZ1bGwgc206bXgtYXV0byBzbTpvdmVyZmxvdy1oaWRkZW4gdHJhbnNpdGlvbi1jb2xvcnNcXFwiXFxuICAgICAgICAgICAgcmVmPVxcXCJhc3NpZ25UaW1lXFxcIlxcbiAgICAgICAgPlxcblxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB4LTQgcHktOCBzbTpweC0xMFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlIG10LTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVsYXRpdmUgZmxleCBqdXN0aWZ5LWNlbnRlciB0ZXh0LWJhc2UgbGVhZGluZy01IGZvbnQtc2VtaWJvbGRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJweC0yIHRleHQtZ3JheS01MDBcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NlZ25hXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBzcGFjZS15LTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInJvdW5kZWQtbGcgZmxleC0xIGFwcGVhcmFuY2Utbm9uZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHctZnVsbCBweS0yIHB4LTQgYmctd2hpdGUgdGV4dC1ncmF5LTcwMCBwbGFjZWhvbGRlci1ncmF5LTQwMCBzaGFkb3ctc20gdGV4dC1iYXNlIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTYwMCBmb2N1czpib3JkZXItdHJhbnNwYXJlbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiVGltZSBJRFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJpZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVsYXRpdmVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwicm91bmRlZC1sZyBmbGV4LTEgYXBwZWFyYW5jZS1ub25lIGJvcmRlciBib3JkZXItZ3JheS0zMDAgdy1mdWxsIHB5LTIgcHgtNCBiZy13aGl0ZSB0ZXh0LWdyYXktNzAwIHBsYWNlaG9sZGVyLWdyYXktNDAwIHNoYWRvdy1zbSB0ZXh0LWJhc2UgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNjAwIGZvY3VzOmJvcmRlci10cmFuc3BhcmVudFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJUaW1lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XFxcInRpbWVTdHJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInJvdW5kZWQtbGcgZmxleC0xIGFwcGVhcmFuY2Utbm9uZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHctZnVsbCBweS0yIHB4LTQgYmctd2hpdGUgdGV4dC1ncmF5LTcwMCBwbGFjZWhvbGRlci1ncmF5LTQwMCBzaGFkb3ctc20gdGV4dC1iYXNlIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTYwMCBmb2N1czpib3JkZXItdHJhbnNwYXJlbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiUFNcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cXFwicHNOYW1lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVsYXRpdmVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwicm91bmRlZC1sZyBmbGV4LTEgYXBwZWFyYW5jZS1ub25lIGJvcmRlciBib3JkZXItZ3JheS0zMDAgdy1mdWxsIHB5LTIgcHgtNCBiZy13aGl0ZSB0ZXh0LWdyYXktNzAwIHBsYWNlaG9sZGVyLWdyYXktNDAwIHNoYWRvdy1zbSB0ZXh0LWJhc2UgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNjAwIGZvY3VzOmJvcmRlci10cmFuc3BhcmVudFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJDb3JyaWRvcmUgKE51bWVybylcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cXFwicnVubmVyTnVtXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInctZnVsbCBweC00IHB5LTIgdGV4dC1iYXNlIGZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSBiZy1ncmF5LTUwMCByb3VuZGVkLWxnIHNoYWRvdy1tZCBob3ZlcjpiZy1ncmF5LTcwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS01MDAgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLW9mZnNldC1ncmF5LTIwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInN1Ym1pdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzZWduYVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZm9ybT5cXG5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTsiLCJ2YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzXCIpO1xuZnVuY3Rpb24gX19kZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIChvYmouX19lc01vZHVsZSA/IG9ialtcImRlZmF1bHRcIl0gOiBvYmopOyB9XG5tb2R1bGUuZXhwb3J0cyA9IChIYW5kbGViYXJzW1wiZGVmYXVsdFwiXSB8fCBIYW5kbGViYXJzKS50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls4LFwiPj0gNC4zLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJsZzpmbGV4IHctZnVsbFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBsZzp3LTIvMyBsZzpwci0yXFxcIj5cXG4gICAgICAgIDxjMS10YWJsZVxcbiAgICAgICAgICAgIGxhYmVscz1cXFwiSUQsTm9tZSxHYXAsU3RhcnQsT3JkaW5lXFxcIlxcbiAgICAgICAgICAgIGtleXM9XFxcImlkLG5hbWUsZ2FwLHN0YXJ0LG9yZGVyXFxcIlxcbiAgICAgICAgICAgIGZpbHRlcktleT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICBvcmRlckJ5PVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgIHJlZj1cXFwidGFibGVcXFwiXFxuICAgICAgICA+PC9jMS10YWJsZT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBsZzp3LTEvM1xcXCI+XFxuXFxuICAgICAgICA8Zm9ybSBjbGFzcz1cXFwiYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3cgc206bWF4LXctbWQgc206dy1mdWxsIHNtOm14LWF1dG8gc206b3ZlcmZsb3ctaGlkZGVuXFxcIiByZWY9XFxcImNyZWF0ZVBzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJweC00IHB5LTggc206cHgtMTBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZSBtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlIGZsZXgganVzdGlmeS1jZW50ZXIgdGV4dC1iYXNlIGxlYWRpbmctNSBmb250LXNlbWlib2xkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicHgtMiB0ZXh0LWdyYXktNTAwIGJnLXdoaXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVvdmEgUFNcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm10LTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsIHNwYWNlLXktNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVsYXRpdmVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwicm91bmRlZC1sZyBmbGV4LTEgYXBwZWFyYW5jZS1ub25lIGJvcmRlciBib3JkZXItZ3JheS0zMDAgdy1mdWxsIHB5LTIgcHgtNCBiZy13aGl0ZSB0ZXh0LWdyYXktNzAwIHBsYWNlaG9sZGVyLWdyYXktNDAwIHNoYWRvdy1zbSB0ZXh0LWJhc2UgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNjAwIGZvY3VzOmJvcmRlci10cmFuc3BhcmVudFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJOb21lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJkYXRldGltZS1sb2NhbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwicm91bmRlZC1sZyBmbGV4LTEgYXBwZWFyYW5jZS1ub25lIGJvcmRlciBib3JkZXItZ3JheS0zMDAgdy1mdWxsIHB5LTIgcHgtNCBiZy13aGl0ZSB0ZXh0LWdyYXktNzAwIHBsYWNlaG9sZGVyLWdyYXktNDAwIHNoYWRvdy1zbSB0ZXh0LWJhc2UgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNjAwIGZvY3VzOmJvcmRlci10cmFuc3BhcmVudFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJTdGFydFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJzdGFydFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInJvdW5kZWQtbGcgZmxleC0xIGFwcGVhcmFuY2Utbm9uZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHctZnVsbCBweS0yIHB4LTQgYmctd2hpdGUgdGV4dC1ncmF5LTcwMCBwbGFjZWhvbGRlci1ncmF5LTQwMCBzaGFkb3ctc20gdGV4dC1iYXNlIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTYwMCBmb2N1czpib3JkZXItdHJhbnNwYXJlbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIkdhcFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XFxcImdhcFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuPVxcXCJbMC05XStcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInctZnVsbCBibG9jayBweC0zIHB5LTIgdGV4dC1ncmF5LTcwMCBiZy13aGl0ZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQtbWQgc2hhZG93LXNtIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLXByaW1hcnktNTAwIGZvY3VzOmJvcmRlci1wcmltYXJ5LTUwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJvcmRlclxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcImFzY1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENyZXNjZW50ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcImRlc2NcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWNyZXNjZW50ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LWZ1bGwgcHgtNCBweS0yIHRleHQtYmFzZSBmb250LXNlbWlib2xkIHRleHQtd2hpdGUgYmctZ3JheS01MDAgcm91bmRlZC1sZyBzaGFkb3ctbWQgaG92ZXI6YmctZ3JheS03MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNTAwIGZvY3VzOnJpbmctb2Zmc2V0LTIgZm9jdXM6cmluZy1vZmZzZXQtZ3JheS0yMDBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJzdWJtaXRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENyZWFcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Zvcm0+XFxuXFxuICAgICAgICA8Zm9ybSBjbGFzcz1cXFwiYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3cgc206bWF4LXctbWQgc206dy1mdWxsIHNtOm14LWF1dG8gc206b3ZlcmZsb3ctaGlkZGVuXFxcIiByZWY9XFxcInVwbG9hZFBzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJweC00IHB5LTggc206cHgtMTBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZSBtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlIGZsZXgganVzdGlmeS1jZW50ZXIgdGV4dC1iYXNlIGxlYWRpbmctNSBmb250LXNlbWlib2xkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicHgtMiB0ZXh0LWdyYXktNTAwIGJnLXdoaXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FyaWNhIFBTXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBzcGFjZS15LTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcImZpbGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInJvdW5kZWQtbGcgZmxleC0xIGFwcGVhcmFuY2Utbm9uZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHctZnVsbCBweS0yIHB4LTQgYmctd2hpdGUgdGV4dC1ncmF5LTcwMCBwbGFjZWhvbGRlci1ncmF5LTQwMCBzaGFkb3ctc20gdGV4dC1iYXNlIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTYwMCBmb2N1czpib3JkZXItdHJhbnNwYXJlbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIkZpbGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJmaWxlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm49XFxcIlswLTldK1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LWZ1bGwgcHgtNCBweS0yIHRleHQtYmFzZSBmb250LXNlbWlib2xkIHRleHQtd2hpdGUgYmctZ3JheS01MDAgcm91bmRlZC1sZyBzaGFkb3ctbWQgaG92ZXI6YmctZ3JheS03MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNTAwIGZvY3VzOnJpbmctb2Zmc2V0LTIgZm9jdXM6cmluZy1vZmZzZXQtZ3JheS0yMDBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJzdWJtaXRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhcmljYVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZm9ybT5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93IHNtOm1heC13LW1kIHNtOnctZnVsbCBzbTpteC1hdXRvIHNtOm92ZXJmbG93LWhpZGRlblxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHgtNCBweS04IHNtOnB4LTEwXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibXQtNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGwgc3BhY2UteS02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidy1mdWxsIHB4LTQgcHktMiB0ZXh0LWJhc2UgZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlIGJnLWdyYXktNTAwIHJvdW5kZWQtbGcgc2hhZG93LW1kIGhvdmVyOmJnLWdyYXktNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTUwMCBmb2N1czpyaW5nLW9mZnNldC0yIGZvY3VzOnJpbmctb2Zmc2V0LWdyYXktMjAwXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmPVxcXCJkb3dubG9hZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NhcmljYSBDU1ZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTsiLCJ2YXIgSGFuZGxlYmFycyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzXCIpO1xuZnVuY3Rpb24gX19kZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIChvYmouX19lc01vZHVsZSA/IG9ialtcImRlZmF1bHRcIl0gOiBvYmopOyB9XG5tb2R1bGUuZXhwb3J0cyA9IChIYW5kbGViYXJzW1wiZGVmYXVsdFwiXSB8fCBIYW5kbGViYXJzKS50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls4LFwiPj0gNC4zLjBcIl0sXCJtYWluXCI6ZnVuY3Rpb24oY29udGFpbmVyLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJsZzpmbGV4IHctZnVsbFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBsZzp3LTIvMyBsZzpwci0yXFxcIj5cXG4gICAgICAgIDxjMS10YWJsZVxcbiAgICAgICAgICAgIGxhYmVscz1cXFwiSUQsTm9tZSxOdW1lcm8sQ2F0ZWdvcmlhXFxcIlxcbiAgICAgICAgICAgIGtleXM9XFxcImlkLG5hbWUsbnVtYmVyLGNhdGVnb3J5XFxcIlxcbiAgICAgICAgICAgIGZpbHRlcktleT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICBvcmRlckJ5PVxcXCJudW1iZXJcXFwiXFxuICAgICAgICAgICAgcmVmPVxcXCJ0YWJsZVxcXCJcXG4gICAgICAgID48L2MxLXRhYmxlPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsIGxnOnctMS8zXFxcIj5cXG5cXG4gICAgICAgIDxmb3JtIGNsYXNzPVxcXCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdyBzbTptYXgtdy1tZCBzbTp3LWZ1bGwgc206bXgtYXV0byBzbTpvdmVyZmxvdy1oaWRkZW5cXFwiIHJlZj1cXFwiY3JlYXRlUnVubmVyXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJweC00IHB5LTggc206cHgtMTBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZSBtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlIGZsZXgganVzdGlmeS1jZW50ZXIgdGV4dC1iYXNlIGxlYWRpbmctNSBmb250LXNlbWlib2xkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicHgtMiB0ZXh0LWdyYXktNTAwIGJnLXdoaXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVvdm8gQ29ycmlkb3JlXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBzcGFjZS15LTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInJvdW5kZWQtbGcgZmxleC0xIGFwcGVhcmFuY2Utbm9uZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHctZnVsbCBweS0yIHB4LTQgYmctd2hpdGUgdGV4dC1ncmF5LTcwMCBwbGFjZWhvbGRlci1ncmF5LTQwMCBzaGFkb3ctc20gdGV4dC1iYXNlIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTYwMCBmb2N1czpib3JkZXItdHJhbnNwYXJlbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiTm9tZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVsYXRpdmVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwicm91bmRlZC1sZyBmbGV4LTEgYXBwZWFyYW5jZS1ub25lIGJvcmRlciBib3JkZXItZ3JheS0zMDAgdy1mdWxsIHB5LTIgcHgtNCBiZy13aGl0ZSB0ZXh0LWdyYXktNzAwIHBsYWNlaG9sZGVyLWdyYXktNDAwIHNoYWRvdy1zbSB0ZXh0LWJhc2UgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNjAwIGZvY3VzOmJvcmRlci10cmFuc3BhcmVudFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiTnVtZXJvXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cXFwibnVtYmVyXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm49XFxcIlswLTldK1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInJvdW5kZWQtbGcgZmxleC0xIGFwcGVhcmFuY2Utbm9uZSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHctZnVsbCBweS0yIHB4LTQgYmctd2hpdGUgdGV4dC1ncmF5LTcwMCBwbGFjZWhvbGRlci1ncmF5LTQwMCBzaGFkb3ctc20gdGV4dC1iYXNlIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTYwMCBmb2N1czpib3JkZXItdHJhbnNwYXJlbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIkNhdGVnb3JpYVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XFxcImNhdGVnb3J5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInctZnVsbCBweC00IHB5LTIgdGV4dC1iYXNlIGZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSBiZy1ncmF5LTUwMCByb3VuZGVkLWxnIHNoYWRvdy1tZCBob3ZlcjpiZy1ncmF5LTcwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS01MDAgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLW9mZnNldC1ncmF5LTIwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcInN1Ym1pdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3JlYVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZm9ybT5cXG5cXG4gICAgICAgIDxmb3JtIGNsYXNzPVxcXCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdyBzbTptYXgtdy1tZCBzbTp3LWZ1bGwgc206bXgtYXV0byBzbTpvdmVyZmxvdy1oaWRkZW5cXFwiIHJlZj1cXFwidXBsb2FkUnVubmVyXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJweC00IHB5LTggc206cHgtMTBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZSBtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlbGF0aXZlIGZsZXgganVzdGlmeS1jZW50ZXIgdGV4dC1iYXNlIGxlYWRpbmctNSBmb250LXNlbWlib2xkXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwicHgtMiB0ZXh0LWdyYXktNTAwIGJnLXdoaXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FyaWNhIENvcnJpZG9yaVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibXQtNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGwgc3BhY2UteS02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGxcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyZWxhdGl2ZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJmaWxlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJyb3VuZGVkLWxnIGZsZXgtMSBhcHBlYXJhbmNlLW5vbmUgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCB3LWZ1bGwgcHktMiBweC00IGJnLXdoaXRlIHRleHQtZ3JheS03MDAgcGxhY2Vob2xkZXItZ3JheS00MDAgc2hhZG93LXNtIHRleHQtYmFzZSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS02MDAgZm9jdXM6Ym9yZGVyLXRyYW5zcGFyZW50XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJGaWxlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cXFwiZmlsZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuPVxcXCJbMC05XStcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGxcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwidy1mdWxsIHB4LTQgcHktMiB0ZXh0LWJhc2UgZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlIGJnLWdyYXktNTAwIHJvdW5kZWQtbGcgc2hhZG93LW1kIGhvdmVyOmJnLWdyYXktNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTUwMCBmb2N1czpyaW5nLW9mZnNldC0yIGZvY3VzOnJpbmctb2Zmc2V0LWdyYXktMjAwXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cXFwic3VibWl0XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYXJpY2FcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Zvcm0+XFxuXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdyBzbTptYXgtdy1tZCBzbTp3LWZ1bGwgc206bXgtYXV0byBzbTpvdmVyZmxvdy1oaWRkZW5cXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInB4LTQgcHktOCBzbTpweC0xMFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm10LTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsIHNwYWNlLXktNlxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidy1mdWxsXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcInctZnVsbCBweC00IHB5LTIgdGV4dC1iYXNlIGZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSBiZy1ncmF5LTUwMCByb3VuZGVkLWxnIHNoYWRvdy1tZCBob3ZlcjpiZy1ncmF5LTcwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS01MDAgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLW9mZnNldC1ncmF5LTIwMFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZj1cXFwiZG93bmxvYWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNjYXJpY2EgQ1NWXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7IiwidmFyIEhhbmRsZWJhcnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qc1wiKTtcbmZ1bmN0aW9uIF9fZGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiAob2JqLl9fZXNNb2R1bGUgPyBvYmpbXCJkZWZhdWx0XCJdIDogb2JqKTsgfVxubW9kdWxlLmV4cG9ydHMgPSAoSGFuZGxlYmFyc1tcImRlZmF1bHRcIl0gfHwgSGFuZGxlYmFycykudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbOCxcIj49IDQuMy4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwibGc6ZmxleCB3LWZ1bGxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ3LWZ1bGwgbGc6dy0yLzMgbGc6cHItMlxcXCI+XFxuICAgICAgICA8YzEtdGFibGVcXG4gICAgICAgICAgICBsYWJlbHM9XFxcIklELE51bWVybyxOb21lLFN0YXJ0LEVuZCxEaWZmXFxcIlxcbiAgICAgICAgICAgIGtleXM9XFxcImlkLG51bWJlcixuYW1lLHN0YXJ0LGVuZCxkaWZmXFxcIlxcbiAgICAgICAgICAgIGZpbHRlcktleT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICBvcmRlckJ5PVxcXCJkaWZmXFxcIlxcbiAgICAgICAgICAgIGFjdGlvbkRpc2FibGVkPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICAgIHJlZj1cXFwidGFibGVcXFwiXFxuICAgICAgICA+PC9jMS10YWJsZT5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBsZzp3LTEvM1xcXCI+XFxuICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmctd2hpdGUgcm91bmRlZC1sZyBzaGFkb3cgc206bWF4LXctbWQgc206dy1mdWxsIHNtOm14LWF1dG8gc206b3ZlcmZsb3ctaGlkZGVuXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJweC00IHB5LTggc206cHgtMTBcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtdC02XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbCBzcGFjZS15LTZcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInctZnVsbFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJ3LWZ1bGwgcHgtNCBweS0yIHRleHQtYmFzZSBmb250LXNlbWlib2xkIHRleHQtd2hpdGUgYmctZ3JheS01MDAgcm91bmRlZC1sZyBzaGFkb3ctbWQgaG92ZXI6YmctZ3JheS03MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktNTAwIGZvY3VzOnJpbmctb2Zmc2V0LTIgZm9jdXM6cmluZy1vZmZzZXQtZ3JheS0yMDBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY9XFxcImRvd25sb2FkXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTY2FyaWNhIENTVlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pOyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8qXG4gKiBEZXhpZS5qcyAtIGEgbWluaW1hbGlzdGljIHdyYXBwZXIgZm9yIEluZGV4ZWREQlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCeSBEYXZpZCBGYWhsYW5kZXIsIGRhdmlkLmZhaGxhbmRlckBnbWFpbC5jb21cbiAqXG4gKiBWZXJzaW9uIDMuMi4zLCBNb24gSmFuIDIzIDIwMjNcbiAqXG4gKiBodHRwczovL2RleGllLm9yZ1xuICpcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9cbiAqL1xuIFxuY29uc3QgX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOlxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6XG4gICAgICAgICAgICBnbG9iYWw7XG5cbmNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKSB7XG4gICAgX2dsb2JhbC5Qcm9taXNlID0gUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGV4dGVuZChvYmosIGV4dGVuc2lvbikge1xuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICBrZXlzKGV4dGVuc2lvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIG9ialtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuY29uc3QgX2hhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcbn1cbmZ1bmN0aW9uIHByb3BzKHByb3RvLCBleHRlbnNpb24pIHtcbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGdldFByb3RvKHByb3RvKSk7XG4gICAgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8ga2V5cyA6IFJlZmxlY3Qub3duS2V5cykoZXh0ZW5zaW9uKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHNldFByb3AocHJvdG8sIGtleSwgZXh0ZW5zaW9uW2tleV0pO1xuICAgIH0pO1xufVxuY29uc3QgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5mdW5jdGlvbiBzZXRQcm9wKG9iaiwgcHJvcCwgZnVuY3Rpb25PckdldFNldCwgb3B0aW9ucykge1xuICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgZ2V0OiBmdW5jdGlvbk9yR2V0U2V0LmdldCwgc2V0OiBmdW5jdGlvbk9yR2V0U2V0LnNldCwgY29uZmlndXJhYmxlOiB0cnVlIH0gOlxuICAgICAgICB7IHZhbHVlOiBmdW5jdGlvbk9yR2V0U2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZShDaGlsZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGZ1bmN0aW9uIChQYXJlbnQpIHtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBzZXRQcm9wKENoaWxkLnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4dGVuZDogcHJvcHMuYmluZChudWxsLCBDaGlsZC5wcm90b3R5cGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG4gICAgY29uc3QgcGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICBsZXQgcHJvdG87XG4gICAgcmV0dXJuIHBkIHx8IChwcm90byA9IGdldFByb3RvKG9iaikpICYmIGdldFByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG59XG5jb25zdCBfc2xpY2UgPSBbXS5zbGljZTtcbmZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJncywgc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZShvcmlnRnVuYywgb3ZlcnJpZGVkRmFjdG9yeSkge1xuICAgIHJldHVybiBvdmVycmlkZWRGYWN0b3J5KG9yaWdGdW5jKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChiKSB7XG4gICAgaWYgKCFiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xufVxuZnVuY3Rpb24gYXNhcCQxKGZuKSB7XG4gICAgaWYgKF9nbG9iYWwuc2V0SW1tZWRpYXRlKVxuICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIGVsc2VcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG59XG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFycmF5LCBleHRyYWN0b3IpIHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChyZXN1bHQsIGl0ZW0sIGkpID0+IHtcbiAgICAgICAgdmFyIG5hbWVBbmRWYWx1ZSA9IGV4dHJhY3RvcihpdGVtLCBpKTtcbiAgICAgICAgaWYgKG5hbWVBbmRWYWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvbmVycm9yLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICBvbmVycm9yICYmIG9uZXJyb3IoZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICBpZiAoaGFzT3duKG9iaiwga2V5UGF0aCkpXG4gICAgICAgIHJldHVybiBvYmpba2V5UGF0aF07XG4gICAgaWYgKCFrZXlQYXRoKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoW2ldKTtcbiAgICAgICAgICAgIHJ2LnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICB2YXIgaW5uZXJPYmogPSBvYmpba2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKV07XG4gICAgICAgIHJldHVybiBpbm5lck9iaiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZ2V0QnlLZXlQYXRoKGlubmVyT2JqLCBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB2YWx1ZSkge1xuICAgIGlmICghb2JqIHx8IGtleVBhdGggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICgnaXNGcm96ZW4nIGluIE9iamVjdCAmJiBPYmplY3QuaXNGcm96ZW4ob2JqKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4ga2V5UGF0aCkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiB2YWx1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0sIHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nS2V5UGF0aCA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChjdXJyZW50S2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNwbGljZShjdXJyZW50S2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbY3VycmVudEtleVBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9ialtjdXJyZW50S2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lck9iaiB8fCAhaGFzT3duKG9iaiwgY3VycmVudEtleVBhdGgpKVxuICAgICAgICAgICAgICAgICAgICBpbm5lck9iaiA9IChvYmpbY3VycmVudEtleVBhdGhdID0ge30pO1xuICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbm5lck9iaiwgcmVtYWluaW5nS2V5UGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChrZXlQYXRoKSkpXG4gICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2Uoa2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9ialtrZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGVsQnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHVuZGVmaW5lZCk7XG4gICAgZWxzZSBpZiAoJ2xlbmd0aCcgaW4ga2V5UGF0aClcbiAgICAgICAgW10ubWFwLmNhbGwoa2V5UGF0aCwgZnVuY3Rpb24gKGtwKSB7XG4gICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrcCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUob2JqKSB7XG4gICAgdmFyIHJ2ID0ge307XG4gICAgZm9yICh2YXIgbSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093bihvYmosIG0pKVxuICAgICAgICAgICAgcnZbbV0gPSBvYmpbbV07XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbmNvbnN0IGNvbmNhdCA9IFtdLmNvbmNhdDtcbmZ1bmN0aW9uIGZsYXR0ZW4oYSkge1xuICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xufVxuY29uc3QgaW50cmluc2ljVHlwZU5hbWVzID0gXCJCb29sZWFuLFN0cmluZyxEYXRlLFJlZ0V4cCxCbG9iLEZpbGUsRmlsZUxpc3QsRmlsZVN5c3RlbUZpbGVIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcbiAgICAuc3BsaXQoJywnKS5jb25jYXQoZmxhdHRlbihbOCwgMTYsIDMyLCA2NF0ubWFwKG51bSA9PiBbXCJJbnRcIiwgXCJVaW50XCIsIFwiRmxvYXRcIl0ubWFwKHQgPT4gdCArIG51bSArIFwiQXJyYXlcIikpKSkuZmlsdGVyKHQgPT4gX2dsb2JhbFt0XSk7XG5jb25zdCBpbnRyaW5zaWNUeXBlcyA9IGludHJpbnNpY1R5cGVOYW1lcy5tYXAodCA9PiBfZ2xvYmFsW3RdKTtcbmFycmF5VG9PYmplY3QoaW50cmluc2ljVHlwZU5hbWVzLCB4ID0+IFt4LCB0cnVlXSk7XG5sZXQgY2lyY3VsYXJSZWZzID0gbnVsbDtcbmZ1bmN0aW9uIGRlZXBDbG9uZShhbnkpIHtcbiAgICBjaXJjdWxhclJlZnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBydiA9IGlubmVyRGVlcENsb25lKGFueSk7XG4gICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBpbm5lckRlZXBDbG9uZShhbnkpIHtcbiAgICBpZiAoIWFueSB8fCB0eXBlb2YgYW55ICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGFueTtcbiAgICBsZXQgcnYgPSBjaXJjdWxhclJlZnMgJiYgY2lyY3VsYXJSZWZzLmdldChhbnkpO1xuICAgIGlmIChydilcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIGlmIChpc0FycmF5KGFueSkpIHtcbiAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYW55Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcnYucHVzaChpbm5lckRlZXBDbG9uZShhbnlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnRyaW5zaWNUeXBlcy5pbmRleE9mKGFueS5jb25zdHJ1Y3RvcikgPj0gMCkge1xuICAgICAgICBydiA9IGFueTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8oYW55KTtcbiAgICAgICAgcnYgPSBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgIGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuc2V0KGFueSwgcnYpO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFueSkge1xuICAgICAgICAgICAgaWYgKGhhc093bihhbnksIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZShhbnlbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbmNvbnN0IHsgdG9TdHJpbmcgfSA9IHt9O1xuZnVuY3Rpb24gdG9TdHJpbmdUYWcobykge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbn1cbmNvbnN0IGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgIFN5bWJvbC5pdGVyYXRvciA6XG4gICAgJ0BAaXRlcmF0b3InO1xuY29uc3QgZ2V0SXRlcmF0b3JPZiA9IHR5cGVvZiBpdGVyYXRvclN5bWJvbCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIGk7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiAoaSA9IHhbaXRlcmF0b3JTeW1ib2xdKSAmJiBpLmFwcGx5KHgpO1xufSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG5jb25zdCBOT19DSEFSX0FSUkFZID0ge307XG5mdW5jdGlvbiBnZXRBcnJheU9mKGFycmF5TGlrZSkge1xuICAgIHZhciBpLCBhLCB4LCBpdDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheUxpa2UpKVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5TGlrZS5zbGljZSgpO1xuICAgICAgICBpZiAodGhpcyA9PT0gTk9fQ0hBUl9BUlJBWSAmJiB0eXBlb2YgYXJyYXlMaWtlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaWYgKChpdCA9IGdldEl0ZXJhdG9yT2YoYXJyYXlMaWtlKSkpIHtcbiAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICgoeCA9IGl0Lm5leHQoKSksICF4LmRvbmUpXG4gICAgICAgICAgICAgICAgYS5wdXNoKHgudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5TGlrZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgYVtpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICB9XG4gICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBhW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBhO1xufVxuY29uc3QgaXNBc3luY0Z1bmN0aW9uID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChmbikgPT4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nXG4gICAgOiAoKSA9PiBmYWxzZTtcblxudmFyIGRlYnVnID0gdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIC9eKGh0dHB8aHR0cHMpOlxcL1xcLyhsb2NhbGhvc3R8MTI3XFwuMFxcLjBcXC4xKS8udGVzdChsb2NhdGlvbi5ocmVmKTtcbmZ1bmN0aW9uIHNldERlYnVnKHZhbHVlLCBmaWx0ZXIpIHtcbiAgICBkZWJ1ZyA9IHZhbHVlO1xuICAgIGxpYnJhcnlGaWx0ZXIgPSBmaWx0ZXI7XG59XG52YXIgbGlicmFyeUZpbHRlciA9ICgpID0+IHRydWU7XG5jb25zdCBORUVEU19USFJPV19GT1JfU1RBQ0sgPSAhbmV3IEVycm9yKFwiXCIpLnN0YWNrO1xuZnVuY3Rpb24gZ2V0RXJyb3JXaXRoU3RhY2soKSB7XG4gICAgaWYgKE5FRURTX1RIUk9XX0ZPUl9TVEFDSylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdldEVycm9yV2l0aFN0YWNrLmFyZ3VtZW50cztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoKTtcbn1cbmZ1bmN0aW9uIHByZXR0eVN0YWNrKGV4Y2VwdGlvbiwgbnVtSWdub3JlZEZyYW1lcykge1xuICAgIHZhciBzdGFjayA9IGV4Y2VwdGlvbi5zdGFjaztcbiAgICBpZiAoIXN0YWNrKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICBudW1JZ25vcmVkRnJhbWVzID0gKG51bUlnbm9yZWRGcmFtZXMgfHwgMCk7XG4gICAgaWYgKHN0YWNrLmluZGV4T2YoZXhjZXB0aW9uLm5hbWUpID09PSAwKVxuICAgICAgICBudW1JZ25vcmVkRnJhbWVzICs9IChleGNlcHRpb24ubmFtZSArIGV4Y2VwdGlvbi5tZXNzYWdlKS5zcGxpdCgnXFxuJykubGVuZ3RoO1xuICAgIHJldHVybiBzdGFjay5zcGxpdCgnXFxuJylcbiAgICAgICAgLnNsaWNlKG51bUlnbm9yZWRGcmFtZXMpXG4gICAgICAgIC5maWx0ZXIobGlicmFyeUZpbHRlcilcbiAgICAgICAgLm1hcChmcmFtZSA9PiBcIlxcblwiICsgZnJhbWUpXG4gICAgICAgIC5qb2luKCcnKTtcbn1cblxudmFyIGRleGllRXJyb3JOYW1lcyA9IFtcbiAgICAnTW9kaWZ5JyxcbiAgICAnQnVsaycsXG4gICAgJ09wZW5GYWlsZWQnLFxuICAgICdWZXJzaW9uQ2hhbmdlJyxcbiAgICAnU2NoZW1hJyxcbiAgICAnVXBncmFkZScsXG4gICAgJ0ludmFsaWRUYWJsZScsXG4gICAgJ01pc3NpbmdBUEknLFxuICAgICdOb1N1Y2hEYXRhYmFzZScsXG4gICAgJ0ludmFsaWRBcmd1bWVudCcsXG4gICAgJ1N1YlRyYW5zYWN0aW9uJyxcbiAgICAnVW5zdXBwb3J0ZWQnLFxuICAgICdJbnRlcm5hbCcsXG4gICAgJ0RhdGFiYXNlQ2xvc2VkJyxcbiAgICAnUHJlbWF0dXJlQ29tbWl0JyxcbiAgICAnRm9yZWlnbkF3YWl0J1xuXTtcbnZhciBpZGJEb21FcnJvck5hbWVzID0gW1xuICAgICdVbmtub3duJyxcbiAgICAnQ29uc3RyYWludCcsXG4gICAgJ0RhdGEnLFxuICAgICdUcmFuc2FjdGlvbkluYWN0aXZlJyxcbiAgICAnUmVhZE9ubHknLFxuICAgICdWZXJzaW9uJyxcbiAgICAnTm90Rm91bmQnLFxuICAgICdJbnZhbGlkU3RhdGUnLFxuICAgICdJbnZhbGlkQWNjZXNzJyxcbiAgICAnQWJvcnQnLFxuICAgICdUaW1lb3V0JyxcbiAgICAnUXVvdGFFeGNlZWRlZCcsXG4gICAgJ1N5bnRheCcsXG4gICAgJ0RhdGFDbG9uZSdcbl07XG52YXIgZXJyb3JMaXN0ID0gZGV4aWVFcnJvck5hbWVzLmNvbmNhdChpZGJEb21FcnJvck5hbWVzKTtcbnZhciBkZWZhdWx0VGV4dHMgPSB7XG4gICAgVmVyc2lvbkNoYW5nZWQ6IFwiRGF0YWJhc2UgdmVyc2lvbiBjaGFuZ2VkIGJ5IG90aGVyIGRhdGFiYXNlIGNvbm5lY3Rpb25cIixcbiAgICBEYXRhYmFzZUNsb3NlZDogXCJEYXRhYmFzZSBoYXMgYmVlbiBjbG9zZWRcIixcbiAgICBBYm9ydDogXCJUcmFuc2FjdGlvbiBhYm9ydGVkXCIsXG4gICAgVHJhbnNhY3Rpb25JbmFjdGl2ZTogXCJUcmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBjb21wbGV0ZWQgb3IgZmFpbGVkXCIsXG4gICAgTWlzc2luZ0FQSTogXCJJbmRleGVkREIgQVBJIG1pc3NpbmcuIFBsZWFzZSB2aXNpdCBodHRwczovL3Rpbnl1cmwuY29tL3kydXV2c2tiXCJcbn07XG5mdW5jdGlvbiBEZXhpZUVycm9yKG5hbWUsIG1zZykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxuZGVyaXZlKERleGllRXJyb3IpLmZyb20oRXJyb3IpLmV4dGVuZCh7XG4gICAgc3RhY2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5fc3RhY2sgPSB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBwcmV0dHlTdGFjayh0aGlzLl9lLCAyKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH1cbn0pO1xuZnVuY3Rpb24gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcykge1xuICAgIHJldHVybiBtc2cgKyBcIi4gRXJyb3JzOiBcIiArIE9iamVjdC5rZXlzKGZhaWx1cmVzKVxuICAgICAgICAubWFwKGtleSA9PiBmYWlsdXJlc1trZXldLnRvU3RyaW5nKCkpXG4gICAgICAgIC5maWx0ZXIoKHYsIGksIHMpID0+IHMuaW5kZXhPZih2KSA9PT0gaSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gTW9kaWZ5RXJyb3IobXNnLCBmYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzKSB7XG4gICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgdGhpcy5mYWlsdXJlcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMuZmFpbGVkS2V5cyA9IGZhaWxlZEtleXM7XG4gICAgdGhpcy5zdWNjZXNzQ291bnQgPSBzdWNjZXNzQ291bnQ7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG59XG5kZXJpdmUoTW9kaWZ5RXJyb3IpLmZyb20oRGV4aWVFcnJvcik7XG5mdW5jdGlvbiBCdWxrRXJyb3IobXNnLCBmYWlsdXJlcykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IFwiQnVsa0Vycm9yXCI7XG4gICAgdGhpcy5mYWlsdXJlcyA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAocG9zID0+IGZhaWx1cmVzW3Bvc10pO1xuICAgIHRoaXMuZmFpbHVyZXNCeVBvcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xufVxuZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcbnZhciBlcnJuYW1lcyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4gKG9ialtuYW1lXSA9IG5hbWUgKyBcIkVycm9yXCIsIG9iaiksIHt9KTtcbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBEZXhpZUVycm9yO1xudmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICB2YXIgZnVsbE5hbWUgPSBuYW1lICsgXCJFcnJvclwiO1xuICAgIGZ1bmN0aW9uIERleGllRXJyb3IobXNnT3JJbm5lciwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZ1bGxOYW1lO1xuICAgICAgICBpZiAoIW1zZ09ySW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGRlZmF1bHRUZXh0c1tuYW1lXSB8fCBmdWxsTmFtZTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7bXNnT3JJbm5lcn0keyFpbm5lciA/ICcnIDogJ1xcbiAnICsgaW5uZXJ9YDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lciB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2dPcklubmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7bXNnT3JJbm5lci5uYW1lfSAke21zZ09ySW5uZXIubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG1zZ09ySW5uZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVyaXZlKERleGllRXJyb3IpLmZyb20oQmFzZUV4Y2VwdGlvbik7XG4gICAgb2JqW25hbWVdID0gRGV4aWVFcnJvcjtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbmV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcbmV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xudmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5mdW5jdGlvbiBtYXBFcnJvcihkb21FcnJvciwgbWVzc2FnZSkge1xuICAgIGlmICghZG9tRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBEZXhpZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IgfHwgIWRvbUVycm9yLm5hbWUgfHwgIWV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXSlcbiAgICAgICAgcmV0dXJuIGRvbUVycm9yO1xuICAgIHZhciBydiA9IG5ldyBleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0obWVzc2FnZSB8fCBkb21FcnJvci5tZXNzYWdlLCBkb21FcnJvcik7XG4gICAgaWYgKFwic3RhY2tcIiBpbiBkb21FcnJvcikge1xuICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIuc3RhY2s7XG4gICAgICAgICAgICB9IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG52YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKSA9PiB7XG4gICAgaWYgKFtcIlN5bnRheFwiLCBcIlR5cGVcIiwgXCJSYW5nZVwiXS5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuZnVsbE5hbWVFeGNlcHRpb25zLk1vZGlmeUVycm9yID0gTW9kaWZ5RXJyb3I7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuRGV4aWVFcnJvciA9IERleGllRXJyb3I7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuQnVsa0Vycm9yID0gQnVsa0Vycm9yO1xuXG5mdW5jdGlvbiBub3AoKSB7IH1cbmZ1bmN0aW9uIG1pcnJvcih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09IG51bGwgfHwgZjEgPT09IG1pcnJvcilcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBmMihmMSh2YWwpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2FsbEJvdGgob24xLCBvbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tDcmVhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHJlcztcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpXG4gICAgICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLFxuICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yO1xuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIChyZXMyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZXMyKSA6XG4gICAgICAgICAgICAoZXh0ZW5kKHJlcywgcmVzMikpO1xuICAgIH07XG59XG5mdW5jdGlvbiByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHByb21pc2FibGVDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcClcbiAgICAgICAgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHRoaXogPSB0aGlzLCBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIElOVEVSTkFMID0ge307XG5jb25zdCBMT05HX1NUQUNLU19DTElQX0xJTUlUID0gMTAwLFxuTUFYX0xPTkdfU1RBQ0tTID0gMjAsIFpPTkVfRUNIT19MSU1JVCA9IDEwMCwgW3Jlc29sdmVkTmF0aXZlUHJvbWlzZSwgbmF0aXZlUHJvbWlzZVByb3RvLCByZXNvbHZlZEdsb2JhbFByb21pc2VdID0gdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID9cbiAgICBbXSA6XG4gICAgKCgpID0+IHtcbiAgICAgICAgbGV0IGdsb2JhbFAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uc3VidGxlKVxuICAgICAgICAgICAgcmV0dXJuIFtnbG9iYWxQLCBnZXRQcm90byhnbG9iYWxQKSwgZ2xvYmFsUF07XG4gICAgICAgIGNvbnN0IG5hdGl2ZVAgPSBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuYXRpdmVQLFxuICAgICAgICAgICAgZ2V0UHJvdG8obmF0aXZlUCksXG4gICAgICAgICAgICBnbG9iYWxQXG4gICAgICAgIF07XG4gICAgfSkoKSwgbmF0aXZlUHJvbWlzZVRoZW4gPSBuYXRpdmVQcm9taXNlUHJvdG8gJiYgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW47XG5jb25zdCBOYXRpdmVQcm9taXNlID0gcmVzb2x2ZWROYXRpdmVQcm9taXNlICYmIHJlc29sdmVkTmF0aXZlUHJvbWlzZS5jb25zdHJ1Y3RvcjtcbmNvbnN0IHBhdGNoR2xvYmFsUHJvbWlzZSA9ICEhcmVzb2x2ZWRHbG9iYWxQcm9taXNlO1xudmFyIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IGZhbHNlO1xudmFyIHNjaGVkdWxlUGh5c2ljYWxUaWNrID0gcmVzb2x2ZWRHbG9iYWxQcm9taXNlID9cbiAgICAoKSA9PiB7IHJlc29sdmVkR2xvYmFsUHJvbWlzZS50aGVuKHBoeXNpY2FsVGljayk7IH1cbiAgICA6XG4gICAgICAgIF9nbG9iYWwuc2V0SW1tZWRpYXRlID9cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZS5iaW5kKG51bGwsIHBoeXNpY2FsVGljaykgOlxuICAgICAgICAgICAgX2dsb2JhbC5NdXRhdGlvbk9ic2VydmVyID9cbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAobmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxUaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KSkub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgnaScsICcxJyk7XG4gICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgKCkgPT4geyBzZXRUaW1lb3V0KHBoeXNpY2FsVGljaywgMCk7IH07XG52YXIgYXNhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG4gICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG4gICAgICAgIHNjaGVkdWxlUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgfVxufTtcbnZhciBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlLFxubmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlLFxudW5oYW5kbGVkRXJyb3JzID0gW10sXG5yZWplY3RpbmdFcnJvcnMgPSBbXSxcbmN1cnJlbnRGdWxmaWxsZXIgPSBudWxsLCByZWplY3Rpb25NYXBwZXIgPSBtaXJyb3I7XG52YXIgZ2xvYmFsUFNEID0ge1xuICAgIGlkOiAnZ2xvYmFsJyxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgcmVmOiAwLFxuICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgIG9udW5oYW5kbGVkOiBnbG9iYWxFcnJvcixcbiAgICBwZ3A6IGZhbHNlLFxuICAgIGVudjoge30sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmhhbmRsZWRzLmZvckVhY2godWggPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFcnJvcih1aFswXSwgdWhbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xudmFyIFBTRCA9IGdsb2JhbFBTRDtcbnZhciBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xudmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDtcbnZhciB0aWNrRmluYWxpemVycyA9IFtdO1xuZnVuY3Rpb24gRGV4aWVQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5vbnVuY2F0Y2hlZCA9IG5vcDtcbiAgICB0aGlzLl9saWIgPSBmYWxzZTtcbiAgICB2YXIgcHNkID0gKHRoaXMuX1BTRCA9IFBTRCk7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIHRoaXMuX3N0YWNrSG9sZGVyID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX251bVByZXYgPSAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChmbiAhPT0gSU5URVJOQUwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICBoYW5kbGVSZWplY3Rpb24odGhpcywgdGhpcy5fdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgKytwc2QucmVmO1xuICAgIGV4ZWN1dGVQcm9taXNlVGFzayh0aGlzLCBmbik7XG59XG5jb25zdCB0aGVuUHJvcCA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcbiAgICAgICAgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIobmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvbkZ1bGZpbGxlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSwgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlamVjdGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCByZXNvbHZlLCByZWplY3QsIHBzZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWJ1ZyAmJiBsaW5rVG9QcmV2aW91c1Byb21pc2UocnYsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgICAgIHRoZW4ucHJvdG90eXBlID0gSU5URVJOQUw7XG4gICAgICAgIHJldHVybiB0aGVuO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc2V0UHJvcCh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgdGhlblByb3AgOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IHRoZW5Qcm9wLnNldFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbnByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICB0aGVuOiB0aGVuUHJvcCxcbiAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTtcbiAgICB9LFxuICAgIGNhdGNoOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCBoYW5kbGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLnRoZW4obnVsbCwgZXJyID0+XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycikpXG4gICAgICAgICAgICA6IHRoaXMudGhlbihudWxsLCBlcnIgPT5cbiAgICAgICAgICAgIGVyciAmJiBlcnIubmFtZSA9PT0gdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKSk7XG4gICAgfSxcbiAgICBmaW5hbGx5OiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBvbkZpbmFsbHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlUmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgc3RhY2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzdGFja3MgPSBnZXRTdGFjayh0aGlzLCBbXSwgTUFYX0xPTkdfU1RBQ0tTKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBzdGFja3Muam9pbihcIlxcbkZyb20gcHJldmlvdXM6IFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgZXhjZXB0aW9ucy5UaW1lb3V0KG1zZykpLCBtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCkuZmluYWxseShjbGVhclRpbWVvdXQuYmluZChudWxsLCBoYW5kbGUpKTtcbiAgICAgICAgICAgIH0pIDogdGhpcztcbiAgICB9XG59KTtcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpXG4gICAgc2V0UHJvcChEZXhpZVByb21pc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsICdEZXhpZS5Qcm9taXNlJyk7XG5nbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcbmZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB0aGlzLnBzZCA9IHpvbmU7XG59XG5wcm9wcyhEZXhpZVByb21pc2UsIHtcbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKGEsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICB9LCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICByZXNvbHZlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShydiwgY3VycmVudEZ1bGZpbGxlcik7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcbiAgICByYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5tYXAodmFsdWUgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgUFNEOiB7XG4gICAgICAgIGdldDogKCkgPT4gUFNELFxuICAgICAgICBzZXQ6IHZhbHVlID0+IFBTRCA9IHZhbHVlXG4gICAgfSxcbiAgICB0b3RhbEVjaG9lczogeyBnZXQ6ICgpID0+IHRvdGFsRWNob2VzIH0sXG4gICAgbmV3UFNEOiBuZXdTY29wZSxcbiAgICB1c2VQU0Q6IHVzZVBTRCxcbiAgICBzY2hlZHVsZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBhc2FwLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHsgYXNhcCA9IHZhbHVlOyB9XG4gICAgfSxcbiAgICByZWplY3Rpb25NYXBwZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZWplY3Rpb25NYXBwZXIsXG4gICAgICAgIHNldDogdmFsdWUgPT4geyByZWplY3Rpb25NYXBwZXIgPSB2YWx1ZTsgfVxuICAgIH0sXG4gICAgZm9sbG93OiAoZm4sIHpvbmVQcm9wcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgICAgICAgICAgICAgcHNkLnVuaGFuZGxlZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBwc2Qub251bmhhbmRsZWQgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5oYW5kbGVkcy5sZW5ndGggPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QodGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmlmIChOYXRpdmVQcm9taXNlKSB7XG4gICAgaWYgKE5hdGl2ZVByb21pc2UuYWxsU2V0dGxlZClcbiAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYWxsU2V0dGxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUHJvbWlzZXMuZm9yRWFjaCgocCwgaSkgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUocCkudGhlbih2YWx1ZSA9PiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlIH0sIHJlYXNvbiA9PiByZXN1bHRzW2ldID0geyBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbnkgJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYW55XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKHZhbHVlID0+IHJlc29sdmUodmFsdWUpLCBmYWlsdXJlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXNbaV0gPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCBmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGZuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHByb21pc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fdGhlbihyZXNvbHZlLCByZWplY3QpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3N0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRFeGVjdXRlVGljaylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9LCBoYW5kbGVSZWplY3Rpb24uYmluZChudWxsLCBwcm9taXNlKSk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgICByZWplY3RpbmdFcnJvcnMucHVzaChyZWFzb24pO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgcHJvbWlzZS5fc3RhdGUgPSBmYWxzZTtcbiAgICBwcm9taXNlLl92YWx1ZSA9IHJlYXNvbjtcbiAgICBkZWJ1ZyAmJiByZWFzb24gIT09IG51bGwgJiYgdHlwZW9mIHJlYXNvbiA9PT0gJ29iamVjdCcgJiYgIXJlYXNvbi5fcHJvbWlzZSAmJiB0cnlDYXRjaCgoKSA9PiB7XG4gICAgICAgIHZhciBvcmlnUHJvcCA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihyZWFzb24sIFwic3RhY2tcIik7XG4gICAgICAgIHJlYXNvbi5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHNldFByb3AocmVhc29uLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID9cbiAgICAgICAgICAgICAgICBvcmlnUHJvcCAmJiAob3JpZ1Byb3AuZ2V0ID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AuZ2V0LmFwcGx5KHJlYXNvbikgOlxuICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC52YWx1ZSkgOlxuICAgICAgICAgICAgICAgIHByb21pc2Uuc3RhY2tcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKTtcbiAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuZnVuY3Rpb24gcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcHNkID0gcHJvbWlzZS5fUFNEO1xuICAgIC0tcHNkLnJlZiB8fCBwc2QuZmluYWxpemUoKTtcbiAgICBpZiAobnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIHtcbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNiID0gcHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5vbkZ1bGZpbGxlZCA6IGxpc3RlbmVyLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KShwcm9taXNlLl92YWx1ZSk7XG4gICAgfVxuICAgICsrbGlzdGVuZXIucHNkLnJlZjtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAoY2FsbExpc3RlbmVyLCBbY2IsIHByb21pc2UsIGxpc3RlbmVyXSk7XG59XG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIoY2IsIHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY3VycmVudEZ1bGZpbGxlciA9IHByb21pc2U7XG4gICAgICAgIHZhciByZXQsIHZhbHVlID0gcHJvbWlzZS5fdmFsdWU7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSkge1xuICAgICAgICAgICAgcmV0ID0gY2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVqZWN0aW5nRXJyb3JzID0gW107XG4gICAgICAgICAgICByZXQgPSBjYih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVqZWN0aW5nRXJyb3JzLmluZGV4T2YodmFsdWUpID09PSAtMSlcbiAgICAgICAgICAgICAgICBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gbnVsbDtcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgICAgICAtLWxpc3RlbmVyLnBzZC5yZWYgfHwgbGlzdGVuZXIucHNkLmZpbmFsaXplKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U3RhY2socHJvbWlzZSwgc3RhY2tzLCBsaW1pdCkge1xuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSBsaW1pdClcbiAgICAgICAgcmV0dXJuIHN0YWNrcztcbiAgICB2YXIgc3RhY2sgPSBcIlwiO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGZhaWx1cmUgPSBwcm9taXNlLl92YWx1ZSwgZXJyb3JOYW1lLCBtZXNzYWdlO1xuICAgICAgICBpZiAoZmFpbHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlLm5hbWUgfHwgXCJFcnJvclwiO1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZhaWx1cmUubWVzc2FnZSB8fCBmYWlsdXJlO1xuICAgICAgICAgICAgc3RhY2sgPSBwcmV0dHlTdGFjayhmYWlsdXJlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yTmFtZSA9IGZhaWx1cmU7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBzdGFja3MucHVzaChlcnJvck5hbWUgKyAobWVzc2FnZSA/IFwiOiBcIiArIG1lc3NhZ2UgOiBcIlwiKSArIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2socHJvbWlzZS5fc3RhY2tIb2xkZXIsIDIpO1xuICAgICAgICBpZiAoc3RhY2sgJiYgc3RhY2tzLmluZGV4T2Yoc3RhY2spID09PSAtMSlcbiAgICAgICAgICAgIHN0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgaWYgKHByb21pc2UuX3ByZXYpXG4gICAgICAgICAgICBnZXRTdGFjayhwcm9taXNlLl9wcmV2LCBzdGFja3MsIGxpbWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShwcm9taXNlLCBwcmV2KSB7XG4gICAgdmFyIG51bVByZXYgPSBwcmV2ID8gcHJldi5fbnVtUHJldiArIDEgOiAwO1xuICAgIGlmIChudW1QcmV2IDwgTE9OR19TVEFDS1NfQ0xJUF9MSU1JVCkge1xuICAgICAgICBwcm9taXNlLl9wcmV2ID0gcHJldjtcbiAgICAgICAgcHJvbWlzZS5fbnVtUHJldiA9IG51bVByZXY7XG4gICAgfVxufVxuZnVuY3Rpb24gcGh5c2ljYWxUaWNrKCkge1xuICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgd2FzUm9vdEV4ZWMgPSBpc091dHNpZGVNaWNyb1RpY2s7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gd2FzUm9vdEV4ZWM7XG59XG5mdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgY2FsbGJhY2tzLCBpLCBsO1xuICAgIGRvIHtcbiAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IG1pY3JvdGlja1F1ZXVlO1xuICAgICAgICAgICAgbWljcm90aWNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcbiAgICBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlO1xuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplUGh5c2ljYWxUaWNrKCkge1xuICAgIHZhciB1bmhhbmRsZWRFcnJzID0gdW5oYW5kbGVkRXJyb3JzO1xuICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdO1xuICAgIHVuaGFuZGxlZEVycnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5fUFNELm9udW5oYW5kbGVkLmNhbGwobnVsbCwgcC5fdmFsdWUsIHApO1xuICAgIH0pO1xuICAgIHZhciBmaW5hbGl6ZXJzID0gdGlja0ZpbmFsaXplcnMuc2xpY2UoMCk7XG4gICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSlcbiAgICAgICAgZmluYWxpemVyc1stLWldKCk7XG59XG5mdW5jdGlvbiBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrKGZuKSB7XG4gICAgZnVuY3Rpb24gZmluYWxpemVyKCkge1xuICAgICAgICBmbigpO1xuICAgICAgICB0aWNrRmluYWxpemVycy5zcGxpY2UodGlja0ZpbmFsaXplcnMuaW5kZXhPZihmaW5hbGl6ZXIpLCAxKTtcbiAgICB9XG4gICAgdGlja0ZpbmFsaXplcnMucHVzaChmaW5hbGl6ZXIpO1xuICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgYXNhcCgoKSA9PiB7XG4gICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpIHtcbiAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKHAgPT4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5mdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSlcbiAgICAgICAgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbn1cbmZ1bmN0aW9uIFByb21pc2VSZWplY3QocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xufVxuZnVuY3Rpb24gd3JhcChmbiwgZXJyb3JDYXRjaGVyKSB7XG4gICAgdmFyIHBzZCA9IFBTRDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksIG91dGVyU2NvcGUgPSBQU0Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMCB9O1xudmFyIHRhc2tDb3VudGVyID0gMDtcbnZhciB6b25lU3RhY2sgPSBbXTtcbnZhciB6b25lRWNob2VzID0gMDtcbnZhciB0b3RhbEVjaG9lcyA9IDA7XG52YXIgem9uZV9pZF9jb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5ld1Njb3BlKGZuLCBwcm9wcywgYTEsIGEyKSB7XG4gICAgdmFyIHBhcmVudCA9IFBTRCwgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIHBzZC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcHNkLnJlZiA9IDA7XG4gICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgIHBzZC5pZCA9ICsrem9uZV9pZF9jb3VudGVyO1xuICAgIHZhciBnbG9iYWxFbnYgPSBnbG9iYWxQU0QuZW52O1xuICAgIHBzZC5lbnYgPSBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IHsgdmFsdWU6IERleGllUHJvbWlzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgICAgICBhbGw6IERleGllUHJvbWlzZS5hbGwsXG4gICAgICAgIHJhY2U6IERleGllUHJvbWlzZS5yYWNlLFxuICAgICAgICBhbGxTZXR0bGVkOiBEZXhpZVByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgYW55OiBEZXhpZVByb21pc2UuYW55LFxuICAgICAgICByZXNvbHZlOiBEZXhpZVByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBEZXhpZVByb21pc2UucmVqZWN0LFxuICAgICAgICBudGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuKGdsb2JhbEVudi5udGhlbiwgcHNkKSxcbiAgICAgICAgZ3RoZW46IGdldFBhdGNoZWRQcm9taXNlVGhlbihnbG9iYWxFbnYuZ3RoZW4sIHBzZClcbiAgICB9IDoge307XG4gICAgaWYgKHByb3BzKVxuICAgICAgICBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgKytwYXJlbnQucmVmO1xuICAgIHBzZC5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICB9O1xuICAgIHZhciBydiA9IHVzZVBTRChwc2QsIGZuLCBhMSwgYTIpO1xuICAgIGlmIChwc2QucmVmID09PSAwKVxuICAgICAgICBwc2QuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcnY7XG59XG5mdW5jdGlvbiBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suaWQpXG4gICAgICAgIHRhc2suaWQgPSArK3Rhc2tDb3VudGVyO1xuICAgICsrdGFzay5hd2FpdHM7XG4gICAgdGFzay5lY2hvZXMgKz0gWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0YXNrLmlkO1xufVxuZnVuY3Rpb24gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmF3YWl0cylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgtLXRhc2suYXdhaXRzID09PSAwKVxuICAgICAgICB0YXNrLmlkID0gMDtcbiAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzICogWk9ORV9FQ0hPX0xJTUlUO1xuICAgIHJldHVybiB0cnVlO1xufVxuaWYgKCgnJyArIG5hdGl2ZVByb21pc2VUaGVuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPT09IC0xKSB7XG4gICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IG5vcDtcbn1cbmZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyhwb3NzaWJsZVByb21pc2UpIHtcbiAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICByZXR1cm4gcG9zc2libGVQcm9taXNlLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9zc2libGVQcm9taXNlO1xufVxuZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG4gICAgKyt0b3RhbEVjaG9lcztcbiAgICBpZiAoIXRhc2suZWNob2VzIHx8IC0tdGFzay5lY2hvZXMgPT09IDApIHtcbiAgICAgICAgdGFzay5lY2hvZXMgPSB0YXNrLmlkID0gMDtcbiAgICB9XG4gICAgem9uZVN0YWNrLnB1c2goUFNEKTtcbiAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiB6b25lTGVhdmVFY2hvKCkge1xuICAgIHZhciB6b25lID0gem9uZVN0YWNrW3pvbmVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgc3dpdGNoVG9ab25lKHpvbmUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgdmFyIGN1cnJlbnRab25lID0gUFNEO1xuICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRClcbiAgICAgICAgcmV0dXJuO1xuICAgIFBTRCA9IHRhcmdldFpvbmU7XG4gICAgaWYgKGN1cnJlbnRab25lID09PSBnbG9iYWxQU0QpXG4gICAgICAgIGdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuICAgIGlmIChwYXRjaEdsb2JhbFByb21pc2UpIHtcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcbiAgICAgICAgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4gPSB0YXJnZXRFbnYubnRoZW47XG4gICAgICAgIEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW4gPSB0YXJnZXRFbnYuZ3RoZW47XG4gICAgICAgIGlmIChjdXJyZW50Wm9uZS5nbG9iYWwgfHwgdGFyZ2V0Wm9uZS5nbG9iYWwpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZ2xvYmFsLCAnUHJvbWlzZScsIHRhcmdldEVudi5Qcm9taXNlUHJvcCk7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJhY2UgPSB0YXJnZXRFbnYucmFjZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVzb2x2ZSA9IHRhcmdldEVudi5yZXNvbHZlO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbGxTZXR0bGVkKVxuICAgICAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCA9IHRhcmdldEVudi5hbGxTZXR0bGVkO1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpXG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbnkgPSB0YXJnZXRFbnYuYW55O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc25hcFNob3QoKSB7XG4gICAgdmFyIEdsb2JhbFByb21pc2UgPSBfZ2xvYmFsLlByb21pc2U7XG4gICAgcmV0dXJuIHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogR2xvYmFsUHJvbWlzZSxcbiAgICAgICAgUHJvbWlzZVByb3A6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2dsb2JhbCwgXCJQcm9taXNlXCIpLFxuICAgICAgICBhbGw6IEdsb2JhbFByb21pc2UuYWxsLFxuICAgICAgICByYWNlOiBHbG9iYWxQcm9taXNlLnJhY2UsXG4gICAgICAgIGFsbFNldHRsZWQ6IEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCxcbiAgICAgICAgYW55OiBHbG9iYWxQcm9taXNlLmFueSxcbiAgICAgICAgcmVzb2x2ZTogR2xvYmFsUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IEdsb2JhbFByb21pc2UucmVqZWN0LFxuICAgICAgICBudGhlbjogbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4sXG4gICAgICAgIGd0aGVuOiBHbG9iYWxQcm9taXNlLnByb3RvdHlwZS50aGVuXG4gICAgfSA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUFNEKHBzZCwgZm4sIGExLCBhMiwgYTMpIHtcbiAgICB2YXIgb3V0ZXJTY29wZSA9IFBTRDtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZuKGExLCBhMiwgYTMpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGpvYikge1xuICAgIG5hdGl2ZVByb21pc2VUaGVuLmNhbGwocmVzb2x2ZWROYXRpdmVQcm9taXNlLCBqb2IpO1xufVxuZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCwgY2xlYW51cCkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpXG4gICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwKVxuICAgICAgICAgICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhdGNoZWRQcm9taXNlVGhlbihvcmlnVGhlbiwgem9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gb3JpZ1RoZW4uY2FsbCh0aGlzLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVzb2x2ZWQsIHpvbmUpLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHpvbmUpKTtcbiAgICB9O1xufVxuY29uc3QgVU5IQU5ETEVEUkVKRUNUSU9OID0gXCJ1bmhhbmRsZWRyZWplY3Rpb25cIjtcbmZ1bmN0aW9uIGdsb2JhbEVycm9yKGVyciwgcHJvbWlzZSkge1xuICAgIHZhciBydjtcbiAgICB0cnkge1xuICAgICAgICBydiA9IHByb21pc2Uub251bmNhdGNoZWQoZXJyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIGlmIChydiAhPT0gZmFsc2UpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQsIGV2ZW50RGF0YSA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBlcnIgfTtcbiAgICAgICAgICAgIGlmIChfZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0RXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBleHRlbmQoZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfZ2xvYmFsLkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB7IGRldGFpbDogZXZlbnREYXRhIH0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudCAmJiBfZ2xvYmFsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIV9nbG9iYWwuUHJvbWlzZVJlamVjdGlvbkV2ZW50ICYmIF9nbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgZXZlbnQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuaGFuZGxlZCByZWplY3Rpb246ICR7ZXJyLnN0YWNrIHx8IGVycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG59XG52YXIgcmVqZWN0aW9uID0gRGV4aWVQcm9taXNlLnJlamVjdDtcblxuZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikge1xuICAgIGlmICghZGIuaWRiZGIgfHwgKCFkYi5fc3RhdGUub3BlbkNvbXBsZXRlICYmICghUFNELmxldFRocm91Z2ggJiYgIWRiLl92aXApKSkge1xuICAgICAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYi5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICBpZiAoIWRiLl9vcHRpb25zLmF1dG9PcGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgICBkYi5vcGVuKCkuY2F0Y2gobm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGIuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oKCkgPT4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG4gICAgICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKCgpID0+IHRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbigoKSA9PiByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IERFWElFX1ZFUlNJT04gPSAnMy4yLjMnO1xuY29uc3QgbWF4U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzNSk7XG5jb25zdCBtaW5LZXkgPSAtSW5maW5pdHk7XG5jb25zdCBJTlZBTElEX0tFWV9BUkdVTUVOVCA9IFwiSW52YWxpZCBrZXkgcHJvdmlkZWQuIEtleXMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZywgbnVtYmVyLCBEYXRlIG9yIEFycmF5PHN0cmluZyB8IG51bWJlciB8IERhdGU+LlwiO1xuY29uc3QgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG5jb25zdCBjb25uZWN0aW9ucyA9IFtdO1xuY29uc3QgaXNJRU9yRWRnZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8oTVNJRXxUcmlkZW50fEVkZ2UpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZyA9IGlzSUVPckVkZ2U7XG5jb25zdCBoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSA9IGlzSUVPckVkZ2U7XG5jb25zdCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIgPSBmcmFtZSA9PiAhLyhkZXhpZVxcLmpzfGRleGllXFwubWluXFwuanMpLy50ZXN0KGZyYW1lKTtcbmNvbnN0IERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbmNvbnN0IFJFQURPTkxZID0gJ3JlYWRvbmx5JztcbmNvbnN0IFJFQURXUklURSA9ICdyZWFkd3JpdGUnO1xuXG5mdW5jdGlvbiBjb21iaW5lKGZpbHRlcjEsIGZpbHRlcjIpIHtcbiAgICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICAgIGZpbHRlcjIgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIGZpbHRlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSA6XG4gICAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgICAgZmlsdGVyMjtcbn1cblxuY29uc3QgQW55UmFuZ2UgPSB7XG4gICAgdHlwZTogMyAsXG4gICAgbG93ZXI6IC1JbmZpbml0eSxcbiAgICBsb3dlck9wZW46IGZhbHNlLFxuICAgIHVwcGVyOiBbW11dLFxuICAgIHVwcGVyT3BlbjogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09IFwic3RyaW5nXCIgJiYgIS9cXC4vLnRlc3Qoa2V5UGF0aClcbiAgICAgICAgPyAob2JqKSA9PiB7XG4gICAgICAgICAgICBpZiAob2JqW2tleVBhdGhdID09PSB1bmRlZmluZWQgJiYgKGtleVBhdGggaW4gb2JqKSkge1xuICAgICAgICAgICAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIDogKG9iaikgPT4gb2JqO1xufVxuXG5jbGFzcyBUYWJsZSB7XG4gICAgX3RyYW5zKG1vZGUsIGZuLCB3cml0ZUxvY2tlZCkge1xuICAgICAgICBjb25zdCB0cmFucyA9IHRoaXMuX3R4IHx8IFBTRC50cmFucztcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBmdW5jdGlvbiBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKSB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zLnNjaGVtYVt0YWJsZU5hbWVdKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmbih0cmFucy5pZGJ0cmFucywgdHJhbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zICYmIHRyYW5zLmRiID09PSB0aGlzLmRiID9cbiAgICAgICAgICAgICAgICB0cmFucyA9PT0gUFNELnRyYW5zID9cbiAgICAgICAgICAgICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlKCgpID0+IHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCksIHsgdHJhbnM6IHRyYW5zLCB0cmFuc2xlc3M6IFBTRC50cmFuc2xlc3MgfHwgUFNEIH0pIDpcbiAgICAgICAgICAgICAgICB0ZW1wVHJhbnNhY3Rpb24odGhpcy5kYiwgbW9kZSwgW3RoaXMubmFtZV0sIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYylcbiAgICAgICAgICAgICAgICBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChrZXlPckNyaXQsIGNiKSB7XG4gICAgICAgIGlmIChrZXlPckNyaXQgJiYga2V5T3JDcml0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZShrZXlPckNyaXQpLmZpcnN0KGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsICh0cmFucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5nZXQoeyB0cmFucywga2V5OiBrZXlPckNyaXQgfSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4gdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpKTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHdoZXJlKGluZGV4T3JDcml0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGluZGV4T3JDcml0KTtcbiAgICAgICAgaWYgKGlzQXJyYXkoaW5kZXhPckNyaXQpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGBbJHtpbmRleE9yQ3JpdC5qb2luKCcrJyl9XWApO1xuICAgICAgICBjb25zdCBrZXlQYXRocyA9IGtleXMoaW5kZXhPckNyaXQpO1xuICAgICAgICBpZiAoa2V5UGF0aHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgICAgICAud2hlcmUoa2V5UGF0aHNbMF0pXG4gICAgICAgICAgICAgICAgLmVxdWFscyhpbmRleE9yQ3JpdFtrZXlQYXRoc1swXV0pO1xuICAgICAgICBjb25zdCBjb21wb3VuZEluZGV4ID0gdGhpcy5zY2hlbWEuaW5kZXhlcy5jb25jYXQodGhpcy5zY2hlbWEucHJpbUtleSkuZmlsdGVyKGl4ID0+IGl4LmNvbXBvdW5kICYmXG4gICAgICAgICAgICBrZXlQYXRocy5ldmVyeShrZXlQYXRoID0+IGl4LmtleVBhdGguaW5kZXhPZihrZXlQYXRoKSA+PSAwKSAmJlxuICAgICAgICAgICAgaXgua2V5UGF0aC5ldmVyeShrZXlQYXRoID0+IGtleVBhdGhzLmluZGV4T2Yoa2V5UGF0aCkgPj0gMCkpWzBdO1xuICAgICAgICBpZiAoY29tcG91bmRJbmRleCAmJiB0aGlzLmRiLl9tYXhLZXkgIT09IG1heFN0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgLndoZXJlKGNvbXBvdW5kSW5kZXgubmFtZSlcbiAgICAgICAgICAgICAgICAuZXF1YWxzKGNvbXBvdW5kSW5kZXgua2V5UGF0aC5tYXAoa3AgPT4gaW5kZXhPckNyaXRba3BdKSk7XG4gICAgICAgIGlmICghY29tcG91bmRJbmRleCAmJiBkZWJ1ZylcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIHF1ZXJ5ICR7SlNPTi5zdHJpbmdpZnkoaW5kZXhPckNyaXQpfSBvbiAke3RoaXMubmFtZX0gd291bGQgYmVuZWZpdCBvZiBhIGAgK1xuICAgICAgICAgICAgICAgIGBjb21wb3VuZCBpbmRleCBbJHtrZXlQYXRocy5qb2luKCcrJyl9XWApO1xuICAgICAgICBjb25zdCB7IGlkeEJ5TmFtZSB9ID0gdGhpcy5zY2hlbWE7XG4gICAgICAgIGNvbnN0IGlkYiA9IHRoaXMuZGIuX2RlcHMuaW5kZXhlZERCO1xuICAgICAgICBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiLmNtcChhLCBiKSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpZHgsIGZpbHRlckZ1bmN0aW9uXSA9IGtleVBhdGhzLnJlZHVjZSgoW3ByZXZJbmRleCwgcHJldkZpbHRlckZuXSwga2V5UGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZHhCeU5hbWVba2V5UGF0aF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGV4T3JDcml0W2tleVBhdGhdO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggfHwgaW5kZXgsXG4gICAgICAgICAgICAgICAgcHJldkluZGV4IHx8ICFpbmRleCA/XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmUocHJldkZpbHRlckZuLCBpbmRleCAmJiBpbmRleC5tdWx0aSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHByb3ApICYmIHByb3Auc29tZShpdGVtID0+IGVxdWFscyh2YWx1ZSwgaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHggPT4gZXF1YWxzKHZhbHVlLCBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICA6IHByZXZGaWx0ZXJGblxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSwgW251bGwsIG51bGxdKTtcbiAgICAgICAgcmV0dXJuIGlkeCA/XG4gICAgICAgICAgICB0aGlzLndoZXJlKGlkeC5uYW1lKS5lcXVhbHMoaW5kZXhPckNyaXRbaWR4LmtleVBhdGhdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgICAgICAgIGNvbXBvdW5kSW5kZXggP1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6XG4gICAgICAgICAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTtcbiAgICB9XG4gICAgZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmFuZChmaWx0ZXJGdW5jdGlvbik7XG4gICAgfVxuICAgIGNvdW50KHRoZW5TaG9ydGN1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5jb3VudCh0aGVuU2hvcnRjdXQpO1xuICAgIH1cbiAgICBvZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICAgIH1cbiAgICBsaW1pdChudW1Sb3dzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmxpbWl0KG51bVJvd3MpO1xuICAgIH1cbiAgICBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLmVhY2goY2FsbGJhY2spO1xuICAgIH1cbiAgICB0b0FycmF5KHRoZW5TaG9ydGN1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS50b0FycmF5KHRoZW5TaG9ydGN1dCk7XG4gICAgfVxuICAgIHRvQ29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24obmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcykpO1xuICAgIH1cbiAgICBvcmRlckJ5KGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGlzQXJyYXkoaW5kZXgpID9cbiAgICAgICAgICAgIGBbJHtpbmRleC5qb2luKCcrJyl9XWAgOlxuICAgICAgICAgICAgaW5kZXgpKTtcbiAgICB9XG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBtYXBUb0NsYXNzKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hLm1hcHBlZENsYXNzID0gY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IHJlYWRIb29rID0gb2JqID0+IHtcbiAgICAgICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBtIGluIG9iailcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbbV0gPSBvYmpbbV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hLnJlYWRIb29rKSB7XG4gICAgICAgICAgICB0aGlzLmhvb2sucmVhZGluZy51bnN1YnNjcmliZSh0aGlzLnNjaGVtYS5yZWFkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlbWEucmVhZEhvb2sgPSByZWFkSG9vaztcbiAgICAgICAgdGhpcy5ob29rKFwicmVhZGluZ1wiLCByZWFkSG9vayk7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgZGVmaW5lQ2xhc3MoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKENsYXNzKTtcbiAgICB9XG4gICAgYWRkKG9iaiwga2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYXV0bywga2V5UGF0aCB9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgICAgbGV0IG9ialRvQWRkID0gb2JqO1xuICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwsIHZhbHVlczogW29ialRvQWRkXSB9KTtcbiAgICAgICAgfSkudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQpXG4gICAgICAgICAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKGtleU9yT2JqZWN0LCBtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5T3JPYmplY3QgPT09ICdvYmplY3QnICYmICFpc0FycmF5KGtleU9yT2JqZWN0KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCB0aGlzLnNjaGVtYS5wcmltS2V5LmtleVBhdGgpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiR2l2ZW4gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gaXRzIHByaW1hcnkga2V5XCIpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmljYXRpb25zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyhtb2RpZmljYXRpb25zKS5mb3JFYWNoKGtleVBhdGggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCBrZXlQYXRoLCBtb2RpZmljYXRpb25zW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmljYXRpb25zKGtleU9yT2JqZWN0LCB7IHZhbHVlOiBrZXlPck9iamVjdCwgcHJpbUtleToga2V5IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleU9yT2JqZWN0KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0KG9iaiwga2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYXV0bywga2V5UGF0aCB9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgICAgbGV0IG9ialRvQWRkID0gb2JqO1xuICAgICAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICAgICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsIH0pKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0KVxuICAgICAgICAgICAgLnRoZW4obGFzdFJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBba2V5XSB9KSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBBbnlSYW5nZSB9KSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBidWxrR2V0KGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUuZ2V0TWFueSh7XG4gICAgICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgICAgICB0cmFuc1xuICAgICAgICAgICAgfSkudGhlbihyZXN1bHQgPT4gcmVzdWx0Lm1hcChyZXMgPT4gdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWxrQWRkKG9iamVjdHMsIGtleXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRvLCBrZXlQYXRoIH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgICAgICAgICAgaWYgKGtleVBhdGggJiYga2V5cylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrQWRkKCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBvYmplY3RzVG9BZGQgPSBrZXlQYXRoICYmIGF1dG8gP1xuICAgICAgICAgICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG4gICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb0FkZCwgd2FudFJlc3VsdHMgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoeyBudW1GYWlsdXJlcywgcmVzdWx0cywgbGFzdFJlc3VsdCwgZmFpbHVyZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoYCR7dGhpcy5uYW1lfS5idWxrQWRkKCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtT2JqZWN0c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1bGtQdXQob2JqZWN0cywga2V5c09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShrZXlzT3JPcHRpb25zKSA/IGtleXNPck9wdGlvbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dG8sIGtleVBhdGggfSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgICAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgb2JqZWN0cyBhbmQga2V5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9iamVjdHNUb1B1dCA9IGtleVBhdGggJiYgYXV0byA/XG4gICAgICAgICAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgICAgICAgICBvYmplY3RzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ3B1dCcsIGtleXM6IGtleXMsIHZhbHVlczogb2JqZWN0c1RvUHV0LCB3YW50UmVzdWx0cyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCh7IG51bUZhaWx1cmVzLCByZXN1bHRzLCBsYXN0UmVzdWx0LCBmYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FudFJlc3VsdHMgPyByZXN1bHRzIDogbGFzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihgJHt0aGlzLm5hbWV9LmJ1bGtQdXQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVsa0RlbGV0ZShrZXlzKSB7XG4gICAgICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnZGVsZXRlJywga2V5czoga2V5cyB9KTtcbiAgICAgICAgfSkudGhlbigoeyBudW1GYWlsdXJlcywgbGFzdFJlc3VsdCwgZmFpbHVyZXMgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihgJHt0aGlzLm5hbWV9LmJ1bGtEZWxldGUoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1LZXlzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBFdmVudHMoY3R4KSB7XG4gICAgdmFyIGV2cyA9IHt9O1xuICAgIHZhciBydiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgICAgICAgICB3aGlsZSAoLS1pKVxuICAgICAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZXZzW2V2ZW50TmFtZV0uc3Vic2NyaWJlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZzW2V2ZW50TmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJ2LmFkZEV2ZW50VHlwZSA9IGFkZDtcbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgICBmdW5jdGlvbiBhZGQoZXZlbnROYW1lLCBjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKCFjaGFpbkZ1bmN0aW9uKVxuICAgICAgICAgICAgY2hhaW5GdW5jdGlvbiA9IHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluO1xuICAgICAgICBpZiAoIWRlZmF1bHRGdW5jdGlvbilcbiAgICAgICAgICAgIGRlZmF1bHRGdW5jdGlvbiA9IG5vcDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICBmaXJlOiBkZWZhdWx0RnVuY3Rpb24sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjb250ZXh0LnN1YnNjcmliZXJzLnJlZHVjZShjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBldnNbZXZlbnROYW1lXSA9IHJ2W2V2ZW50TmFtZV0gPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkQ29uZmlndXJlZEV2ZW50cyhjZmcpIHtcbiAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBjZmdbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3MgPT09ICdhc2FwJykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gYWRkKGV2ZW50TmFtZSwgbWlycm9yLCBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2FwJDEoZnVuY3Rpb24gZmlyZUV2ZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VDbGFzc0NvbnN0cnVjdG9yKHByb3RvdHlwZSwgY29uc3RydWN0b3IpIHtcbiAgICBkZXJpdmUoY29uc3RydWN0b3IpLmZyb20oeyBwcm90b3R5cGUgfSk7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFRhYmxlLnByb3RvdHlwZSwgZnVuY3Rpb24gVGFibGUobmFtZSwgdGFibGVTY2hlbWEsIHRyYW5zKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5fdHggPSB0cmFucztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSB0YWJsZVNjaGVtYTtcbiAgICAgICAgdGhpcy5ob29rID0gZGIuX2FsbFRhYmxlc1tuYW1lXSA/IGRiLl9hbGxUYWJsZXNbbmFtZV0uaG9vayA6IEV2ZW50cyhudWxsLCB7XG4gICAgICAgICAgICBcImNyZWF0aW5nXCI6IFtob29rQ3JlYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgICAgIFwicmVhZGluZ1wiOiBbcHVyZUZ1bmN0aW9uQ2hhaW4sIG1pcnJvcl0sXG4gICAgICAgICAgICBcInVwZGF0aW5nXCI6IFtob29rVXBkYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgICAgIFwiZGVsZXRpbmdcIjogW2hvb2tEZWxldGluZ0NoYWluLCBub3BdXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpc1BsYWluS2V5UmFuZ2UoY3R4LCBpZ25vcmVMaW1pdEZpbHRlcikge1xuICAgIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG4gICAgICAgIChpZ25vcmVMaW1pdEZpbHRlciA/IGN0eC5qdXN0TGltaXQgOiAhY3R4LnJlcGxheUZpbHRlcik7XG59XG5mdW5jdGlvbiBhZGRGaWx0ZXIoY3R4LCBmbikge1xuICAgIGN0eC5maWx0ZXIgPSBjb21iaW5lKGN0eC5maWx0ZXIsIGZuKTtcbn1cbmZ1bmN0aW9uIGFkZFJlcGxheUZpbHRlcihjdHgsIGZhY3RvcnksIGlzTGltaXRGaWx0ZXIpIHtcbiAgICB2YXIgY3VyciA9IGN0eC5yZXBsYXlGaWx0ZXI7XG4gICAgY3R4LnJlcGxheUZpbHRlciA9IGN1cnIgPyAoKSA9PiBjb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKSA6IGZhY3Rvcnk7XG4gICAgY3R4Lmp1c3RMaW1pdCA9IGlzTGltaXRGaWx0ZXIgJiYgIWN1cnI7XG59XG5mdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHgsIGZuKSB7XG4gICAgY3R4LmlzTWF0Y2ggPSBjb21iaW5lKGN0eC5pc01hdGNoLCBmbik7XG59XG5mdW5jdGlvbiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlU2NoZW1hKSB7XG4gICAgaWYgKGN0eC5pc1ByaW1LZXkpXG4gICAgICAgIHJldHVybiBjb3JlU2NoZW1hLnByaW1hcnlLZXk7XG4gICAgY29uc3QgaW5kZXggPSBjb3JlU2NoZW1hLmdldEluZGV4QnlLZXlQYXRoKGN0eC5pbmRleCk7XG4gICAgaWYgKCFpbmRleClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIHRyYW5zKSB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKTtcbiAgICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuICAgICAgICB0cmFucyxcbiAgICAgICAgdmFsdWVzOiAhY3R4LmtleXNPbmx5LFxuICAgICAgICByZXZlcnNlOiBjdHguZGlyID09PSAncHJldicsXG4gICAgICAgIHVuaXF1ZTogISFjdHgudW5pcXVlLFxuICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGl0ZXIoY3R4LCBmbiwgY29yZVRyYW5zLCBjb3JlVGFibGUpIHtcbiAgICBjb25zdCBmaWx0ZXIgPSBjdHgucmVwbGF5RmlsdGVyID8gY29tYmluZShjdHguZmlsdGVyLCBjdHgucmVwbGF5RmlsdGVyKCkpIDogY3R4LmZpbHRlcjtcbiAgICBpZiAoIWN0eC5vcikge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZpbHRlciksIGZuLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzZXQgPSB7fTtcbiAgICAgICAgY29uc3QgdW5pb24gPSAoaXRlbSwgY3Vyc29yLCBhZHZhbmNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCByZXN1bHQgPT4gY3Vyc29yLnN0b3AocmVzdWx0KSwgZXJyID0+IGN1cnNvci5mYWlsKGVycikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJycgKyBwcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpXG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICcnICsgbmV3IFVpbnQ4QXJyYXkocHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd24oc2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm4oaXRlbSwgY3Vyc29yLCBhZHZhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBjdHgub3IuX2l0ZXJhdGUodW5pb24sIGNvcmVUcmFucyksXG4gICAgICAgICAgICBpdGVyYXRlKG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksIGN0eC5hbGdvcml0aG0sIHVuaW9uLCAhY3R4LmtleXNPbmx5ICYmIGN0eC52YWx1ZU1hcHBlcilcbiAgICAgICAgXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlLCBmaWx0ZXIsIGZuLCB2YWx1ZU1hcHBlcikge1xuICAgIHZhciBtYXBwZWRGbiA9IHZhbHVlTWFwcGVyID8gKHgsIGMsIGEpID0+IGZuKHZhbHVlTWFwcGVyKHgpLCBjLCBhKSA6IGZuO1xuICAgIHZhciB3cmFwcGVkRm4gPSB3cmFwKG1hcHBlZEZuKTtcbiAgICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGN1cnNvciA9PiB7XG4gICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJzb3Iuc3RhcnQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBjID0gKCkgPT4gY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZXIgPT4gYyA9IGFkdmFuY2VyLCB2YWwgPT4geyBjdXJzb3Iuc3RvcCh2YWwpOyBjID0gbm9wOyB9LCBlID0+IHsgY3Vyc29yLmZhaWwoZSk7IGMgPSBub3A7IH0pKVxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oY3Vyc29yLnZhbHVlLCBjdXJzb3IsIGFkdmFuY2VyID0+IGMgPSBhZHZhbmNlcik7XG4gICAgICAgICAgICAgICAgYygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB0YSA9IHR5cGUoYSk7XG4gICAgICAgIGNvbnN0IHRiID0gdHlwZShiKTtcbiAgICAgICAgaWYgKHRhICE9PSB0Yikge1xuICAgICAgICAgICAgaWYgKHRhID09PSAnQXJyYXknKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHRiID09PSAnQXJyYXknKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICh0YSA9PT0gJ2JpbmFyeScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgPT09ICdiaW5hcnknKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICh0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBpZiAodGIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmICh0YSA9PT0gJ0RhdGUnKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHRiICE9PSAnRGF0ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRhKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVVpbnQ4QXJyYXlzKGdldFVpbnQ4QXJyYXkoYSksIGdldFVpbnQ4QXJyYXkoYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGEsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfYSkgeyB9XG4gICAgcmV0dXJuIE5hTjtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYSwgYikge1xuICAgIGNvbnN0IGFsID0gYS5sZW5ndGg7XG4gICAgY29uc3QgYmwgPSBiLmxlbmd0aDtcbiAgICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgcmVzID0gY21wKGFbaV0sIGJbaV0pO1xuICAgICAgICBpZiAocmVzICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKGEsIGIpIHtcbiAgICBjb25zdCBhbCA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGJsID0gYi5sZW5ndGg7XG4gICAgY29uc3QgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGFbaV0gPCBiW2ldID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiB0eXBlKHgpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHg7XG4gICAgaWYgKHQgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gdDtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHgpKVxuICAgICAgICByZXR1cm4gJ2JpbmFyeSc7XG4gICAgY29uc3QgdHNUYWcgPSB0b1N0cmluZ1RhZyh4KTtcbiAgICByZXR1cm4gdHNUYWcgPT09ICdBcnJheUJ1ZmZlcicgPyAnYmluYXJ5JyA6IHRzVGFnO1xufVxuZnVuY3Rpb24gZ2V0VWludDhBcnJheShhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gYTtcbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSk7XG59XG5cbmNsYXNzIENvbGxlY3Rpb24ge1xuICAgIF9yZWFkKGZuLCBjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZG9ubHknLCBmbikudGhlbihjYik7XG4gICAgfVxuICAgIF93cml0ZShmbikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICByZXR1cm4gY3R4LmVycm9yID9cbiAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMobnVsbCwgcmVqZWN0aW9uLmJpbmQobnVsbCwgY3R4LmVycm9yKSkgOlxuICAgICAgICAgICAgY3R4LnRhYmxlLl90cmFucygncmVhZHdyaXRlJywgZm4sIFwibG9ja2VkXCIpO1xuICAgIH1cbiAgICBfYWRkQWxnb3JpdGhtKGZuKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5hbGdvcml0aG0gPSBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZuKTtcbiAgICB9XG4gICAgX2l0ZXJhdGUoZm4sIGNvcmVUcmFucykge1xuICAgICAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcbiAgICB9XG4gICAgY2xvbmUocHJvcHMpIHtcbiAgICAgICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksIGN0eCA9IE9iamVjdC5jcmVhdGUodGhpcy5fY3R4KTtcbiAgICAgICAgaWYgKHByb3BzKVxuICAgICAgICAgICAgZXh0ZW5kKGN0eCwgcHJvcHMpO1xuICAgICAgICBydi5fY3R4ID0gY3R4O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHJhdygpIHtcbiAgICAgICAgdGhpcy5fY3R4LnZhbHVlTWFwcGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVhY2goZm4pIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4gaXRlcihjdHgsIGZuLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpKTtcbiAgICB9XG4gICAgY291bnQoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVRhYmxlLnNjaGVtYSksXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS50aGVuKGNvdW50ID0+IE1hdGgubWluKGNvdW50LCBjdHgubGltaXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCAoKSA9PiB7ICsrY291bnQ7IHJldHVybiBmYWxzZTsgfSwgdHJhbnMsIGNvcmVUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgc29ydEJ5KGtleVBhdGgsIGNiKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0ga2V5UGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKSwgbGFzdFBhcnQgPSBwYXJ0c1swXSwgbGFzdEluZGV4ID0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dmFsKG9iaiwgaSkge1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldHZhbChvYmpbcGFydHNbaV1dLCBpIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2xhc3RQYXJ0XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JkZXIgPSB0aGlzLl9jdHguZGlyID09PSBcIm5leHRcIiA/IDEgOiAtMTtcbiAgICAgICAgZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBhVmFsID0gZ2V0dmFsKGEsIGxhc3RJbmRleCksIGJWYWwgPSBnZXR2YWwoYiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBhVmFsIDwgYlZhbCA/IC1vcmRlciA6IGFWYWwgPiBiVmFsID8gb3JkZXIgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnNvcnQoc29ydGVyKTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHRvQXJyYXkoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWVNYXBwZXIgfSA9IGN0eDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbigoeyByZXN1bHQgfSkgPT4gdmFsdWVNYXBwZXIgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyKSA6IHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBpdGVtID0+IGEucHVzaChpdGVtKSwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKS50aGVuKCgpID0+IGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjYik7XG4gICAgfVxuICAgIG9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgaWYgKG9mZnNldCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkpIHtcbiAgICAgICAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnNvciwgYWR2YW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2Uob2Zmc2V0TGVmdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+ICgtLW9mZnNldExlZnQgPCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsaW1pdChudW1Sb3dzKSB7XG4gICAgICAgIHRoaXMuX2N0eC5saW1pdCA9IE1hdGgubWluKHRoaXMuX2N0eC5saW1pdCwgbnVtUm93cyk7XG4gICAgICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsICgpID0+IHtcbiAgICAgICAgICAgIHZhciByb3dzTGVmdCA9IG51bVJvd3M7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICgtLXJvd3NMZWZ0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd3NMZWZ0ID49IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVudGlsKGZpbHRlckZ1bmN0aW9uLCBiSW5jbHVkZVN0b3BFbnRyeSkge1xuICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJJbmNsdWRlU3RvcEVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmlyc3QoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkudG9BcnJheShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG4gICAgfVxuICAgIGxhc3QoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0KGNiKTtcbiAgICB9XG4gICAgZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhbmQoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmaWx0ZXIpO1xuICAgIH1cbiAgICBvcihpbmRleE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcbiAgICB9XG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgdGhpcy5fY3R4LmRpciA9ICh0aGlzLl9jdHguZGlyID09PSBcInByZXZcIiA/IFwibmV4dFwiIDogXCJwcmV2XCIpO1xuICAgICAgICBpZiAodGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZWFjaEtleShjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5rZXksIGN1cnNvcik7IH0pO1xuICAgIH1cbiAgICBlYWNoVW5pcXVlS2V5KGNiKSB7XG4gICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoS2V5KGNiKTtcbiAgICB9XG4gICAgZWFjaFByaW1hcnlLZXkoY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yKTsgfSk7XG4gICAgfVxuICAgIGtleXMoY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHByaW1hcnlLZXlzKGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkudGhlbigoeyByZXN1bHQgfSkgPT4gcmVzdWx0KS50aGVuKGNiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGl0ZW0sIGN1cnNvcikge1xuICAgICAgICAgICAgYS5wdXNoKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHVuaXF1ZUtleXMoY2IpIHtcbiAgICAgICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoY2IpO1xuICAgIH1cbiAgICBmaXJzdEtleShjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdCgxKS5rZXlzKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgbGFzdEtleShjYikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuICAgIH1cbiAgICBkaXN0aW5jdCgpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgaWR4ID0gY3R4LmluZGV4ICYmIGN0eC50YWJsZS5zY2hlbWEuaWR4QnlOYW1lW2N0eC5pbmRleF07XG4gICAgICAgIGlmICghaWR4IHx8ICFpZHgubXVsdGkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICAgICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG4gICAgICAgICAgICBzZXRbc3RyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1vZGlmeShjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICAgICAgICB2YXIgbW9kaWZ5ZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtb2RpZnllciA9IGNoYW5nZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG1vZGlmeWVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlQYXRoID0ga2V5UGF0aHNbaV0sIHZhbCA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICAgICAgICBjb25zdCB7IG91dGJvdW5kLCBleHRyYWN0S2V5IH0gPSBjb3JlVGFibGUuc2NoZW1hLnByaW1hcnlLZXk7XG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMuZGIuX29wdGlvbnMubW9kaWZ5Q2h1bmtTaXplIHx8IDIwMDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsRmFpbHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgZmFpbGVkS2V5cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYXBwbHlNdXRhdGVSZXN1bHQgPSAoZXhwZWN0ZWRDb3VudCwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmYWlsdXJlcywgbnVtRmFpbHVyZXMgfSA9IHJlcztcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQgKz0gZXhwZWN0ZWRDb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBrZXlzKGZhaWx1cmVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbEZhaWx1cmVzLnB1c2goZmFpbHVyZXNbcG9zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkucHJpbWFyeUtleXMoKS50aGVuKGtleXMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaHVuayA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihsaW1pdCwga2V5cy5sZW5ndGggLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBrZXlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IFwiaW1tdXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbih2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkVmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1dEtleXMgPSBvdXRib3VuZCA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleToga2V5c1tvZmZzZXQgKyBpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmeWVyLmNhbGwoY3R4LCBjdHgudmFsdWUsIGN0eCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFvdXRib3VuZCAmJiBjbXAoZXh0cmFjdEtleShvcmlnVmFsdWUpLCBleHRyYWN0S2V5KGN0eC52YWx1ZSkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZXMucHVzaChjdHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFsdWVzLnB1c2goY3R4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRLZXlzLnB1c2goa2V5c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbWl0ID09PSBJbmZpbml0eSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJyB8fCBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdHguaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkVmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdhZGQnLCB2YWx1ZXM6IGFkZFZhbHVlcyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgaW4gcmVzLmZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnNwbGljZShwYXJzZUludChwb3MpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU11dGF0ZVJlc3VsdChhZGRWYWx1ZXMubGVuZ3RoLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKCgpID0+IChwdXRWYWx1ZXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgdHlwZW9mIGNoYW5nZXMgPT09ICdvYmplY3QnKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBwdXRLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHB1dFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWM6IHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihyZXMgPT4gYXBwbHlNdXRhdGVSZXN1bHQocHV0VmFsdWVzLmxlbmd0aCwgcmVzKSkpLnRoZW4oKCkgPT4gKGRlbGV0ZUtleXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGRlbGV0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihyZXMgPT4gYXBwbHlNdXRhdGVSZXN1bHQoZGVsZXRlS2V5cy5sZW5ndGgsIHJlcykpKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGggPiBvZmZzZXQgKyBjb3VudCAmJiBuZXh0Q2h1bmsob2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaHVuaygwKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsRmFpbHVyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkVycm9yIG1vZGlmeWluZyBvbmUgb3IgbW9yZSBvYmplY3RzXCIsIHRvdGFsRmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LCByYW5nZSA9IGN0eC5yYW5nZTtcbiAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAoKGN0eC5pc1ByaW1LZXkgJiYgIWhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlKSB8fCByYW5nZS50eXBlID09PSAzICkpXG4gICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUodHJhbnMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gY3R4LnRhYmxlLmNvcmUuc2NoZW1hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcmVSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5jb3VudCh7IHRyYW5zLCBxdWVyeTogeyBpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IGNvcmVSYW5nZSB9IH0pLnRoZW4oY291bnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBjb3JlUmFuZ2UgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IGZhaWx1cmVzLCBsYXN0UmVzdWx0LCByZXN1bHRzLCBudW1GYWlsdXJlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiQ291bGQgbm90IGRlbGV0ZSBzb21lIHZhbHVlc1wiLCBPYmplY3Qua2V5cyhmYWlsdXJlcykubWFwKHBvcyA9PiBmYWlsdXJlc1twb3NdKSwgY291bnQgLSBudW1GYWlsdXJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tb2RpZnkoZGVsZXRlQ2FsbGJhY2spO1xuICAgIH1cbn1cbmNvbnN0IGRlbGV0ZUNhbGxiYWNrID0gKHZhbHVlLCBjdHgpID0+IGN0eC52YWx1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihDb2xsZWN0aW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwga2V5UmFuZ2VHZW5lcmF0b3IpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICBsZXQga2V5UmFuZ2UgPSBBbnlSYW5nZSwgZXJyb3IgPSBudWxsO1xuICAgICAgICBpZiAoa2V5UmFuZ2VHZW5lcmF0b3IpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGtleVJhbmdlID0ga2V5UmFuZ2VHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdoZXJlQ3R4ID0gd2hlcmVDbGF1c2UuX2N0eDtcbiAgICAgICAgY29uc3QgdGFibGUgPSB3aGVyZUN0eC50YWJsZTtcbiAgICAgICAgY29uc3QgcmVhZGluZ0hvb2sgPSB0YWJsZS5ob29rLnJlYWRpbmcuZmlyZTtcbiAgICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgaW5kZXg6IHdoZXJlQ3R4LmluZGV4LFxuICAgICAgICAgICAgaXNQcmltS2V5OiAoIXdoZXJlQ3R4LmluZGV4IHx8ICh0YWJsZS5zY2hlbWEucHJpbUtleS5rZXlQYXRoICYmIHdoZXJlQ3R4LmluZGV4ID09PSB0YWJsZS5zY2hlbWEucHJpbUtleS5uYW1lKSksXG4gICAgICAgICAgICByYW5nZToga2V5UmFuZ2UsXG4gICAgICAgICAgICBrZXlzT25seTogZmFsc2UsXG4gICAgICAgICAgICBkaXI6IFwibmV4dFwiLFxuICAgICAgICAgICAgdW5pcXVlOiBcIlwiLFxuICAgICAgICAgICAgYWxnb3JpdGhtOiBudWxsLFxuICAgICAgICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgcmVwbGF5RmlsdGVyOiBudWxsLFxuICAgICAgICAgICAganVzdExpbWl0OiB0cnVlLFxuICAgICAgICAgICAgaXNNYXRjaDogbnVsbCxcbiAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgIGxpbWl0OiBJbmZpbml0eSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG9yOiB3aGVyZUN0eC5vcixcbiAgICAgICAgICAgIHZhbHVlTWFwcGVyOiByZWFkaW5nSG9vayAhPT0gbWlycm9yID8gcmVhZGluZ0hvb2sgOiBudWxsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuZnVuY3Rpb24gc2ltcGxlQ29tcGFyZVJldmVyc2UoYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG5mdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLCBlcnIsIFQpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIGluc3RhbmNlb2YgV2hlcmVDbGF1c2UgP1xuICAgICAgICBuZXcgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UuQ29sbGVjdGlvbihjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSkgOlxuICAgICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICBjb2xsZWN0aW9uLl9jdHguZXJyb3IgPSBUID8gbmV3IFQoZXJyKSA6IG5ldyBUeXBlRXJyb3IoZXJyKTtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGVtcHR5Q29sbGVjdGlvbih3aGVyZUNsYXVzZSkge1xuICAgIHJldHVybiBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbih3aGVyZUNsYXVzZSwgKCkgPT4gcmFuZ2VFcXVhbChcIlwiKSkubGltaXQoMCk7XG59XG5mdW5jdGlvbiB1cHBlckZhY3RvcnkoZGlyKSB7XG4gICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAocykgPT4gcy50b1VwcGVyQ2FzZSgpIDpcbiAgICAgICAgKHMpID0+IHMudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGxvd2VyRmFjdG9yeShkaXIpIHtcbiAgICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgICAgIChzKSA9PiBzLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAocykgPT4gcy50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZSwgbG93ZXJOZWVkbGUsIGNtcCwgZGlyKSB7XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleS5sZW5ndGgsIGxvd2VyTmVlZGxlLmxlbmd0aCk7XG4gICAgdmFyIGxscCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGx3cktleUNoYXIgPSBsb3dlcktleVtpXTtcbiAgICAgICAgaWYgKGx3cktleUNoYXIgIT09IGxvd2VyTmVlZGxlW2ldKSB7XG4gICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgdXBwZXJOZWVkbGVbaV0pIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIHVwcGVyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCBsb3dlck5lZWRsZVtpXSkgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgbG93ZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGxscCA+PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlcktleVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtcChrZXlbaV0sIGx3cktleUNoYXIpIDwgMClcbiAgICAgICAgICAgIGxscCA9IGk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCBsb3dlck5lZWRsZS5sZW5ndGggJiYgZGlyID09PSBcIm5leHRcIilcbiAgICAgICAgcmV0dXJuIGtleSArIHVwcGVyTmVlZGxlLnN1YnN0cihrZXkubGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoIDwga2V5Lmxlbmd0aCAmJiBkaXIgPT09IFwicHJldlwiKVxuICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuICAgIHJldHVybiAobGxwIDwgMCA/IG51bGwgOiBrZXkuc3Vic3RyKDAsIGxscCkgKyBsb3dlck5lZWRsZVtsbHBdICsgdXBwZXJOZWVkbGUuc3Vic3RyKGxscCArIDEpKTtcbn1cbmZ1bmN0aW9uIGFkZElnbm9yZUNhc2VBbGdvcml0aG0od2hlcmVDbGF1c2UsIG1hdGNoLCBuZWVkbGVzLCBzdWZmaXgpIHtcbiAgICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LCBuZWVkbGVzTGVuID0gbmVlZGxlcy5sZW5ndGg7XG4gICAgaWYgKCFuZWVkbGVzLmV2ZXJ5KHMgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdERpcmVjdGlvbihkaXIpIHtcbiAgICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlckZhY3RvcnkoZGlyKTtcbiAgICAgICAgY29tcGFyZSA9IChkaXIgPT09IFwibmV4dFwiID8gc2ltcGxlQ29tcGFyZSA6IHNpbXBsZUNvbXBhcmVSZXZlcnNlKTtcbiAgICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxvd2VyOiBsb3dlcihuZWVkbGUpLCB1cHBlcjogdXBwZXIobmVlZGxlKSB9O1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZShhLmxvd2VyLCBiLmxvd2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVwcGVyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi51cHBlcjsgfSk7XG4gICAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKSB7IHJldHVybiBuYi5sb3dlcjsgfSk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGRpcjtcbiAgICAgICAgbmV4dEtleVN1ZmZpeCA9IChkaXIgPT09IFwibmV4dFwiID8gXCJcIiA6IHN1ZmZpeCk7XG4gICAgfVxuICAgIGluaXREaXJlY3Rpb24oXCJuZXh0XCIpO1xuICAgIHZhciBjID0gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24od2hlcmVDbGF1c2UsICgpID0+IGNyZWF0ZVJhbmdlKHVwcGVyTmVlZGxlc1swXSwgbG93ZXJOZWVkbGVzW25lZWRsZXNMZW4gLSAxXSArIHN1ZmZpeCkpO1xuICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICBpbml0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgfTtcbiAgICB2YXIgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IDA7XG4gICAgYy5fYWRkQWxnb3JpdGhtKGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGxvd2VyS2V5ID0gbG93ZXIoa2V5KTtcbiAgICAgICAgaWYgKG1hdGNoKGxvd2VyS2V5LCBsb3dlck5lZWRsZXMsIGZpcnN0UG9zc2libGVOZWVkbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQb3NzaWJsZU5lZWRsZTsgaSA8IG5lZWRsZXNMZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjYXNpbmcgPSBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlc1tpXSwgbG93ZXJOZWVkbGVzW2ldLCBjb21wYXJlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChjYXNpbmcgPT09IG51bGwgJiYgbG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UG9zc2libGVOZWVkbGUgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbCB8fCBjb21wYXJlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nLCBjYXNpbmcpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IGNhc2luZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKGZ1bmN0aW9uICgpIHsgY3Vyc29yLmNvbnRpbnVlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICsgbmV4dEtleVN1ZmZpeCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjO1xufVxuZnVuY3Rpb24gY3JlYXRlUmFuZ2UobG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3Blbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIgLFxuICAgICAgICBsb3dlcixcbiAgICAgICAgdXBwZXIsXG4gICAgICAgIGxvd2VyT3BlbixcbiAgICAgICAgdXBwZXJPcGVuXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlRXF1YWwodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxICxcbiAgICAgICAgbG93ZXI6IHZhbHVlLFxuICAgICAgICB1cHBlcjogdmFsdWVcbiAgICB9O1xufVxuXG5jbGFzcyBXaGVyZUNsYXVzZSB7XG4gICAgZ2V0IENvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgudGFibGUuZGIuQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgYmV0d2Vlbihsb3dlciwgdXBwZXIsIGluY2x1ZGVMb3dlciwgaW5jbHVkZVVwcGVyKSB7XG4gICAgICAgIGluY2x1ZGVMb3dlciA9IGluY2x1ZGVMb3dlciAhPT0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVVcHBlciA9IGluY2x1ZGVVcHBlciA9PT0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPiAwKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXF1YWxzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiByYW5nZUVxdWFsKHZhbHVlKSk7XG4gICAgfVxuICAgIGFib3ZlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuICAgIGFib3ZlT3JFcXVhbCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgYmVsb3codmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUsIGZhbHNlLCB0cnVlKSk7XG4gICAgfVxuICAgIGJlbG93T3JFcXVhbCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHN0cikge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgICAgICByZXR1cm4gdGhpcy5iZXR3ZWVuKHN0ciwgc3RyICsgbWF4U3RyaW5nLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aElnbm9yZUNhc2Uoc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydHNXaXRoKHN0cik7XG4gICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4LmluZGV4T2YoYVswXSkgPT09IDAsIFtzdHJdLCBtYXhTdHJpbmcpO1xuICAgIH1cbiAgICBlcXVhbHNJZ25vcmVDYXNlKHN0cikge1xuICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4geCA9PT0gYVswXSwgW3N0cl0sIFwiXCIpO1xuICAgIH1cbiAgICBhbnlPZklnbm9yZUNhc2UoKSB7XG4gICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IGEuaW5kZXhPZih4KSAhPT0gLTEsIHNldCwgXCJcIik7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UoKSB7XG4gICAgICAgIHZhciBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IGEuc29tZShuID0+IHguaW5kZXhPZihuKSA9PT0gMCksIHNldCwgbWF4U3RyaW5nKTtcbiAgICB9XG4gICAgYW55T2YoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLl9jbXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgY29uc3QgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2Uoc2V0WzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZGlyZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbXBhcmUgPSAoZGlyZWN0aW9uID09PSBcIm5leHRcIiA/XG4gICAgICAgICAgICAgICAgdGhpcy5fYXNjZW5kaW5nIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXNjZW5kaW5nKTtcbiAgICAgICAgICAgIHNldC5zb3J0KGNvbXBhcmUpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGMuX2FkZEFsZ29yaXRobSgoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKCgpID0+IHsgY3Vyc29yLmNvbnRpbnVlKHNldFtpXSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBub3RFcXVhbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKFtbbWluS2V5LCB2YWx1ZV0sIFt2YWx1ZSwgdGhpcy5kYi5fbWF4S2V5XV0sIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBub25lT2YoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHNldC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldC5zb3J0KHRoaXMuX2FzY2VuZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZXMgPSBzZXQucmVkdWNlKChyZXMsIHZhbCkgPT4gcmVzID9cbiAgICAgICAgICAgIHJlcy5jb25jYXQoW1tyZXNbcmVzLmxlbmd0aCAtIDFdWzFdLCB2YWxdXSkgOlxuICAgICAgICAgICAgW1ttaW5LZXksIHZhbF1dLCBudWxsKTtcbiAgICAgICAgcmFuZ2VzLnB1c2goW3NldFtzZXQubGVuZ3RoIC0gMV0sIHRoaXMuZGIuX21heEtleV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHJhbmdlcywgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gICAgfVxuICAgIGluQW55UmFuZ2UocmFuZ2VzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuX2NtcCwgYXNjZW5kaW5nID0gdGhpcy5fYXNjZW5kaW5nLCBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZywgbWluID0gdGhpcy5fbWluLCBtYXggPSB0aGlzLl9tYXg7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgaWYgKCFyYW5nZXMuZXZlcnkocmFuZ2UgPT4gcmFuZ2VbMF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcmFuZ2VbMV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgYXNjZW5kaW5nKHJhbmdlWzBdLCByYW5nZVsxXSkgPD0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwiRmlyc3QgYXJndW1lbnQgdG8gaW5BbnlSYW5nZSgpIG11c3QgYmUgYW4gQXJyYXkgb2YgdHdvLXZhbHVlIEFycmF5cyBbbG93ZXIsdXBwZXJdIHdoZXJlIHVwcGVyIG11c3Qgbm90IGJlIGxvd2VyIHRoYW4gbG93ZXJcIiwgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluY2x1ZGVMb3dlcnMgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmluY2x1ZGVMb3dlcnMgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBpbmNsdWRlVXBwZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVVcHBlcnMgPT09IHRydWU7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlcywgbmV3UmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlWzBdID0gbWluKHJhbmdlWzBdLCBuZXdSYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlWzFdID0gbWF4KHJhbmdlWzFdLCBuZXdSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBsKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ld1JhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG4gICAgICAgIGZ1bmN0aW9uIHJhbmdlU29ydGVyKGEsIGIpIHsgcmV0dXJuIHNvcnREaXJlY3Rpb24oYVswXSwgYlswXSk7IH1cbiAgICAgICAgbGV0IHNldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldCA9IHJhbmdlcy5yZWR1Y2UoYWRkUmFuZ2UsIFtdKTtcbiAgICAgICAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VQb3MgPSAwO1xuICAgICAgICBjb25zdCBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSA9IGluY2x1ZGVVcHBlcnMgP1xuICAgICAgICAgICAga2V5ID0+IGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID4gMCA6XG4gICAgICAgICAgICBrZXkgPT4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPj0gMDtcbiAgICAgICAgY29uc3Qga2V5SXNCZWZvcmVDdXJyZW50RW50cnkgPSBpbmNsdWRlTG93ZXJzID9cbiAgICAgICAgICAgIGtleSA9PiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPiAwIDpcbiAgICAgICAgICAgIGtleSA9PiBkZXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPj0gMDtcbiAgICAgICAgZnVuY3Rpb24ga2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuICFrZXlJc0JleW9uZEN1cnJlbnRFbnRyeShrZXkpICYmICFrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuICAgICAgICBjb25zdCBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZShzZXRbMF1bMF0sIHNldFtzZXQubGVuZ3RoIC0gMV1bMV0sICFpbmNsdWRlTG93ZXJzLCAhaW5jbHVkZVVwcGVycykpO1xuICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGRpcmVjdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZWZvcmVDdXJyZW50RW50cnk7XG4gICAgICAgICAgICAgICAgc29ydERpcmVjdGlvbiA9IGRlc2NlbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgICAgIH07XG4gICAgICAgIGMuX2FkZEFsZ29yaXRobSgoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgIHdoaWxlIChjaGVja0tleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgKytyYW5nZVBvcztcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQb3MgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPT09IDAgfHwgdGhpcy5fY21wKGtleSwgc2V0W3JhbmdlUG9zXVswXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnREaXJlY3Rpb24gPT09IGFzY2VuZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBzdGFydHNXaXRoQW55T2YoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFzZXQuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcInN0YXJ0c1dpdGhBbnlPZigpIG9ubHkgd29ya3Mgd2l0aCBzdHJpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShzZXQubWFwKChzdHIpID0+IFtzdHIsIHN0ciArIG1heFN0cmluZ10pKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoV2hlcmVDbGF1c2UucHJvdG90eXBlLCBmdW5jdGlvbiBXaGVyZUNsYXVzZSh0YWJsZSwgaW5kZXgsIG9yQ29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCA9PT0gXCI6aWRcIiA/IG51bGwgOiBpbmRleCxcbiAgICAgICAgICAgIG9yOiBvckNvbGxlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5kZXhlZERCID0gZGIuX2RlcHMuaW5kZXhlZERCO1xuICAgICAgICBpZiAoIWluZGV4ZWREQilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gaW5kZXhlZERCLmNtcC5iaW5kKGluZGV4ZWREQik7XG4gICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcgPSAoYSwgYikgPT4gaW5kZXhlZERCLmNtcChiLCBhKTtcbiAgICAgICAgdGhpcy5fbWF4ID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYSwgYikgPiAwID8gYSA6IGI7XG4gICAgICAgIHRoaXMuX21pbiA9IChhLCBiKSA9PiBpbmRleGVkREIuY21wKGEsIGIpIDwgMCA/IGEgOiBiO1xuICAgICAgICB0aGlzLl9JREJLZXlSYW5nZSA9IGRiLl9kZXBzLklEQktleVJhbmdlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KSB7XG4gICAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5jb25zdCBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSA9ICdzdG9yYWdlbXV0YXRlZCc7XG5jb25zdCBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgPSAneC1zdG9yYWdlbXV0YXRlZC0xJztcbmNvbnN0IGdsb2JhbEV2ZW50cyA9IEV2ZW50cyhudWxsLCBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSk7XG5cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICBfbG9jaygpIHtcbiAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcbiAgICAgICAgKyt0aGlzLl9yZWN1bG9jaztcbiAgICAgICAgaWYgKHRoaXMuX3JlY3Vsb2NrID09PSAxICYmICFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgUFNELmxvY2tPd25lckZvciA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfdW5sb2NrKCkge1xuICAgICAgICBhc3NlcnQoIVBTRC5nbG9iYWwpO1xuICAgICAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCFQU0QuZ2xvYmFsKVxuICAgICAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2Jsb2NrZWRGdW5jcy5sZW5ndGggPiAwICYmICF0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9sb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuICAgIH1cbiAgICBjcmVhdGUoaWRidHJhbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuICAgICAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuZGIuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgICAgICBhc3NlcnQoIXRoaXMuaWRidHJhbnMpO1xuICAgICAgICBpZiAoIWlkYnRyYW5zICYmICFpZGJkYikge1xuICAgICAgICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkRhdGFiYXNlQ2xvc2VkRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJNaXNzaW5nQVBJRXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICAgICAgYXNzZXJ0KHRoaXMuX2NvbXBsZXRpb24uX3N0YXRlID09PSBudWxsKTtcbiAgICAgICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcbiAgICAgICAgICAgICh0aGlzLmRiLmNvcmVcbiAgICAgICAgICAgICAgICA/IHRoaXMuZGIuY29yZS50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KVxuICAgICAgICAgICAgICAgIDogaWRiZGIudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSkpO1xuICAgICAgICBpZGJ0cmFucy5vbmVycm9yID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWRidHJhbnMub25hYm9ydCA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgJiYgdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KGlkYnRyYW5zLmVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbihcImFib3J0XCIpLmZpcmUoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWRidHJhbnMub25jb21wbGV0ZSA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgIGlmICgnbXV0YXRlZFBhcnRzJyBpbiBpZGJ0cmFucykge1xuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKGlkYnRyYW5zW1wibXV0YXRlZFBhcnRzXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfcHJvbWlzZShtb2RlLCBmbiwgYldyaXRlTG9jaykge1xuICAgICAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScgJiYgdGhpcy5tb2RlICE9PSAncmVhZHdyaXRlJylcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoXCJUcmFuc2FjdGlvbiBpcyByZWFkb25seVwiKSk7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKSk7XG4gICAgICAgIGlmICh0aGlzLl9sb2NrZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrZWRGdW5jcy5wdXNoKFsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIFBTRF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYldyaXRlTG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcC5maW5hbGx5KCgpID0+IHRoaXMuX3VubG9jaygpKTtcbiAgICAgICAgICAgICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pXG4gICAgICAgICAgICAgICAgICAgIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fcm9vdCgpIDogdGhpcztcbiAgICB9XG4gICAgd2FpdEZvcihwcm9taXNlTGlrZSkge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHByb21pc2VMaWtlKTtcbiAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpIHtcbiAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSByb290Ll93YWl0aW5nRm9yLnRoZW4oKCkgPT4gcHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gcm9vdC5pZGJ0cmFucy5vYmplY3RTdG9yZShyb290LnN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgKGZ1bmN0aW9uIHNwaW4oKSB7XG4gICAgICAgICAgICAgICAgKytyb290Ll9zcGluQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJvb3QuX3dhaXRpbmdRdWV1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIChyb290Ll93YWl0aW5nUXVldWUuc2hpZnQoKSkoKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvcilcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0KC1JbmZpbml0eSkub25zdWNjZXNzID0gc3BpbjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihyZXMgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpLCBlcnIgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZWplY3QuYmluZChudWxsLCBlcnIpKSkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRidHJhbnMpXG4gICAgICAgICAgICAgICAgdGhpcy5pZGJ0cmFucy5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG5ldyBleGNlcHRpb25zLkFib3J0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICBjb25zdCBtZW1vaXplZFRhYmxlcyA9ICh0aGlzLl9tZW1vaXplZFRhYmxlcyB8fCAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgPSB7fSkpO1xuICAgICAgICBpZiAoaGFzT3duKG1lbW9pemVkVGFibGVzLCB0YWJsZU5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV07XG4gICAgICAgIGNvbnN0IHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcbiAgICAgICAgaWYgKCF0YWJsZVNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQm91bmRUYWJsZSA9IG5ldyB0aGlzLmRiLlRhYmxlKHRhYmxlTmFtZSwgdGFibGVTY2hlbWEsIHRoaXMpO1xuICAgICAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdID0gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihUcmFuc2FjdGlvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudCkge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuc3RvcmVOYW1lcyA9IHN0b3JlTmFtZXM7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICAgIHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5ID0gY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5O1xuICAgICAgICB0aGlzLmlkYnRyYW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG4gICAgICAgIHRoaXMuX2Jsb2NrZWRGdW5jcyA9IFtdO1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dhaXRpbmdRdWV1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY29tcGxldGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uLmNvbXBsZXRlLmZpcmUoKTtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICB2YXIgd2FzQWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbi5lcnJvci5maXJlKGUpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgP1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Ll9yZWplY3QoZSkgOlxuICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiB0aGlzLmlkYnRyYW5zICYmIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCwgdW5pcXVlLCBtdWx0aSwgYXV0bywgY29tcG91bmQsIGlzUHJpbUtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGtleVBhdGgsXG4gICAgICAgIHVuaXF1ZSxcbiAgICAgICAgbXVsdGksXG4gICAgICAgIGF1dG8sXG4gICAgICAgIGNvbXBvdW5kLFxuICAgICAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aClcbiAgICB9O1xufVxuZnVuY3Rpb24gbmFtZUZyb21LZXlQYXRoKGtleVBhdGgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAga2V5UGF0aCA6XG4gICAgICAgIGtleVBhdGggPyAoJ1snICsgW10uam9pbi5jYWxsKGtleVBhdGgsICcrJykgKyAnXScpIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFibGVTY2hlbWEobmFtZSwgcHJpbUtleSwgaW5kZXhlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHByaW1LZXksXG4gICAgICAgIGluZGV4ZXMsXG4gICAgICAgIG1hcHBlZENsYXNzOiBudWxsLFxuICAgICAgICBpZHhCeU5hbWU6IGFycmF5VG9PYmplY3QoaW5kZXhlcywgaW5kZXggPT4gW2luZGV4Lm5hbWUsIGluZGV4XSlcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzYWZhcmlNdWx0aVN0b3JlRml4KHN0b3JlTmFtZXMpIHtcbiAgICByZXR1cm4gc3RvcmVOYW1lcy5sZW5ndGggPT09IDEgPyBzdG9yZU5hbWVzWzBdIDogc3RvcmVOYW1lcztcbn1cbmxldCBnZXRNYXhLZXkgPSAoSWRiS2V5UmFuZ2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBJZGJLZXlSYW5nZS5vbmx5KFtbXV0pO1xuICAgICAgICBnZXRNYXhLZXkgPSAoKSA9PiBbW11dO1xuICAgICAgICByZXR1cm4gW1tdXTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZ2V0TWF4S2V5ID0gKCkgPT4gbWF4U3RyaW5nO1xuICAgICAgICByZXR1cm4gbWF4U3RyaW5nO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSB7XG4gICAgaWYgKGtleVBhdGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuICAgIGNvbnN0IHNwbGl0ID0ga2V5UGF0aC5zcGxpdCgnLicpO1xuICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PiBvYmpba2V5UGF0aF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlpZnkoYXJyYXlMaWtlKSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbn1cbmxldCBfaWRfY291bnRlciA9IDA7XG5mdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCkge1xuICAgIHJldHVybiBrZXlQYXRoID09IG51bGwgP1xuICAgICAgICBcIjppZFwiIDpcbiAgICAgICAgdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgIGtleVBhdGggOlxuICAgICAgICAgICAgYFske2tleVBhdGguam9pbignKycpfV1gO1xufVxuZnVuY3Rpb24gY3JlYXRlREJDb3JlKGRiLCBJZGJLZXlSYW5nZSwgdG1wVHJhbnMpIHtcbiAgICBmdW5jdGlvbiBleHRyYWN0U2NoZW1hKGRiLCB0cmFucykge1xuICAgICAgICBjb25zdCB0YWJsZXMgPSBhcnJheWlmeShkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRiLm5hbWUsXG4gICAgICAgICAgICAgICAgdGFibGVzOiB0YWJsZXMubWFwKHRhYmxlID0+IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlKSkubWFwKHN0b3JlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBrZXlQYXRoLCBhdXRvSW5jcmVtZW50IH0gPSBzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRib3VuZCA9IGtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhCeUtleVBhdGggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RvcmUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IGFycmF5aWZ5KHN0b3JlLmluZGV4TmFtZXMpLm1hcChpbmRleE5hbWUgPT4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGluZGV4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIHVuaXF1ZSwgbXVsdGlFbnRyeSwga2V5UGF0aCB9ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEluZGV4QnlLZXlQYXRoOiAoa2V5UGF0aCkgPT4gaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtcIjppZFwiXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc0dldEFsbDogdGFibGVzLmxlbmd0aCA+IDAgJiYgKCdnZXRBbGwnIGluIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlc1swXSkpICYmXG4gICAgICAgICAgICAgICAgISh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICEvKENocm9tZVxcL3xFZGdlXFwvKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgICAgIGNvbnN0IHsgbG93ZXIsIHVwcGVyLCBsb3dlck9wZW4sIHVwcGVyT3BlbiB9ID0gcmFuZ2U7XG4gICAgICAgIGNvbnN0IGlkYlJhbmdlID0gbG93ZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCAhIXVwcGVyT3BlbikgOlxuICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgISFsb3dlck9wZW4pIDpcbiAgICAgICAgICAgICAgICBJZGJLZXlSYW5nZS5ib3VuZChsb3dlciwgdXBwZXIsICEhbG93ZXJPcGVuLCAhIXVwcGVyT3Blbik7XG4gICAgICAgIHJldHVybiBpZGJSYW5nZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGFibGVTY2hlbWEubmFtZTtcbiAgICAgICAgZnVuY3Rpb24gbXV0YXRlKHsgdHJhbnMsIHR5cGUsIGtleXMsIHZhbHVlcywgcmFuZ2UgfSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Ym91bmQgPSBzdG9yZS5rZXlQYXRoID09IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBZGRPclB1dCA9IHR5cGUgPT09IFwicHV0XCIgfHwgdHlwZSA9PT0gXCJhZGRcIjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWRkT3JQdXQgJiYgdHlwZSAhPT0gJ2RlbGV0ZScgJiYgdHlwZSAhPT0gJ2RlbGV0ZVJhbmdlJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0ga2V5cyB8fCB2YWx1ZXMgfHwgeyBsZW5ndGg6IDEgfTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiB2YWx1ZXMgJiYga2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4ga2V5cyBhcnJheSBtdXN0IGhhdmUgc2FtZSBsZW5ndGggYXMgZ2l2ZW4gdmFsdWVzIGFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBudW1GYWlsdXJlczogMCwgZmFpbHVyZXM6IHt9LCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIGxldCByZXE7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICsrbnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGVsZXRlUmFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50eXBlID09PSA0IClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgbnVtRmFpbHVyZXMsIGZhaWx1cmVzLCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gMyApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuY2xlYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5kZWxldGUobWFrZUlEQktleVJhbmdlKHJhbmdlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2FyZ3MxLCBhcmdzMl0gPSBpc0FkZE9yUHV0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGJvdW5kID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVzLCBrZXlzXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlcywgbnVsbF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgW2tleXMsIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBZGRPclB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSAoYXJnczIgJiYgYXJnczJbaV0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldLCBhcmdzMltpXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmVbdHlwZV0oYXJnczFbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkb25lID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0UmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgcmVxcy5mb3JFYWNoKChyZXEsIGkpID0+IHJlcS5lcnJvciAhPSBudWxsICYmIChmYWlsdXJlc1tpXSA9IHJlcS5lcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bUZhaWx1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiB0eXBlID09PSBcImRlbGV0ZVwiID8ga2V5cyA6IHJlcXMubWFwKHJlcSA9PiByZXEucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZG9uZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9wZW5DdXJzb3IoeyB0cmFucywgdmFsdWVzLCBxdWVyeSwgcmV2ZXJzZSwgdW5pcXVlIH0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgcmFuZ2UgfSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgP1xuICAgICAgICAgICAgICAgICAgICBzdG9yZSA6XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHJldmVyc2UgP1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2XCIgOlxuICAgICAgICAgICAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXh0XCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pIDpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLl9fX2lkID0gKytfaWRfY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX2N1cnNvckNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5LmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX2N1cnNvckFkdmFuY2UgPSBjdXJzb3IuYWR2YW5jZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvVGhyb3dDdXJzb3JJc05vdFN0YXJ0ZWQgPSAoKSA9PiB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RhcnRlZFwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9UaHJvd0N1cnNvcklzU3RvcHBlZCA9ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdG9wcGVkXCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IudHJhbnMgPSB0cmFucztcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHdyYXAocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ290T25lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KCgpID0+IGdvdE9uZS0tID8gdGhpcy5jb250aW51ZSgpIDogdGhpcy5zdG9wKCkpLnRoZW4oKCkgPT4gdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlSXRlcmF0aW9uLCByZWplY3RJdGVyYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uID0gd3JhcChyZXNvbHZlSXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3RJdGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gcmVqZWN0SXRlcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJdGVyYXRpb24odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGd1YXJkZWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdGFydCA9ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIGJlaGluZCBsYXN0IGVudHJ5XCIpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGd1YXJkZWRDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlID0gX2N1cnNvckNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0aW9uUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBxdWVyeShoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgIHJldHVybiAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zLCB2YWx1ZXMsIGxpbWl0LCBxdWVyeSB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9uSW5maW5pdExpbWl0ID0gbGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHJhbmdlIH0gPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0OiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dldEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZ2V0QWxsS2V5cyhpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudCA9PiByZXNvbHZlKHsgcmVzdWx0OiBldmVudC50YXJnZXQucmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB2YWx1ZXMgfHwgISgnb3BlbktleUN1cnNvcicgaW4gc291cmNlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IoaWRiS2V5UmFuZ2UpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihpZGJLZXlSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVzID8gY3Vyc29yLnZhbHVlIDogY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsaW1pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgc2NoZW1hOiB0YWJsZVNjaGVtYSxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIGdldE1hbnkoeyB0cmFucywga2V5cyB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2FsbGJhY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZXN1bHRbcmVxLl9wb3NdID0gcmVxLnJlc3VsdCkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjYWxsYmFja0NvdW50ID09PSBrZXlDb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gc3RvcmUuZ2V0KGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5fcG9zID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gc3VjY2Vzc0hhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytrZXlDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Q291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0KHsgdHJhbnMsIGtleSB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gc3RvcmUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudCA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgICAgICAgb3BlbkN1cnNvcixcbiAgICAgICAgICAgIGNvdW50KHsgcXVlcnksIHRyYW5zIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZGV4LCByYW5nZSB9ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiByZXNvbHZlKGV2LnRhcmdldC5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyBzY2hlbWEsIGhhc0dldEFsbCB9ID0gZXh0cmFjdFNjaGVtYShkYiwgdG1wVHJhbnMpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHNjaGVtYS50YWJsZXMubWFwKHRhYmxlU2NoZW1hID0+IGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKSk7XG4gICAgY29uc3QgdGFibGVNYXAgPSB7fTtcbiAgICB0YWJsZXMuZm9yRWFjaCh0YWJsZSA9PiB0YWJsZU1hcFt0YWJsZS5uYW1lXSA9IHRhYmxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICAgICAgdHJhbnNhY3Rpb246IGRiLnRyYW5zYWN0aW9uLmJpbmQoZGIpLFxuICAgICAgICB0YWJsZShuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0YWJsZU1hcFtuYW1lXTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFibGUgJyR7bmFtZX0nIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlTWFwW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBNSU5fS0VZOiAtSW5maW5pdHksXG4gICAgICAgIE1BWF9LRVk6IGdldE1heEtleShJZGJLZXlSYW5nZSksXG4gICAgICAgIHNjaGVtYVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhzdGFja0ltcGwsIG1pZGRsZXdhcmVzKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZSgoZG93biwgeyBjcmVhdGUgfSkgPT4gKHsgLi4uZG93biwgLi4uY3JlYXRlKGRvd24pIH0pLCBzdGFja0ltcGwpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhtaWRkbGV3YXJlcywgaWRiZGIsIHsgSURCS2V5UmFuZ2UsIGluZGV4ZWREQiB9LCB0bXBUcmFucykge1xuICAgIGNvbnN0IGRiY29yZSA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFjayhjcmVhdGVEQkNvcmUoaWRiZGIsIElEQktleVJhbmdlLCB0bXBUcmFucyksIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGJjb3JlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyh7IF9ub3ZpcDogZGIgfSwgdG1wVHJhbnMpIHtcbiAgICBjb25zdCBpZGJkYiA9IHRtcFRyYW5zLmRiO1xuICAgIGNvbnN0IHN0YWNrcyA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MoZGIuX21pZGRsZXdhcmVzLCBpZGJkYiwgZGIuX2RlcHMsIHRtcFRyYW5zKTtcbiAgICBkYi5jb3JlID0gc3RhY2tzLmRiY29yZTtcbiAgICBkYi50YWJsZXMuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLm5hbWU7XG4gICAgICAgIGlmIChkYi5jb3JlLnNjaGVtYS50YWJsZXMuc29tZSh0YmwgPT4gdGJsLm5hbWUgPT09IHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBpZiAoZGJbdGFibGVOYW1lXSBpbnN0YW5jZW9mIGRiLlRhYmxlKSB7XG4gICAgICAgICAgICAgICAgZGJbdGFibGVOYW1lXS5jb3JlID0gdGFibGUuY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRBcGlPblBsYWNlKHsgX25vdmlwOiBkYiB9LCBvYmpzLCB0YWJsZU5hbWVzLCBkYnNjaGVtYSkge1xuICAgIHRhYmxlTmFtZXMuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBkYnNjaGVtYVt0YWJsZU5hbWVdO1xuICAgICAgICBvYmpzLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BEZXNjID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgdGFibGVOYW1lKTtcbiAgICAgICAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogPT09IGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSB8fCBvYmogaW5zdGFuY2VvZiBkYi5UcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZXRQcm9wKG9iaiwgdGFibGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnRhYmxlKHRhYmxlTmFtZSk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCB0YWJsZU5hbWUsIHsgdmFsdWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZW1vdmVUYWJsZXNBcGkoeyBfbm92aXA6IGRiIH0sIG9ianMpIHtcbiAgICBvYmpzLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9ialtrZXldIGluc3RhbmNlb2YgZGIuVGFibGUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBsb3dlclZlcnNpb25GaXJzdChhLCBiKSB7XG4gICAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG59XG5mdW5jdGlvbiBydW5VcGdyYWRlcnMoZGIsIG9sZFZlcnNpb24sIGlkYlVwZ3JhZGVUcmFucywgcmVqZWN0KSB7XG4gICAgY29uc3QgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgIGNvbnN0IHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBkYi5fc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgICB0cmFucy5jcmVhdGUoaWRiVXBncmFkZVRyYW5zKTtcbiAgICB0cmFucy5fY29tcGxldGlvbi5jYXRjaChyZWplY3QpO1xuICAgIGNvbnN0IHJlamVjdFRyYW5zYWN0aW9uID0gdHJhbnMuX3JlamVjdC5iaW5kKHRyYW5zKTtcbiAgICBjb25zdCB0cmFuc2xlc3MgPSBQU0QudHJhbnNsZXNzIHx8IFBTRDtcbiAgICBuZXdTY29wZSgoKSA9PiB7XG4gICAgICAgIFBTRC50cmFucyA9IHRyYW5zO1xuICAgICAgICBQU0QudHJhbnNsZXNzID0gdHJhbnNsZXNzO1xuICAgICAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHRhYmxlTmFtZSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgZ2xvYmFsU2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyhkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgIERleGllUHJvbWlzZS5mb2xsb3coKCkgPT4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucykpLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKGRiLCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKS5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVUYWJsZXNBbmRJbmRleGVzKHsgX25vdmlwOiBkYiB9LCBvbGRWZXJzaW9uLCB0cmFucywgaWRiVXBncmFkZVRyYW5zKSB7XG4gICAgY29uc3QgcXVldWUgPSBbXTtcbiAgICBjb25zdCB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcbiAgICBsZXQgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgIGxldCBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSBmYWxzZTtcbiAgICBjb25zdCB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIodiA9PiB2Ll9jZmcudmVyc2lvbiA+PSBvbGRWZXJzaW9uKTtcbiAgICB2ZXJzVG9SdW4uZm9yRWFjaCh2ZXJzaW9uID0+IHtcbiAgICAgICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG5ld1NjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG5ld1NjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYSwgbmV3U2NoZW1hKTtcbiAgICAgICAgICAgIGRpZmYuYWRkLmZvckVhY2godHVwbGUgPT4ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdHVwbGVbMF0sIHR1cGxlWzFdLnByaW1LZXksIHR1cGxlWzFdLmluZGV4ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaWZmLmNoYW5nZS5mb3JFYWNoKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5VcGdyYWRlKFwiTm90IHlldCBzdXBwb3J0IGZvciBjaGFuZ2luZyBwcmltYXJ5IGtleVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKGNoYW5nZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGlkeCA9PiBhZGRJbmRleChzdG9yZSwgaWR4KSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlSW5kZXgoaWR4Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5kZXgoc3RvcmUsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLmZvckVhY2goaWR4TmFtZSA9PiBzdG9yZS5kZWxldGVJbmRleChpZHhOYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VXBncmFkZSA9IHZlcnNpb24uX2NmZy5jb250ZW50VXBncmFkZTtcbiAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICAgICAgdHJhbnMuX21lbW9pemVkVGFibGVzID0ge307XG4gICAgICAgICAgICAgICAgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgdXBncmFkZVNjaGVtYSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuICAgICAgICAgICAgICAgIGRpZmYuZGVsLmZvckVhY2godGFibGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlU2NoZW1hW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgICAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYSksIHVwZ3JhZGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHRyYW5zLnNjaGVtYSA9IHVwZ3JhZGVTY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFVwZ3JhZGVJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKGNvbnRlbnRVcGdyYWRlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBjb250ZW50VXBncmFkZSh0cmFucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKSA6IHByb21pc2VGb2xsb3dlZC50aGVuKCgpID0+IHJldHVyblZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxdWV1ZS5wdXNoKGlkYnRyYW5zID0+IHtcbiAgICAgICAgICAgIGlmICghYW55Q29udGVudFVwZ3JhZGVySGFzUnVuIHx8ICFoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBkYi5fc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgICAgIHRyYW5zLnNjaGVtYSA9IGRiLl9kYlNjaGVtYTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcnVuUXVldWUoKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZS5sZW5ndGggPyBEZXhpZVByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuICAgICAgICAgICAgRGV4aWVQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1blF1ZXVlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZ2xvYmFsU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSkge1xuICAgIGNvbnN0IGRpZmYgPSB7XG4gICAgICAgIGRlbDogW10sXG4gICAgICAgIGFkZDogW10sXG4gICAgICAgIGNoYW5nZTogW11cbiAgICB9O1xuICAgIGxldCB0YWJsZTtcbiAgICBmb3IgKHRhYmxlIGluIG9sZFNjaGVtYSkge1xuICAgICAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pXG4gICAgICAgICAgICBkaWZmLmRlbC5wdXNoKHRhYmxlKTtcbiAgICB9XG4gICAgZm9yICh0YWJsZSBpbiBuZXdTY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSwgbmV3RGVmID0gbmV3U2NoZW1hW3RhYmxlXTtcbiAgICAgICAgaWYgKCFvbGREZWYpIHtcbiAgICAgICAgICAgIGRpZmYuYWRkLnB1c2goW3RhYmxlLCBuZXdEZWZdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgICAgICBkZWY6IG5ld0RlZixcbiAgICAgICAgICAgICAgICByZWNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgICAgICAgICBhZGQ6IFtdLFxuICAgICAgICAgICAgICAgIGNoYW5nZTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKFxuICAgICAgICAgICAgJycgKyAob2xkRGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpICE9PSAoJycgKyAobmV3RGVmLnByaW1LZXkua2V5UGF0aCB8fCAnJykpIHx8XG4gICAgICAgICAgICAgICAgKG9sZERlZi5wcmltS2V5LmF1dG8gIT09IG5ld0RlZi5wcmltS2V5LmF1dG8gJiYgIWlzSUVPckVkZ2UpKVxuICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UucmVjcmVhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEluZGV4ZXMgPSBvbGREZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ZXMgPSBuZXdEZWYuaWR4QnlOYW1lO1xuICAgICAgICAgICAgICAgIGxldCBpZHhOYW1lO1xuICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBvbGRJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3SW5kZXhlc1tpZHhOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5kZWwucHVzaChpZHhOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpZHhOYW1lIGluIG5ld0luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkSWR4ID0gb2xkSW5kZXhlc1tpZHhOYW1lXSwgbmV3SWR4ID0gbmV3SW5kZXhlc1tpZHhOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRJZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkLnB1c2gobmV3SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkSWR4LnNyYyAhPT0gbmV3SWR4LnNyYylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5jaGFuZ2UucHVzaChuZXdJZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpIHtcbiAgICBjb25zdCBzdG9yZSA9IGlkYnRyYW5zLmRiLmNyZWF0ZU9iamVjdFN0b3JlKHRhYmxlTmFtZSwgcHJpbUtleS5rZXlQYXRoID9cbiAgICAgICAgeyBrZXlQYXRoOiBwcmltS2V5LmtleVBhdGgsIGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9IDpcbiAgICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSk7XG4gICAgaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiBhZGRJbmRleChzdG9yZSwgaWR4KSk7XG4gICAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAga2V5cyhuZXdTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgaWYgKCFpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIG5ld1NjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIG5ld1NjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpIHtcbiAgICBbXS5zbGljZS5jYWxsKGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMpLmZvckVhY2goc3RvcmVOYW1lID0+IG5ld1NjaGVtYVtzdG9yZU5hbWVdID09IG51bGwgJiYgaWRidHJhbnMuZGIuZGVsZXRlT2JqZWN0U3RvcmUoc3RvcmVOYW1lKSk7XG59XG5mdW5jdGlvbiBhZGRJbmRleChzdG9yZSwgaWR4KSB7XG4gICAgc3RvcmUuY3JlYXRlSW5kZXgoaWR4Lm5hbWUsIGlkeC5rZXlQYXRoLCB7IHVuaXF1ZTogaWR4LnVuaXF1ZSwgbXVsdGlFbnRyeTogaWR4Lm11bHRpIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucykge1xuICAgIGNvbnN0IGdsb2JhbFNjaGVtYSA9IHt9O1xuICAgIGNvbnN0IGRiU3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICAgIGRiU3RvcmVOYW1lcy5mb3JFYWNoKHN0b3JlTmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgbGV0IGtleVBhdGggPSBzdG9yZS5rZXlQYXRoO1xuICAgICAgICBjb25zdCBwcmltS2V5ID0gY3JlYXRlSW5kZXhTcGVjKG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSwga2V5UGF0aCB8fCBcIlwiLCBmYWxzZSwgZmFsc2UsICEhc3RvcmUuYXV0b0luY3JlbWVudCwga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBpZGJpbmRleCA9IHN0b3JlLmluZGV4KHN0b3JlLmluZGV4TmFtZXNbal0pO1xuICAgICAgICAgICAga2V5UGF0aCA9IGlkYmluZGV4LmtleVBhdGg7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjcmVhdGVJbmRleFNwZWMoaWRiaW5kZXgubmFtZSwga2V5UGF0aCwgISFpZGJpbmRleC51bmlxdWUsICEhaWRiaW5kZXgubXVsdGlFbnRyeSwgZmFsc2UsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBnbG9iYWxTY2hlbWE7XG59XG5mdW5jdGlvbiByZWFkR2xvYmFsU2NoZW1hKHsgX25vdmlwOiBkYiB9LCBpZGJkYiwgdG1wVHJhbnMpIHtcbiAgICBkYi52ZXJubyA9IGlkYmRiLnZlcnNpb24gLyAxMDtcbiAgICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgICBkYi5fc3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzXSwga2V5cyhnbG9iYWxTY2hlbWEpLCBnbG9iYWxTY2hlbWEpO1xufVxuZnVuY3Rpb24gdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykge1xuICAgIGNvbnN0IGluc3RhbGxlZFNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgdG1wVHJhbnMpO1xuICAgIGNvbnN0IGRpZmYgPSBnZXRTY2hlbWFEaWZmKGluc3RhbGxlZFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcbiAgICByZXR1cm4gIShkaWZmLmFkZC5sZW5ndGggfHwgZGlmZi5jaGFuZ2Uuc29tZShjaCA9PiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKHsgX25vdmlwOiBkYiB9LCBzY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgY29uc3Qgc3RvcmVOYW1lcyA9IGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9yZU5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlTmFtZSA9IHN0b3JlTmFtZXNbaV07XG4gICAgICAgIGNvbnN0IHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgZGIuX2hhc0dldEFsbCA9ICdnZXRBbGwnIGluIHN0b3JlO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4TmFtZSA9IHN0b3JlLmluZGV4TmFtZXNbal07XG4gICAgICAgICAgICBjb25zdCBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuICAgICAgICAgICAgY29uc3QgZGV4aWVOYW1lID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IFwiW1wiICsgc2xpY2Uoa2V5UGF0aCkuam9pbignKycpICsgXCJdXCI7XG4gICAgICAgICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFNwZWMgPSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhTcGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4U3BlYy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtpbmRleE5hbWVdID0gaW5kZXhTcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJiBfZ2xvYmFsIGluc3RhbmNlb2YgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgICAgICBbXS5jb25jYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCopLykpWzFdIDwgNjA0KSB7XG4gICAgICAgIGRiLl9oYXNHZXRBbGwgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUluZGV4U3ludGF4KHByaW1LZXlBbmRJbmRleGVzKSB7XG4gICAgcmV0dXJuIHByaW1LZXlBbmRJbmRleGVzLnNwbGl0KCcsJykubWFwKChpbmRleCwgaW5kZXhOdW0pID0+IHtcbiAgICAgICAgaW5kZXggPSBpbmRleC50cmltKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRleC5yZXBsYWNlKC8oWyYqXXxcXCtcXCspL2csIFwiXCIpO1xuICAgICAgICBjb25zdCBrZXlQYXRoID0gL15cXFsvLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC9eXFxbKC4qKVxcXSQvKVsxXS5zcGxpdCgnKycpIDogbmFtZTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUluZGV4U3BlYyhuYW1lLCBrZXlQYXRoIHx8IG51bGwsIC9cXCYvLnRlc3QoaW5kZXgpLCAvXFwqLy50ZXN0KGluZGV4KSwgL1xcK1xcKy8udGVzdChpbmRleCksIGlzQXJyYXkoa2V5UGF0aCksIGluZGV4TnVtID09PSAwKTtcbiAgICB9KTtcbn1cblxuY2xhc3MgVmVyc2lvbiB7XG4gICAgX3BhcnNlU3RvcmVzU3BlYyhzdG9yZXMsIG91dFNjaGVtYSkge1xuICAgICAgICBrZXlzKHN0b3JlcykuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3Jlc1t0YWJsZU5hbWVdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBwYXJzZUluZGV4U3ludGF4KHN0b3Jlc1t0YWJsZU5hbWVdKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbUtleSA9IGluZGV4ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJpbUtleS5tdWx0aSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiUHJpbWFyeSBrZXkgY2Fubm90IGJlIG11bHRpLXZhbHVlZFwiKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeC5hdXRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiT25seSBwcmltYXJ5IGtleSBjYW4gYmUgbWFya2VkIGFzIGF1dG9JbmNyZW1lbnQgKCsrKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHgua2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkluZGV4IG11c3QgaGF2ZSBhIG5hbWUgYW5kIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0U2NoZW1hW3RhYmxlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYSh0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcmVzKHN0b3Jlcykge1xuICAgICAgICBjb25zdCBkYiA9IHRoaXMuZGI7XG4gICAgICAgIHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPSB0aGlzLl9jZmcuc3RvcmVzU291cmNlID9cbiAgICAgICAgICAgIGV4dGVuZCh0aGlzLl9jZmcuc3RvcmVzU291cmNlLCBzdG9yZXMpIDpcbiAgICAgICAgICAgIHN0b3JlcztcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gICAgICAgIGNvbnN0IHN0b3Jlc1NwZWMgPSB7fTtcbiAgICAgICAgbGV0IGRic2NoZW1hID0ge307XG4gICAgICAgIHZlcnNpb25zLmZvckVhY2godmVyc2lvbiA9PiB7XG4gICAgICAgICAgICBleHRlbmQoc3RvcmVzU3BlYywgdmVyc2lvbi5fY2ZnLnN0b3Jlc1NvdXJjZSk7XG4gICAgICAgICAgICBkYnNjaGVtYSA9ICh2ZXJzaW9uLl9jZmcuZGJzY2hlbWEgPSB7fSk7XG4gICAgICAgICAgICB2ZXJzaW9uLl9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzU3BlYywgZGJzY2hlbWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGIuX2RiU2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUsIHRoaXMuX2NmZy50YWJsZXNdLCBrZXlzKGRic2NoZW1hKSwgZGJzY2hlbWEpO1xuICAgICAgICBkYi5fc3RvcmVOYW1lcyA9IGtleXMoZGJzY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBncmFkZSh1cGdyYWRlRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlID0gcHJvbWlzYWJsZUNoYWluKHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSB8fCBub3AsIHVwZ3JhZGVGdW5jdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFZlcnNpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBWZXJzaW9uKHZlcnNpb25OdW1iZXIpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLl9jZmcgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uTnVtYmVyLFxuICAgICAgICAgICAgc3RvcmVzU291cmNlOiBudWxsLFxuICAgICAgICAgICAgZGJzY2hlbWE6IHt9LFxuICAgICAgICAgICAgdGFibGVzOiB7fSxcbiAgICAgICAgICAgIGNvbnRlbnRVcGdyYWRlOiBudWxsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKSB7XG4gICAgbGV0IGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl07XG4gICAgaWYgKCFkYk5hbWVzREIpIHtcbiAgICAgICAgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXSA9IG5ldyBEZXhpZSQxKERCTkFNRVNfREIsIHtcbiAgICAgICAgICAgIGFkZG9uczogW10sXG4gICAgICAgICAgICBpbmRleGVkREIsXG4gICAgICAgICAgICBJREJLZXlSYW5nZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRiTmFtZXNEQi52ZXJzaW9uKDEpLnN0b3Jlcyh7IGRibmFtZXM6IFwibmFtZVwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGJOYW1lc0RCLnRhYmxlKFwiZGJuYW1lc1wiKTtcbn1cbmZ1bmN0aW9uIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpIHtcbiAgICByZXR1cm4gaW5kZXhlZERCICYmIHR5cGVvZiBpbmRleGVkREIuZGF0YWJhc2VzID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXREYXRhYmFzZU5hbWVzKHsgaW5kZXhlZERCLCBJREJLZXlSYW5nZSwgfSkge1xuICAgIHJldHVybiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKVxuICAgICAgICA/IFByb21pc2UucmVzb2x2ZShpbmRleGVkREIuZGF0YWJhc2VzKCkpLnRoZW4oKGluZm9zKSA9PiBpbmZvc1xuICAgICAgICAgICAgLm1hcCgoaW5mbykgPT4gaW5mby5uYW1lKVxuICAgICAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gREJOQU1FU19EQikpXG4gICAgICAgIDogZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnRvQ29sbGVjdGlvbigpLnByaW1hcnlLZXlzKCk7XG59XG5mdW5jdGlvbiBfb25EYXRhYmFzZUNyZWF0ZWQoeyBpbmRleGVkREIsIElEQktleVJhbmdlIH0sIG5hbWUpIHtcbiAgICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICAgICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgICAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkucHV0KHsgbmFtZSB9KS5jYXRjaChub3ApO1xufVxuZnVuY3Rpb24gX29uRGF0YWJhc2VEZWxldGVkKHsgaW5kZXhlZERCLCBJREJLZXlSYW5nZSB9LCBuYW1lKSB7XG4gICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICAgICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLmRlbGV0ZShuYW1lKS5jYXRjaChub3ApO1xufVxuXG5mdW5jdGlvbiB2aXAoZm4pIHtcbiAgICByZXR1cm4gbmV3U2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpZGJSZWFkeSgpIHtcbiAgICB2YXIgaXNTYWZhcmkgPSAhbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiZcbiAgICAgICAgL1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhL0Nocm9tKGV8aXVtKVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAoIWlzU2FmYXJpIHx8ICFpbmRleGVkREIuZGF0YWJhc2VzKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGludGVydmFsSWQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciB0cnlJZGIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleGVkREIuZGF0YWJhc2VzKCkuZmluYWxseShyZXNvbHZlKTsgfTtcbiAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRyeUlkYiwgMTAwKTtcbiAgICAgICAgdHJ5SWRiKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsSWQpOyB9KTtcbn1cblxuZnVuY3Rpb24gZGV4aWVPcGVuKGRiKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBkYi5fc3RhdGU7XG4gICAgY29uc3QgeyBpbmRleGVkREIgfSA9IGRiLl9kZXBzO1xuICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkIHx8IGRiLmlkYmRiKVxuICAgICAgICByZXR1cm4gc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbigoKSA9PiBzdGF0ZS5kYk9wZW5FcnJvciA/XG4gICAgICAgICAgICByZWplY3Rpb24oc3RhdGUuZGJPcGVuRXJyb3IpIDpcbiAgICAgICAgICAgIGRiKTtcbiAgICBkZWJ1ZyAmJiAoc3RhdGUub3BlbkNhbmNlbGxlci5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpKTtcbiAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG4gICAgc3RhdGUub3BlbkNvbXBsZXRlID0gZmFsc2U7XG4gICAgY29uc3Qgb3BlbkNhbmNlbGxlciA9IHN0YXRlLm9wZW5DYW5jZWxsZXI7XG4gICAgZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZCgpIHtcbiAgICAgICAgaWYgKHN0YXRlLm9wZW5DYW5jZWxsZXIgIT09IG9wZW5DYW5jZWxsZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgnZGIub3BlbigpIHdhcyBjYW5jZWxsZWQnKTtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVEYlJlYWR5ID0gc3RhdGUuZGJSZWFkeVJlc29sdmUsXG4gICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbCwgd2FzQ3JlYXRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBEZXhpZVByb21pc2UucmFjZShbb3BlbkNhbmNlbGxlciwgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gRGV4aWVQcm9taXNlLnJlc29sdmUoKSA6IGlkYlJlYWR5KCkpLnRoZW4oKCkgPT4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICBpZiAoIWluZGV4ZWREQilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgICAgICBjb25zdCBkYk5hbWUgPSBkYi5uYW1lO1xuICAgICAgICAgICAgY29uc3QgcmVxID0gc3RhdGUuYXV0b1NjaGVtYSA/XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG4gICAgICAgICAgICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBNYXRoLnJvdW5kKGRiLnZlcm5vICogMTApKTtcbiAgICAgICAgICAgIGlmICghcmVxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICByZXEub25ibG9ja2VkID0gd3JhcChkYi5fZmlyZU9uQmxvY2tlZCk7XG4gICAgICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gd3JhcChlID0+IHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEgJiYgIWRiLl9vcHRpb25zLmFsbG93RW1wdHlEQikge1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IHByZXZlbnREZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxyZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZGVscmVxLm9uc3VjY2VzcyA9IGRlbHJlcS5vbmVycm9yID0gd3JhcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuTm9TdWNoRGF0YWJhc2UoYERhdGFiYXNlICR7ZGJOYW1lfSBkb2VzbnQgZXhpc3RgKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZlciA9IGUub2xkVmVyc2lvbiA+IE1hdGgucG93KDIsIDYyKSA/IDAgOiBlLm9sZFZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHdhc0NyZWF0ZWQgPSBvbGRWZXIgPCAxO1xuICAgICAgICAgICAgICAgICAgICBkYi5fbm92aXAuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBydW5VcGdyYWRlcnMoZGIsIG9sZFZlciAvIDEwLCB1cGdyYWRlVHJhbnNhY3Rpb24sIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkYmRiID0gZGIuX25vdmlwLmlkYmRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RTdG9yZU5hbWVzID0gc2xpY2UoaWRiZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcFRyYW5zID0gaWRiZGIudHJhbnNhY3Rpb24oc2FmYXJpTXVsdGlTdG9yZUZpeChvYmplY3RTdG9yZU5hbWVzKSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXV0b1NjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIGRiLl9kYlNjaGVtYSwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXhpZSBTY2hlbWFEaWZmOiBTY2hlbWEgd2FzIGV4dGVuZGVkIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgbnVtYmVyIHBhc3NlZCB0byBkYi52ZXJzaW9uKCkuIFNvbWUgcXVlcmllcyBtYXkgZmFpbC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbnMucHVzaChkYik7XG4gICAgICAgICAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZjRmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkYi5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWRiZGIub25jbG9zZSA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkYi5vbihcImNsb3NlXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh3YXNDcmVhdGVkKVxuICAgICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZUNyZWF0ZWQoZGIuX2RlcHMsIGRiTmFtZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSkpXSkudGhlbigoKSA9PiB7XG4gICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcCgoKSA9PiBkYi5vbi5yZWFkeS5maXJlKGRiLnZpcCkpKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluZGVycyA9IHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnJlZHVjZShwcm9taXNhYmxlQ2hhaW4sIG5vcCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmlwKCgpID0+IHJlbWFpbmRlcnMoZGIudmlwKSkpLnRoZW4oZmlyZVJlbWFpbmRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gZmFsc2U7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBkYjtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IGVycjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiAmJiB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICBpZiAob3BlbkNhbmNlbGxlciA9PT0gc3RhdGUub3BlbkNhbmNlbGxlcikge1xuICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlRGJSZWFkeSgpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhd2FpdEl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgdmFyIGNhbGxOZXh0ID0gcmVzdWx0ID0+IGl0ZXJhdG9yLm5leHQocmVzdWx0KSwgZG9UaHJvdyA9IGVycm9yID0+IGl0ZXJhdG9yLnRocm93KGVycm9yKSwgb25TdWNjZXNzID0gc3RlcChjYWxsTmV4dCksIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuICAgIGZ1bmN0aW9uIHN0ZXAoZ2V0TmV4dCkge1xuICAgICAgICByZXR1cm4gKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksIHZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB2YWx1ZSA6XG4gICAgICAgICAgICAgICAgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudGhlbiAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkodmFsdWUpID8gUHJvbWlzZS5hbGwodmFsdWUpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSA6IG9uU3VjY2Vzcyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc3RlcChjYWxsTmV4dCkoKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zYWN0aW9uQXJncyhtb2RlLCBfdGFibGVBcmdzXywgc2NvcGVGdW5jKSB7XG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChpIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiVG9vIGZldyBhcmd1bWVudHNcIik7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuICAgIHdoaWxlICgtLWkpXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIHNjb3BlRnVuYyA9IGFyZ3MucG9wKCk7XG4gICAgdmFyIHRhYmxlcyA9IGZsYXR0ZW4oYXJncyk7XG4gICAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG59XG5mdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpIHtcbiAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCB6b25lUHJvcHMgPSB7XG4gICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICB0cmFuc2xlc3M6IHRyYW5zbGVzc1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgICAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKCgpID0+IGVudGVyVHJhbnNhY3Rpb25TY29wZShkYiwgbW9kZSwgc3RvcmVOYW1lcywgbnVsbCwgc2NvcGVGdW5jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oc2NvcGVGdW5jKTtcbiAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICBjb25zdCBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gc2NvcGVGdW5jLmNhbGwodHJhbnMsIHRyYW5zKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJldHVyblZhbHVlLm5leHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gYXdhaXRJdGVyYXRvcihyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB6b25lUHJvcHMpO1xuICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKS50aGVuKHggPT4gdHJhbnMuYWN0aXZlID9cbiAgICAgICAgICAgICAgICB4XG4gICAgICAgICAgICAgICAgOiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUHJlbWF0dXJlQ29tbWl0KFwiVHJhbnNhY3Rpb24gY29tbWl0dGVkIHRvbyBlYXJseS4gU2VlIGh0dHA6Ly9iaXQubHkvMmtkY2tNblwiKSkpXG4gICAgICAgICAgICA6IHByb21pc2VGb2xsb3dlZC50aGVuKCgpID0+IHJldHVyblZhbHVlKSkudGhlbih4ID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICB0cmFucy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oKCkgPT4geCk7XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYWQoYSwgdmFsdWUsIGNvdW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaXNBcnJheShhKSA/IGEuc2xpY2UoKSA6IFthXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZShkb3duKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZG93bixcbiAgICAgICAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IGRvd24udGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSB0YWJsZTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4TG9va3VwID0ge307XG4gICAgICAgICAgICBjb25zdCBhbGxWaXJ0dWFsSW5kZXhlcyA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRkVmlydHVhbEluZGV4ZXMoa2V5UGF0aCwga2V5VGFpbCwgbG93TGV2ZWxJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVBhdGhBbGlhcyA9IGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleExpc3QgPSAoaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSA9IGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gfHwgW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IGtleVBhdGggPT0gbnVsbCA/IDAgOiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyAxIDoga2V5UGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNWaXJ0dWFsID0ga2V5VGFpbCA+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbEluZGV4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5sb3dMZXZlbEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc1ZpcnR1YWwsXG4gICAgICAgICAgICAgICAgICAgIGtleVRhaWwsXG4gICAgICAgICAgICAgICAgICAgIGtleUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpLFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWU6ICFpc1ZpcnR1YWwgJiYgbG93TGV2ZWxJbmRleC51bmlxdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluZGV4TGlzdC5wdXNoKHZpcnR1YWxJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXJ0dWFsSW5kZXguaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbFZpcnR1YWxJbmRleGVzLnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleUxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbEtleVBhdGggPSBrZXlMZW5ndGggPT09IDIgP1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aFswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyh2aXJ0dWFsS2V5UGF0aCwga2V5VGFpbCArIDEsIGxvd0xldmVsSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleExpc3Quc29ydCgoYSwgYikgPT4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleSA9IGFkZFZpcnR1YWxJbmRleGVzKHNjaGVtYS5wcmltYXJ5S2V5LmtleVBhdGgsIDAsIHNjaGVtYS5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgIGluZGV4TG9va3VwW1wiOmlkXCJdID0gW3ByaW1hcnlLZXldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBzY2hlbWEuaW5kZXhlcykge1xuICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKGluZGV4LmtleVBhdGgsIDAsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRCZXN0SW5kZXgoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGluZGV4TG9va3VwW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSYW5nZShyYW5nZSwga2V5VGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHJhbmdlLnR5cGUgPT09IDEgID9cbiAgICAgICAgICAgICAgICAgICAgICAgIDIgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiBwYWQocmFuZ2UubG93ZXIsIHJhbmdlLmxvd2VyT3BlbiA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCksXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXI6IHBhZChyYW5nZS51cHBlciwgcmFuZ2UudXBwZXJPcGVuID8gZG93bi5NSU5fS0VZIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJPcGVuOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QocmVxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSByZXEucXVlcnkuaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LmlzVmlydHVhbCA/IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVxLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdHJhbnNsYXRlUmFuZ2UocmVxLnF1ZXJ5LnJhbmdlLCBpbmRleC5rZXlUYWlsKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSA6IHJlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBhbGxWaXJ0dWFsSW5kZXhlcyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IGZpbmRCZXN0SW5kZXhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50KHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuY291bnQodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5KHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUucXVlcnkodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW5DdXJzb3IocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5VGFpbCwgaXNWaXJ0dWFsLCBrZXlMZW5ndGggfSA9IHJlcS5xdWVyeS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZpcnR1YWwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcihyZXEpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2NvbnRpbnVlKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHBhZChrZXksIHJlcS5yZXZlcnNlID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudW5pcXVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS5yZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkb3duLk1JTl9LRVlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbEN1cnNvciA9IE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6IHsgdmFsdWU6IF9jb250aW51ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlUHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZShrZXksIHByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkocGFkKGtleSwgZG93bi5NQVhfS0VZLCBrZXlUYWlsKSwgcHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlMZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LnNsaWNlKDAsIGtleUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsQ3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHRyYW5zbGF0ZVJlcXVlc3QocmVxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGN1cnNvciA9PiBjdXJzb3IgJiYgY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCB2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlID0ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIG5hbWU6IFwiVmlydHVhbEluZGV4TWlkZGxld2FyZVwiLFxuICAgIGxldmVsOiAxLFxuICAgIGNyZWF0ZTogY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZVxufTtcblxuZnVuY3Rpb24gZ2V0T2JqZWN0RGlmZihhLCBiLCBydiwgcHJmeCkge1xuICAgIHJ2ID0gcnYgfHwge307XG4gICAgcHJmeCA9IHByZnggfHwgJyc7XG4gICAga2V5cyhhKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmICghaGFzT3duKGIsIHByb3ApKSB7XG4gICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXAgPSBhW3Byb3BdLCBicCA9IGJbcHJvcF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFwID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYnAgPT09ICdvYmplY3QnICYmIGFwICYmIGJwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBicFR5cGVOYW1lID0gdG9TdHJpbmdUYWcoYnApO1xuICAgICAgICAgICAgICAgIGlmIChhcFR5cGVOYW1lICE9PSBicFR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE9iamVjdERpZmYoYXAsIGJwLCBydiwgcHJmeCArIHByb3AgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApIHtcbiAgICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApXG4gICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGtleXMoYikuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAoIWhhc093bihhLCBwcm9wKSkge1xuICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBydjtcbn1cblxuZnVuY3Rpb24gZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpIHtcbiAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKVxuICAgICAgICByZXR1cm4gcmVxLmtleXM7XG4gICAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSk7XG59XG5cbmNvbnN0IGhvb2tzTWlkZGxld2FyZSA9IHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBuYW1lOiBcIkhvb2tzTWlkZGxld2FyZVwiLFxuICAgIGxldmVsOiAyLFxuICAgIGNyZWF0ZTogKGRvd25Db3JlKSA9PiAoe1xuICAgICAgICAuLi5kb3duQ29yZSxcbiAgICAgICAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duVGFibGUgPSBkb3duQ29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5IH0gPSBkb3duVGFibGUuc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgdGFibGVNaWRkbGV3YXJlID0ge1xuICAgICAgICAgICAgICAgIC4uLmRvd25UYWJsZSxcbiAgICAgICAgICAgICAgICBtdXRhdGUocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRpbmcsIGNyZWF0aW5nLCB1cGRhdGluZyB9ID0gZHhUcmFucy50YWJsZSh0YWJsZU5hbWUpLmhvb2s7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVxLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHV0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wICYmIHVwZGF0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCkgPT4gYWRkUHV0T3JEZWxldGUocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGRlbGV0ZVJhbmdlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSByZXEua2V5cyB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gcmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAuLi5yZXEsIGtleXMgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAuLi5yZXEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gJ2RlbGV0ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyA9IFsuLi5yZXEudmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEua2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5cyA9IFsuLi5yZXEua2V5c107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhpc3RpbmdWYWx1ZXMoZG93blRhYmxlLCByZXEsIGtleXMpLnRoZW4oZXhpc3RpbmdWYWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRzID0ga2V5cy5tYXAoKGtleSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gZXhpc3RpbmdWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVxLnR5cGUgPT09ICdhZGQnIHx8IGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHJpbWFyeUtleSA9IGNyZWF0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgcmVxLnZhbHVlc1tpXSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IG51bGwgJiYgZ2VuZXJhdGVkUHJpbWFyeUtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2VuZXJhdGVkUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByaW1hcnlLZXkub3V0Ym91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcS52YWx1ZXNbaV0sIHByaW1hcnlLZXkua2V5UGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmplY3REaWZmID0gZ2V0T2JqZWN0RGlmZihleGlzdGluZ1ZhbHVlLCByZXEudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxDaGFuZ2VzID0gdXBkYXRpbmcuZmlyZS5jYWxsKGN0eCwgb2JqZWN0RGlmZiwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFZhbHVlID0gcmVxLnZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQ2hhbmdlcykuZm9yRWFjaChrZXlQYXRoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihyZXF1ZXN0ZWRWYWx1ZSwga2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZhbHVlW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxdWVzdGVkVmFsdWUsIGtleVBhdGgsIGFkZGl0aW9uYWxDaGFuZ2VzW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKS50aGVuKCh7IGZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNvbnRleHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbmVycm9yICYmIGN0eC5vbmVycm9yKGZhaWx1cmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbnN1Y2Nlc3MgJiYgY3R4Lm9uc3VjY2VzcyhyZXEudHlwZSA9PT0gJ3B1dCcgJiYgZXhpc3RpbmdWYWx1ZXNbaV0gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzW2ldIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXMsIHJlc3VsdHMsIG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGN0eCA9PiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVsZXRlUmFuZ2UocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHJlcS50cmFucywgcmVxLnJhbmdlLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVsZXRlTmV4dENodW5rKHRyYW5zLCByYW5nZSwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUucXVlcnkoeyB0cmFucywgdmFsdWVzOiBmYWxzZSwgcXVlcnk6IHsgaW5kZXg6IHByaW1hcnlLZXksIHJhbmdlIH0sIGxpbWl0IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHsgcmVzdWx0IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUHV0T3JEZWxldGUoeyB0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFucyB9KS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzOiBbXSwgbnVtRmFpbHVyZXM6IDAsIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayh0cmFucywgeyAuLi5yYW5nZSwgbG93ZXI6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxvd2VyT3BlbjogdHJ1ZSB9LCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0YWJsZU1pZGRsZXdhcmU7XG4gICAgICAgIH0sXG4gICAgfSlcbn07XG5mdW5jdGlvbiBnZXRFeGlzdGluZ1ZhbHVlcyh0YWJsZSwgcmVxLCBlZmZlY3RpdmVLZXlzKSB7XG4gICAgcmV0dXJuIHJlcS50eXBlID09PSBcImFkZFwiXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICAgICAgICA6IHRhYmxlLmdldE1hbnkoeyB0cmFuczogcmVxLnRyYW5zLCBrZXlzOiBlZmZlY3RpdmVLZXlzLCBjYWNoZTogXCJpbW11dGFibGVcIiB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgY2FjaGUsIGNsb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFjYWNoZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoY2FjaGUua2V5cy5sZW5ndGggPCBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY2FjaGUua2V5cy5sZW5ndGggJiYgaiA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjbXAoY2FjaGUua2V5c1tpXSwga2V5c1tqXSkgIT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZSA/IGRlZXBDbG9uZShjYWNoZS52YWx1ZXNbaV0pIDogY2FjaGUudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY29uc3QgY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUgPSB7XG4gICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgbGV2ZWw6IC0xLFxuICAgIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhYmxlOiAodGFibGVOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGdldE1hbnk6IChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKHJlcS5rZXlzLCByZXEudHJhbnNbXCJfY2FjaGVcIl0sIHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoY2FjaGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiByZXEua2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByZXEuY2FjaGUgPT09IFwiY2xvbmVcIiA/IGRlZXBDbG9uZShyZXMpIDogcmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBpc0VtcHR5UmFuZ2Uobm9kZSkge1xuICAgIHJldHVybiAhKFwiZnJvbVwiIGluIG5vZGUpO1xufVxuY29uc3QgUmFuZ2VTZXQgPSBmdW5jdGlvbiAoZnJvbU9yVHJlZSwgdG8pIHtcbiAgICBpZiAodGhpcykge1xuICAgICAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHsgZDogMSwgZnJvbTogZnJvbU9yVHJlZSwgdG86IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdG8gOiBmcm9tT3JUcmVlIH0gOiB7IGQ6IDAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBydiA9IG5ldyBSYW5nZVNldCgpO1xuICAgICAgICBpZiAoZnJvbU9yVHJlZSAmJiAoXCJkXCIgaW4gZnJvbU9yVHJlZSkpIHtcbiAgICAgICAgICAgIGV4dGVuZChydiwgZnJvbU9yVHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbn07XG5wcm9wcyhSYW5nZVNldC5wcm90b3R5cGUsIHtcbiAgICBhZGQocmFuZ2VTZXQpIHtcbiAgICAgICAgbWVyZ2VSYW5nZXModGhpcywgcmFuZ2VTZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEtleShrZXkpIHtcbiAgICAgICAgYWRkUmFuZ2UodGhpcywga2V5LCBrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEtleXMoa2V5cykge1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZFJhbmdlKHRoaXMsIGtleSwga2V5KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgW2l0ZXJhdG9yU3ltYm9sXSgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcyk7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKSB7XG4gICAgY29uc3QgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gICAgaWYgKGlzTmFOKGRpZmYpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRpZmYgPiAwKVxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCk7XG4gICAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKVxuICAgICAgICByZXR1cm4gZXh0ZW5kKHRhcmdldCwgeyBmcm9tLCB0bywgZDogMSB9KTtcbiAgICBjb25zdCBsZWZ0ID0gdGFyZ2V0Lmw7XG4gICAgY29uc3QgcmlnaHQgPSB0YXJnZXQucjtcbiAgICBpZiAoY21wKHRvLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgICAgIGxlZnRcbiAgICAgICAgICAgID8gYWRkUmFuZ2UobGVmdCwgZnJvbSwgdG8pXG4gICAgICAgICAgICA6ICh0YXJnZXQubCA9IHsgZnJvbSwgdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGNtcChmcm9tLCB0YXJnZXQudG8pID4gMCkge1xuICAgICAgICByaWdodFxuICAgICAgICAgICAgPyBhZGRSYW5nZShyaWdodCwgZnJvbSwgdG8pXG4gICAgICAgICAgICA6ICh0YXJnZXQuciA9IHsgZnJvbSwgdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGNtcChmcm9tLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgICAgIHRhcmdldC5mcm9tID0gZnJvbTtcbiAgICAgICAgdGFyZ2V0LmwgPSBudWxsO1xuICAgICAgICB0YXJnZXQuZCA9IHJpZ2h0ID8gcmlnaHQuZCArIDEgOiAxO1xuICAgIH1cbiAgICBpZiAoY21wKHRvLCB0YXJnZXQudG8pID4gMCkge1xuICAgICAgICB0YXJnZXQudG8gPSB0bztcbiAgICAgICAgdGFyZ2V0LnIgPSBudWxsO1xuICAgICAgICB0YXJnZXQuZCA9IHRhcmdldC5sID8gdGFyZ2V0LmwuZCArIDEgOiAxO1xuICAgIH1cbiAgICBjb25zdCByaWdodFdhc0N1dE9mZiA9ICF0YXJnZXQucjtcbiAgICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0LCBsZWZ0KTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0ICYmIHJpZ2h0V2FzQ3V0T2ZmKSB7XG4gICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgcmlnaHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHRhcmdldCwgbmV3U2V0KSB7XG4gICAgZnVuY3Rpb24gX2FkZFJhbmdlU2V0KHRhcmdldCwgeyBmcm9tLCB0bywgbCwgciB9KSB7XG4gICAgICAgIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAobClcbiAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgICAgICBpZiAocilcbiAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRW1wdHlSYW5nZShuZXdTZXQpKVxuICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBuZXdTZXQpO1xufVxuZnVuY3Rpb24gcmFuZ2VzT3ZlcmxhcChyYW5nZVNldDEsIHJhbmdlU2V0Mikge1xuICAgIGNvbnN0IGkxID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDIpO1xuICAgIGxldCBuZXh0UmVzdWx0MSA9IGkxLm5leHQoKTtcbiAgICBpZiAobmV4dFJlc3VsdDEuZG9uZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhID0gbmV4dFJlc3VsdDEudmFsdWU7XG4gICAgY29uc3QgaTIgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0MSk7XG4gICAgbGV0IG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pO1xuICAgIGxldCBiID0gbmV4dFJlc3VsdDIudmFsdWU7XG4gICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICAgIGlmIChjbXAoYi5mcm9tLCBhLnRvKSA8PSAwICYmIGNtcChiLnRvLCBhLmZyb20pID49IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY21wKGEuZnJvbSwgYi5mcm9tKSA8IDBcbiAgICAgICAgICAgID8gKGEgPSAobmV4dFJlc3VsdDEgPSBpMS5uZXh0KGIuZnJvbSkpLnZhbHVlKVxuICAgICAgICAgICAgOiAoYiA9IChuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKSkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRSYW5nZVNldEl0ZXJhdG9yKG5vZGUpIHtcbiAgICBsZXQgc3RhdGUgPSBpc0VtcHR5UmFuZ2Uobm9kZSkgPyBudWxsIDogeyBzOiAwLCBuOiBub2RlIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVByb3ZpZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB3aGlsZSAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sICYmIGNtcChrZXksIHN0YXRlLm4uZnJvbSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5UHJvdmlkZWQgfHwgY21wKGtleSwgc3RhdGUubi50bykgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc3RhdGUubiwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm4ucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmViYWxhbmNlKHRhcmdldCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGlmZiA9ICgoKF9hID0gdGFyZ2V0LnIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kKSB8fCAwKSAtICgoKF9iID0gdGFyZ2V0LmwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kKSB8fCAwKTtcbiAgICBjb25zdCByID0gZGlmZiA+IDEgPyBcInJcIiA6IGRpZmYgPCAtMSA/IFwibFwiIDogXCJcIjtcbiAgICBpZiAocikge1xuICAgICAgICBjb25zdCBsID0gciA9PT0gXCJyXCIgPyBcImxcIiA6IFwiclwiO1xuICAgICAgICBjb25zdCByb290Q2xvbmUgPSB7IC4uLnRhcmdldCB9O1xuICAgICAgICBjb25zdCBvbGRSb290UmlnaHQgPSB0YXJnZXRbcl07XG4gICAgICAgIHRhcmdldC5mcm9tID0gb2xkUm9vdFJpZ2h0LmZyb207XG4gICAgICAgIHRhcmdldC50byA9IG9sZFJvb3RSaWdodC50bztcbiAgICAgICAgdGFyZ2V0W3JdID0gb2xkUm9vdFJpZ2h0W3JdO1xuICAgICAgICByb290Q2xvbmVbcl0gPSBvbGRSb290UmlnaHRbbF07XG4gICAgICAgIHRhcmdldFtsXSA9IHJvb3RDbG9uZTtcbiAgICAgICAgcm9vdENsb25lLmQgPSBjb21wdXRlRGVwdGgocm9vdENsb25lKTtcbiAgICB9XG4gICAgdGFyZ2V0LmQgPSBjb21wdXRlRGVwdGgodGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEZXB0aCh7IHIsIGwgfSkge1xuICAgIHJldHVybiAociA/IChsID8gTWF0aC5tYXgoci5kLCBsLmQpIDogci5kKSA6IGwgPyBsLmQgOiAwKSArIDE7XG59XG5cbmNvbnN0IG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlID0ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIGxldmVsOiAwLFxuICAgIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICAgICAgY29uc3QgZGJOYW1lID0gY29yZS5zY2hlbWEubmFtZTtcbiAgICAgICAgY29uc3QgRlVMTF9SQU5HRSA9IG5ldyBSYW5nZVNldChjb3JlLk1JTl9LRVksIGNvcmUuTUFYX0tFWSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb3JlLFxuICAgICAgICAgICAgdGFibGU6ICh0YWJsZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gdGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5IH0gPSBzY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBleHRyYWN0S2V5LCBvdXRib3VuZCB9ID0gcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUNsb25lID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlOiAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFucyA9IHJlcS50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0ZWRQYXJ0cyA9IHRyYW5zLm11dGF0ZWRQYXJ0cyB8fCAodHJhbnMubXV0YXRlZFBhcnRzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2VTZXQgPSAoaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtdXRhdGVkUGFydHNbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG11dGF0ZWRQYXJ0c1twYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcmVxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFtrZXlzLCBuZXdPYmpzXSA9IHJlcS50eXBlID09PSBcImRlbGV0ZVJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEucmFuZ2VdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudHlwZSA9PT0gXCJkZWxldGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEua2V5c11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudmFsdWVzLmxlbmd0aCA8IDUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtbXSwgcmVxLnZhbHVlc11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRDYWNoZSA9IHJlcS50cmFuc1tcIl9jYWNoZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gXCJkZWxldGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMgPSByZXMucmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmpzID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgb2xkQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZE9ianMgJiYgdHlwZSAhPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE9ianMgfHwgbmV3T2Jqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbToga2V5cy5sb3dlciwgdG86IGtleXMudXBwZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkKEZVTExfUkFOR0UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2UgPSAoeyBxdWVyeTogeyBpbmRleCwgcmFuZ2UgfSwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmFuZ2VTZXQoKF9hID0gcmFuZ2UubG93ZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvcmUuTUlOX0tFWSwgKF9iID0gcmFuZ2UudXBwZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvcmUuTUFYX0tFWSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkU3Vic2NyaWJlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKHJlcSkgPT4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldChyZXEua2V5KV0sXG4gICAgICAgICAgICAgICAgICAgIGdldE1hbnk6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKHJlcS5rZXlzKV0sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGdldFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuQ3Vyc29yOiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGtleXMocmVhZFN1YnNjcmliZXJzKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xvbmVbbWV0aG9kXSA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3Vic2NyIH0gPSBQU0Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2VTZXQgPSAoaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfS8ke2luZGV4TmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN1YnNjcltwYXJ0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN1YnNjcltwYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbcXVlcmllZEluZGV4LCBxdWVyaWVkUmFuZ2VzXSA9IHJlYWRTdWJzY3JpYmVyc1ttZXRob2RdKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQocXVlcmllZEluZGV4Lm5hbWUgfHwgXCJcIikuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNvdW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzUHJvbWlzZSA9IG1ldGhvZCA9PT0gXCJxdWVyeVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicXVlcnlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQgJiYgcmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlLnRoZW4oKHsgcmVzdWx0OiByZXN1bHRpbmdLZXlzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMocmVzdWx0aW5nS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBLZXlzID0gcmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXMucmVzdWx0Lm1hcChleHRyYWN0S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXMucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09IFwib3BlbkN1cnNvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FudFZhbHVlcyA9IHJlcS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5KGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwa2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5KHBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YW50VmFsdWVzICYmIHBrUmFuZ2VTZXQuYWRkS2V5KGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVDbG9uZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5mdW5jdGlvbiB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKSB7XG4gICAgZnVuY3Rpb24gYWRkQWZmZWN0ZWRJbmRleChpeCkge1xuICAgICAgICBjb25zdCByYW5nZVNldCA9IGdldFJhbmdlU2V0KGl4Lm5hbWUgfHwgXCJcIik7XG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBpeC5leHRyYWN0S2V5KG9iaikgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZEtleU9yS2V5cyA9IChrZXkpID0+IGl4Lm11bHRpRW50cnkgJiYgaXNBcnJheShrZXkpXG4gICAgICAgICAgICA/IGtleS5mb3JFYWNoKGtleSA9PiByYW5nZVNldC5hZGRLZXkoa2V5KSlcbiAgICAgICAgICAgIDogcmFuZ2VTZXQuYWRkS2V5KGtleSk7XG4gICAgICAgIChvbGRPYmpzIHx8IG5ld09ianMpLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEtleSA9IG9sZE9ianMgJiYgZXh0cmFjdEtleShvbGRPYmpzW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0tleSA9IG5ld09ianMgJiYgZXh0cmFjdEtleShuZXdPYmpzW2ldKTtcbiAgICAgICAgICAgIGlmIChjbXAob2xkS2V5LCBuZXdLZXkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMob2xkS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3S2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleU9yS2V5cyhuZXdLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChhZGRBZmZlY3RlZEluZGV4KTtcbn1cblxuY2xhc3MgRGV4aWUkMSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlcyA9IHt9O1xuICAgICAgICB0aGlzLnZlcm5vID0gMDtcbiAgICAgICAgY29uc3QgZGVwcyA9IERleGllJDEuZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFkZG9uczogRGV4aWUkMS5hZGRvbnMsXG4gICAgICAgICAgICBhdXRvT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsXG4gICAgICAgICAgICBJREJLZXlSYW5nZTogZGVwcy5JREJLZXlSYW5nZSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVwcyA9IHtcbiAgICAgICAgICAgIGluZGV4ZWREQjogb3B0aW9ucy5pbmRleGVkREIsXG4gICAgICAgICAgICBJREJLZXlSYW5nZTogb3B0aW9ucy5JREJLZXlSYW5nZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGFkZG9ucywgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2RiU2NoZW1hID0ge307XG4gICAgICAgIHRoaXMuX3ZlcnNpb25zID0gW107XG4gICAgICAgIHRoaXMuX3N0b3JlTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxsVGFibGVzID0ge307XG4gICAgICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuICAgICAgICB0aGlzLl9ub3ZpcCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgZGJPcGVuRXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc0JlaW5nT3BlbmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG9uUmVhZHlCZWluZ0ZpcmVkOiBudWxsLFxuICAgICAgICAgICAgb3BlbkNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGRiUmVhZHlSZXNvbHZlOiBub3AsXG4gICAgICAgICAgICBkYlJlYWR5UHJvbWlzZTogbnVsbCxcbiAgICAgICAgICAgIGNhbmNlbE9wZW46IG5vcCxcbiAgICAgICAgICAgIG9wZW5DYW5jZWxsZXI6IG51bGwsXG4gICAgICAgICAgICBhdXRvU2NoZW1hOiB0cnVlLFxuICAgICAgICAgICAgUFIxMzk4X21heExvb3A6IDNcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgRGV4aWVQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJwb3B1bGF0ZVwiLCBcImJsb2NrZWRcIiwgXCJ2ZXJzaW9uY2hhbmdlXCIsIFwiY2xvc2VcIiwgeyByZWFkeTogW3Byb21pc2FibGVDaGFpbiwgbm9wXSB9KTtcbiAgICAgICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgc3Vic2NyaWJlID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoc3Vic2NyaWJlciwgYlN0aWNreSkgPT4ge1xuICAgICAgICAgICAgICAgIERleGllJDEudmlwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5kYk9wZW5FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5vbi5yZWFkeS51bnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIub24ucmVhZHkudW5zdWJzY3JpYmUodW5zdWJzY3JpYmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5Db2xsZWN0aW9uID0gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLlRhYmxlID0gY3JlYXRlVGFibGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuVmVyc2lvbiA9IGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5XaGVyZUNsYXVzZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmIChldi5uZXdWZXJzaW9uID4gMClcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byB1cGdyYWRlIGRhdGFiYXNlICcke3RoaXMubmFtZX0nLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIHVwZ3JhZGUuYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gZGVsZXRlIGRhdGFiYXNlICcke3RoaXMubmFtZX0nLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIGRlbGV0ZSByZXF1ZXN0LmApO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImJsb2NrZWRcIiwgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGV4aWUuZGVsZXRlKCcke3RoaXMubmFtZX0nKSB3YXMgYmxvY2tlZGApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXBncmFkZSAnJHt0aGlzLm5hbWV9JyBibG9ja2VkIGJ5IG90aGVyIGNvbm5lY3Rpb24gaG9sZGluZyB2ZXJzaW9uICR7ZXYub2xkVmVyc2lvbiAvIDEwfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWF4S2V5ID0gZ2V0TWF4S2V5KG9wdGlvbnMuSURCS2V5UmFuZ2UpO1xuICAgICAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IChtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pID0+IG5ldyB0aGlzLlRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCB0aGlzLl9vcHRpb25zLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZXYgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbihcImJsb2NrZWRcIikuZmlyZShldik7XG4gICAgICAgICAgICBjb25uZWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLm5hbWUgPT09IHRoaXMubmFtZSAmJiBjICE9PSB0aGlzICYmICFjLl9zdGF0ZS52Y0ZpcmVkKVxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXNlKHZpcnR1YWxJbmRleE1pZGRsZXdhcmUpO1xuICAgICAgICB0aGlzLnVzZShob29rc01pZGRsZXdhcmUpO1xuICAgICAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG4gICAgICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcbiAgICAgICAgdGhpcy52aXAgPSBPYmplY3QuY3JlYXRlKHRoaXMsIHsgX3ZpcDogeyB2YWx1ZTogdHJ1ZSB9IH0pO1xuICAgICAgICBhZGRvbnMuZm9yRWFjaChhZGRvbiA9PiBhZGRvbih0aGlzKSk7XG4gICAgfVxuICAgIHZlcnNpb24odmVyc2lvbk51bWJlcikge1xuICAgICAgICBpZiAoaXNOYU4odmVyc2lvbk51bWJlcikgfHwgdmVyc2lvbk51bWJlciA8IDAuMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoYEdpdmVuIHZlcnNpb24gaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyYCk7XG4gICAgICAgIHZlcnNpb25OdW1iZXIgPSBNYXRoLnJvdW5kKHZlcnNpb25OdW1iZXIgKiAxMCkgLyAxMDtcbiAgICAgICAgaWYgKHRoaXMuaWRiZGIgfHwgdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkNhbm5vdCBhZGQgdmVyc2lvbiB3aGVuIGRhdGFiYXNlIGlzIG9wZW5cIik7XG4gICAgICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSB0aGlzLl92ZXJzaW9ucztcbiAgICAgICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcih2ID0+IHYuX2NmZy52ZXJzaW9uID09PSB2ZXJzaW9uTnVtYmVyKVswXTtcbiAgICAgICAgaWYgKHZlcnNpb25JbnN0YW5jZSlcbiAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgICAgIHZlcnNpb25JbnN0YW5jZSA9IG5ldyB0aGlzLlZlcnNpb24odmVyc2lvbk51bWJlcik7XG4gICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbkluc3RhbmNlKTtcbiAgICAgICAgdmVyc2lvbnMuc29ydChsb3dlclZlcnNpb25GaXJzdCk7XG4gICAgICAgIHZlcnNpb25JbnN0YW5jZS5zdG9yZXMoe30pO1xuICAgICAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgfVxuICAgIF93aGVuUmVhZHkoZm4pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkYmRiICYmICh0aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUgfHwgUFNELmxldFRocm91Z2ggfHwgdGhpcy5fdmlwKSkgPyBmbigpIDogbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCh0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmF1dG9PcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKS5jYXRjaChub3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKGZuKTtcbiAgICB9XG4gICAgdXNlKHsgc3RhY2ssIGNyZWF0ZSwgbGV2ZWwsIG5hbWUgfSkge1xuICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgIHRoaXMudW51c2UoeyBzdGFjaywgbmFtZSB9KTtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcbiAgICAgICAgbWlkZGxld2FyZXMucHVzaCh7IHN0YWNrLCBjcmVhdGUsIGxldmVsOiBsZXZlbCA9PSBudWxsID8gMTAgOiBsZXZlbCwgbmFtZSB9KTtcbiAgICAgICAgbWlkZGxld2FyZXMuc29ydCgoYSwgYikgPT4gYS5sZXZlbCAtIGIubGV2ZWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdW51c2UoeyBzdGFjaywgbmFtZSwgY3JlYXRlIH0pIHtcbiAgICAgICAgaWYgKHN0YWNrICYmIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSkge1xuICAgICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdLmZpbHRlcihtdyA9PiBjcmVhdGUgPyBtdy5jcmVhdGUgIT09IGNyZWF0ZSA6XG4gICAgICAgICAgICAgICAgbmFtZSA/IG13Lm5hbWUgIT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wZW4oKSB7XG4gICAgICAgIHJldHVybiBkZXhpZU9wZW4odGhpcyk7XG4gICAgfVxuICAgIF9jbG9zZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgY29uc3QgaWR4ID0gY29ubmVjdGlvbnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIGlmICh0aGlzLmlkYmRiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWRiZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHRoaXMuX25vdmlwLmlkYmRiID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IERleGllUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYXV0b09wZW4gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpO1xuICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4oc3RhdGUuZGJPcGVuRXJyb3IpO1xuICAgIH1cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIGNvbnN0IGhhc0FyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb0RlbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcSA9IHRoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQodGhpcy5fZGVwcywgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHRoaXMuX2ZpcmVPbkJsb2NrZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhc0FyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgbm90IGFsbG93ZWQgaW4gZGIuZGVsZXRlKClcIik7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZG9EZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9EZWxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJhY2tlbmREQigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGI7XG4gICAgfVxuICAgIGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGIgIT09IG51bGw7XG4gICAgfVxuICAgIGhhc0JlZW5DbG9zZWQoKSB7XG4gICAgICAgIGNvbnN0IGRiT3BlbkVycm9yID0gdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgICAgIHJldHVybiBkYk9wZW5FcnJvciAmJiAoZGJPcGVuRXJyb3IubmFtZSA9PT0gJ0RhdGFiYXNlQ2xvc2VkJyk7XG4gICAgfVxuICAgIGhhc0ZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuICAgIH1cbiAgICBkeW5hbWljYWxseU9wZW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWE7XG4gICAgfVxuICAgIGdldCB0YWJsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKHRoaXMuX2FsbFRhYmxlcykubWFwKG5hbWUgPT4gdGhpcy5fYWxsVGFibGVzW25hbWVdKTtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBleHRyYWN0VHJhbnNhY3Rpb25BcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgX3RyYW5zYWN0aW9uKG1vZGUsIHRhYmxlcywgc2NvcGVGdW5jKSB7XG4gICAgICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucztcbiAgICAgICAgaWYgKCFwYXJlbnRUcmFuc2FjdGlvbiB8fCBwYXJlbnRUcmFuc2FjdGlvbi5kYiAhPT0gdGhpcyB8fCBtb2RlLmluZGV4T2YoJyEnKSAhPT0gLTEpXG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgICAgIG1vZGUgPSBtb2RlLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnPycsICcnKTtcbiAgICAgICAgbGV0IGlkYk1vZGUsIHN0b3JlTmFtZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yZU5hbWVzID0gdGFibGVzLm1hcCh0YWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHRhYmxlIGluc3RhbmNlb2YgdGhpcy5UYWJsZSA/IHRhYmxlLm5hbWUgOiB0YWJsZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlTmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRhYmxlIGFyZ3VtZW50IHRvIERleGllLnRyYW5zYWN0aW9uKCkuIE9ubHkgVGFibGUgb3IgU3RyaW5nIGFyZSBhbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZU5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtb2RlID09IFwiclwiIHx8IG1vZGUgPT09IFJFQURPTkxZKVxuICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFET05MWTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJyd1wiIHx8IG1vZGUgPT0gUkVBRFdSSVRFKVxuICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFEV1JJVEU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uLm1vZGUgPT09IFJFQURPTkxZICYmIGlkYk1vZGUgPT09IFJFQURXUklURSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiQ2Fubm90IGVudGVyIGEgc3ViLXRyYW5zYWN0aW9uIHdpdGggUkVBRFdSSVRFIG1vZGUgd2hlbiBwYXJlbnQgdHJhbnNhY3Rpb24gaXMgUkVBRE9OTFlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbiAmJiBwYXJlbnRUcmFuc2FjdGlvbi5zdG9yZU5hbWVzLmluZGV4T2Yoc3RvcmVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJUYWJsZSBcIiArIHN0b3JlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBub3QgaW5jbHVkZWQgaW4gcGFyZW50IHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlICYmIHBhcmVudFRyYW5zYWN0aW9uICYmICFwYXJlbnRUcmFuc2FjdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShudWxsLCAoXywgcmVqZWN0KSA9PiB7IHJlamVjdChlKTsgfSkgOlxuICAgICAgICAgICAgICAgIHJlamVjdGlvbihlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRlclRyYW5zYWN0aW9uID0gZW50ZXJUcmFuc2FjdGlvblNjb3BlLmJpbmQobnVsbCwgdGhpcywgaWRiTW9kZSwgc3RvcmVOYW1lcywgcGFyZW50VHJhbnNhY3Rpb24sIHNjb3BlRnVuYyk7XG4gICAgICAgIHJldHVybiAocGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcbiAgICAgICAgICAgIFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsICgpID0+IHRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSkgOlxuICAgICAgICAgICAgICAgIHRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSk7XG4gICAgfVxuICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093bih0aGlzLl9hbGxUYWJsZXMsIHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRUYWJsZShgVGFibGUgJHt0YWJsZU5hbWV9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgIH1cbn1cblxuY29uc3Qgc3ltYm9sT2JzZXJ2YWJsZSA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJvYnNlcnZhYmxlXCIgaW4gU3ltYm9sXG4gICAgPyBTeW1ib2wub2JzZXJ2YWJsZVxuICAgIDogXCJAQG9ic2VydmFibGVcIjtcbmNsYXNzIE9ic2VydmFibGUge1xuICAgIGNvbnN0cnVjdG9yKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgfVxuICAgIHN1YnNjcmliZSh4LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZSgheCB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geyBuZXh0OiB4LCBlcnJvciwgY29tcGxldGUgfSA6IHgpO1xuICAgIH1cbiAgICBbc3ltYm9sT2JzZXJ2YWJsZV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCh0YXJnZXQsIG5ld1NldCkge1xuICAgIGtleXMobmV3U2V0KS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICBjb25zdCByYW5nZVNldCA9IHRhcmdldFtwYXJ0XSB8fCAodGFyZ2V0W3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpO1xuICAgICAgICBtZXJnZVJhbmdlcyhyYW5nZVNldCwgbmV3U2V0W3BhcnRdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBsaXZlUXVlcnkocXVlcmllcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcGVGdW5jSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihxdWVyaWVyKTtcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZShzdWJzY3IpIHtcbiAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4ZWMgPSAoKSA9PiBuZXdTY29wZShxdWVyaWVyLCB7IHN1YnNjciwgdHJhbnM6IG51bGwgfSk7XG4gICAgICAgICAgICBjb25zdCBydiA9IFBTRC50cmFuc1xuICAgICAgICAgICAgICAgID9cbiAgICAgICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIGV4ZWMpXG4gICAgICAgICAgICAgICAgOiBleGVjKCk7XG4gICAgICAgICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAgICAgICAgIHJ2LnRoZW4oZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGxldCBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRPYnMgPSB7fTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQudW5zdWJzY3JpYmUobXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBvYnNlcnZlci5zdGFydCAmJiBvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pO1xuICAgICAgICBsZXQgcXVlcnlpbmcgPSBmYWxzZSwgc3RhcnRlZExpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBzaG91bGROb3RpZnkoKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5cyhjdXJyZW50T2JzKS5zb21lKChrZXkpID0+IGFjY3VtTXV0c1trZXldICYmIHJhbmdlc092ZXJsYXAoYWNjdW1NdXRzW2tleV0sIGN1cnJlbnRPYnNba2V5XSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG11dGF0aW9uTGlzdGVuZXIgPSAocGFydHMpID0+IHtcbiAgICAgICAgICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQoYWNjdW1NdXRzLCBwYXJ0cyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRvUXVlcnkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlpbmcgfHwgY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyID0ge307XG4gICAgICAgICAgICBjb25zdCByZXQgPSBleGVjdXRlKHN1YnNjcik7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcXVlcnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T2JzID0gc3Vic2NyO1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0ICYmIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcXVlcnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9KTtcbn1cblxubGV0IGRvbURlcHM7XG50cnkge1xuICAgIGRvbURlcHMgPSB7XG4gICAgICAgIGluZGV4ZWREQjogX2dsb2JhbC5pbmRleGVkREIgfHwgX2dsb2JhbC5tb3pJbmRleGVkREIgfHwgX2dsb2JhbC53ZWJraXRJbmRleGVkREIgfHwgX2dsb2JhbC5tc0luZGV4ZWREQixcbiAgICAgICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuICAgIH07XG59XG5jYXRjaCAoZSkge1xuICAgIGRvbURlcHMgPSB7IGluZGV4ZWREQjogbnVsbCwgSURCS2V5UmFuZ2U6IG51bGwgfTtcbn1cblxuY29uc3QgRGV4aWUgPSBEZXhpZSQxO1xucHJvcHMoRGV4aWUsIHtcbiAgICAuLi5mdWxsTmFtZUV4Y2VwdGlvbnMsXG4gICAgZGVsZXRlKGRhdGFiYXNlTmFtZSkge1xuICAgICAgICBjb25zdCBkYiA9IG5ldyBEZXhpZShkYXRhYmFzZU5hbWUsIHsgYWRkb25zOiBbXSB9KTtcbiAgICAgICAgcmV0dXJuIGRiLmRlbGV0ZSgpO1xuICAgIH0sXG4gICAgZXhpc3RzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lLCB7IGFkZG9uczogW10gfSkub3BlbigpLnRoZW4oZGIgPT4ge1xuICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5jYXRjaCgnTm9TdWNoRGF0YWJhc2VFcnJvcicsICgpID0+IGZhbHNlKTtcbiAgICB9LFxuICAgIGdldERhdGFiYXNlTmFtZXMoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXREYXRhYmFzZU5hbWVzKERleGllLmRlcGVuZGVuY2llcykudGhlbihjYik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlZmluZUNsYXNzKCkge1xuICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENsYXNzO1xuICAgIH0sXG4gICAgaWdub3JlVHJhbnNhY3Rpb24oc2NvcGVGdW5jKSB7XG4gICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIHNjb3BlRnVuYykgOlxuICAgICAgICAgICAgc2NvcGVGdW5jKCk7XG4gICAgfSxcbiAgICB2aXAsXG4gICAgYXN5bmM6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3Bhd246IGZ1bmN0aW9uIChnZW5lcmF0b3JGbiwgYXJncywgdGhpeikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGl6LCBhcmdzIHx8IFtdKSk7XG4gICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGN1cnJlbnRUcmFuc2FjdGlvbjoge1xuICAgICAgICBnZXQ6ICgpID0+IFBTRC50cmFucyB8fCBudWxsXG4gICAgfSxcbiAgICB3YWl0Rm9yOiBmdW5jdGlvbiAocHJvbWlzZU9yRnVuY3Rpb24sIG9wdGlvbmFsVGltZW91dCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUodHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKHByb21pc2VPckZ1bmN0aW9uKSA6XG4gICAgICAgICAgICBwcm9taXNlT3JGdW5jdGlvbilcbiAgICAgICAgICAgIC50aW1lb3V0KG9wdGlvbmFsVGltZW91dCB8fCA2MDAwMCk7XG4gICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgICAgICAgUFNELnRyYW5zLndhaXRGb3IocHJvbWlzZSkgOlxuICAgICAgICAgICAgcHJvbWlzZTtcbiAgICB9LFxuICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICBkZWJ1Zzoge1xuICAgICAgICBnZXQ6ICgpID0+IGRlYnVnLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldERlYnVnKHZhbHVlLCB2YWx1ZSA9PT0gJ2RleGllJyA/ICgpID0+IHRydWUgOiBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXJpdmU6IGRlcml2ZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgb3ZlcnJpZGU6IG92ZXJyaWRlLFxuICAgIEV2ZW50czogRXZlbnRzLFxuICAgIG9uOiBnbG9iYWxFdmVudHMsXG4gICAgbGl2ZVF1ZXJ5LFxuICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQsXG4gICAgZ2V0QnlLZXlQYXRoOiBnZXRCeUtleVBhdGgsXG4gICAgc2V0QnlLZXlQYXRoOiBzZXRCeUtleVBhdGgsXG4gICAgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsXG4gICAgc2hhbGxvd0Nsb25lOiBzaGFsbG93Q2xvbmUsXG4gICAgZGVlcENsb25lOiBkZWVwQ2xvbmUsXG4gICAgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZixcbiAgICBjbXAsXG4gICAgYXNhcDogYXNhcCQxLFxuICAgIG1pbktleTogbWluS2V5LFxuICAgIGFkZG9uczogW10sXG4gICAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zLFxuICAgIGVycm5hbWVzOiBlcnJuYW1lcyxcbiAgICBkZXBlbmRlbmNpZXM6IGRvbURlcHMsXG4gICAgc2VtVmVyOiBERVhJRV9WRVJTSU9OLFxuICAgIHZlcnNpb246IERFWElFX1ZFUlNJT04uc3BsaXQoJy4nKVxuICAgICAgICAubWFwKG4gPT4gcGFyc2VJbnQobikpXG4gICAgICAgIC5yZWR1Y2UoKHAsIGMsIGkpID0+IHAgKyAoYyAvIE1hdGgucG93KDEwLCBpICogMikpKSxcbn0pO1xuRGV4aWUubWF4S2V5ID0gZ2V0TWF4S2V5KERleGllLmRlcGVuZGVuY2llcy5JREJLZXlSYW5nZSk7XG5cbmlmICh0eXBlb2YgZGlzcGF0Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCB1cGRhdGVkUGFydHMgPT4ge1xuICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICAgICAgaWYgKGlzSUVPckVkZ2UpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHRydWUsIHRydWUsIHVwZGF0ZWRQYXJ0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB1cGRhdGVkUGFydHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUxvY2FsbHkodXBkYXRlUGFydHMpIHtcbiAgICBsZXQgd2FzTWUgPSBwcm9wYWdhdGluZ0xvY2FsbHk7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUodXBkYXRlUGFydHMpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gd2FzTWU7XG4gICAgfVxufVxubGV0IHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuXG5pZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpO1xuICAgIGlmICh0eXBlb2YgYmMudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYmMudW5yZWYoKTtcbiAgICB9XG4gICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCAoY2hhbmdlZFBhcnRzKSA9PiB7XG4gICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgYmMub25tZXNzYWdlID0gKGV2KSA9PiB7XG4gICAgICAgIGlmIChldi5kYXRhKVxuICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseShldi5kYXRhKTtcbiAgICB9O1xufVxuZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCAoY2hhbmdlZFBhcnRzKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWc6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUGFydHMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmWydjbGllbnRzJ10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5zZWxmWydjbGllbnRzJ10ubWF0Y2hBbGwoeyBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlIH0pXS5mb3JFYWNoKChjbGllbnQpID0+IGNsaWVudC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUGFydHMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseShkYXRhLmNoYW5nZWRQYXJ0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzd0NvbnRhaW5lciA9IHNlbGYuZG9jdW1lbnQgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXI7XG4gICAgaWYgKHN3Q29udGFpbmVyKSB7XG4gICAgICAgIHN3Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBwcm9wYWdhdGVNZXNzYWdlTG9jYWxseSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkoeyBkYXRhIH0pIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSkge1xuICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRhdGEuY2hhbmdlZFBhcnRzKTtcbiAgICB9XG59XG5cbkRleGllUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcbnNldERlYnVnKGRlYnVnLCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuXG5leHBvcnQgeyBEZXhpZSQxIGFzIERleGllLCBSYW5nZVNldCwgRGV4aWUkMSBhcyBkZWZhdWx0LCBsaXZlUXVlcnksIG1lcmdlUmFuZ2VzLCByYW5nZXNPdmVybGFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXhpZS5tanMubWFwXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsImltcG9ydCAnLi9tYWluLmNzcyc7XG5cbmltcG9ydCBDMVRhYmxlIGZyb20gJy4vY29tcG9uZW50cy9jMS10YWJsZSc7XG5pbXBvcnQgQzJOYXYgZnJvbSAnLi9jb21wb25lbnRzL2MyLW5hdic7XG5pbXBvcnQgTDFBcHAgZnJvbSAnLi9jb21wb25lbnRzL2wxLWFwcCc7XG5pbXBvcnQgTDJNYWluIGZyb20gJy4vY29tcG9uZW50cy9sMi1tYWluJztcbmltcG9ydCBNMFJhY2VyIGZyb20gJy4vY29tcG9uZW50cy9tMC1yYWNlcic7XG5pbXBvcnQgTTFEYXNoYm9hcmQgZnJvbSAnLi9jb21wb25lbnRzL20xLWRhc2hib2FyZCc7XG5pbXBvcnQgTTJSYWNlIGZyb20gJy4vY29tcG9uZW50cy9tMi1yYWNlJztcbmltcG9ydCBNM1J1bm5lcnMgZnJvbSAnLi9jb21wb25lbnRzL20zLXJ1bm5lcnMnO1xuaW1wb3J0IHsgZ2V0RXZlbnRTZXJ2aWNlIH0gZnJvbSAnLi9saWJzL2V2ZW50LXNlcnZpY2UnO1xuaW1wb3J0IE00U2NvcmUgZnJvbSAnLi9jb21wb25lbnRzL200LXNjb3JlJztcblxuKGFzeW5jICgpID0+IHtcbiAgICAvLyBsYXlvdXRcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2wxLWFwcCcsIEwxQXBwKTtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2wyLW1haW4nLCBMMk1haW4pO1xuICAgIC8vIG1haW4gY29tcG9uZW50c1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbTAtcmFjZXInLCBNMFJhY2VyKTtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ20xLWRhc2hib2FyZCcsIE0xRGFzaGJvYXJkKTtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ20yLXJhY2UnLCBNMlJhY2UpO1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbTMtcnVubmVycycsIE0zUnVubmVycyk7XG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdtNC1zY29yZScsIE00U2NvcmUpO1xuICAgIC8vIG90aGVyc1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYzEtdGFibGUnLCBDMVRhYmxlKTtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ2MyLW5hdicsIEMyTmF2KTtcblxuICAgIC8vc3RhcnQgZXZlbnQgc2VydmljZVxuICAgIGdldEV2ZW50U2VydmljZSgpLnN0YXJ0KCk7XG59KSgpO1xuIl0sIm5hbWVzIjpbImJhc2UiLCJVdGlscyIsInJ1bnRpbWUiLCJjcmVhdGUiLCJoYiIsIkhhbmRsZWJhcnNFbnZpcm9ubWVudCIsImV4dGVuZCIsIlNhZmVTdHJpbmciLCJFeGNlcHRpb24iLCJlc2NhcGVFeHByZXNzaW9uIiwiVk0iLCJ0ZW1wbGF0ZSIsInNwZWMiLCJpbnN0IiwiX2hhbmRsZWJhcnNOb0NvbmZsaWN0MiIsIlZFUlNJT04iLCJDT01QSUxFUl9SRVZJU0lPTiIsIkxBU1RfQ09NUEFUSUJMRV9DT01QSUxFUl9SRVZJU0lPTiIsIlJFVklTSU9OX0NIQU5HRVMiLCJvYmplY3RUeXBlIiwiaGVscGVycyIsInBhcnRpYWxzIiwiZGVjb3JhdG9ycyIsIl9oZWxwZXJzIiwiX2RlY29yYXRvcnMiLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsImxvZ2dlciIsImxvZyIsIl9sb2dnZXIyIiwicmVnaXN0ZXJIZWxwZXIiLCJuYW1lIiwiZm4iLCJfdXRpbHMiLCJjYWxsIiwidW5yZWdpc3RlckhlbHBlciIsInJlZ2lzdGVyUGFydGlhbCIsInBhcnRpYWwiLCJ1bnJlZ2lzdGVyUGFydGlhbCIsInJlZ2lzdGVyRGVjb3JhdG9yIiwidW5yZWdpc3RlckRlY29yYXRvciIsInJlc2V0TG9nZ2VkUHJvcGVydHlBY2Nlc3NlcyIsIl9pbnRlcm5hbFByb3RvQWNjZXNzIiwiY3JlYXRlRnJhbWUiLCJyZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzIiwiaW5zdGFuY2UiLCJfZGVjb3JhdG9yc0lubGluZTIiLCJwcm9wcyIsImNvbnRhaW5lciIsIm9wdGlvbnMiLCJyZXQiLCJjb250ZXh0Iiwib3JpZ2luYWwiLCJhcmdzIiwiZXJyb3JQcm9wcyIsIm1lc3NhZ2UiLCJub2RlIiwibG9jIiwibGluZSIsImVuZExpbmVOdW1iZXIiLCJjb2x1bW4iLCJlbmRDb2x1bW4iLCJzdGFydCIsImVuZCIsInRtcCIsIkVycm9yIiwiaWR4IiwibGVuZ3RoIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJsaW5lTnVtYmVyIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJub3AiLCJyZWdpc3RlckRlZmF1bHRIZWxwZXJzIiwiX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcyIiwiX2hlbHBlcnNFYWNoMiIsIl9oZWxwZXJzSGVscGVyTWlzc2luZzIiLCJfaGVscGVyc0lmMiIsIl9oZWxwZXJzTG9nMiIsIl9oZWxwZXJzTG9va3VwMiIsIl9oZWxwZXJzV2l0aDIiLCJtb3ZlSGVscGVyVG9Ib29rcyIsImhlbHBlck5hbWUiLCJrZWVwSGVscGVyIiwiaG9va3MiLCJpbnZlcnNlIiwiaWRzIiwiZWFjaCIsImRhdGEiLCJjb250ZXh0UGF0aCIsImkiLCJleGVjSXRlcmF0aW9uIiwiZmllbGQiLCJpbmRleCIsImxhc3QiLCJrZXkiLCJmaXJzdCIsImJsb2NrUGFyYW1zIiwiaiIsImdsb2JhbCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibmV3Q29udGV4dCIsIml0IiwibmV4dCIsImRvbmUiLCJwdXNoIiwicHJpb3JLZXkiLCJrZXlzIiwiZm9yRWFjaCIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImNvbmRpdGlvbmFsIiwiaGFzaCIsImluY2x1ZGVaZXJvIiwibGV2ZWwiLCJvYmoiLCJsb29rdXBQcm9wZXJ0eSIsImNyZWF0ZU5ld0xvb2t1cE9iamVjdCIsInNvdXJjZXMiLCJsb2dnZWRQcm9wZXJ0aWVzIiwiY3JlYXRlUHJvdG9BY2Nlc3NDb250cm9sIiwicnVudGltZU9wdGlvbnMiLCJkZWZhdWx0TWV0aG9kV2hpdGVMaXN0IiwiZGVmYXVsdFByb3BlcnR5V2hpdGVMaXN0IiwicHJvcGVydGllcyIsIndoaXRlbGlzdCIsIl9jcmVhdGVOZXdMb29rdXBPYmplY3QiLCJhbGxvd2VkUHJvdG9Qcm9wZXJ0aWVzIiwiZGVmYXVsdFZhbHVlIiwiYWxsb3dQcm90b1Byb3BlcnRpZXNCeURlZmF1bHQiLCJtZXRob2RzIiwiYWxsb3dlZFByb3RvTWV0aG9kcyIsImFsbG93UHJvdG9NZXRob2RzQnlEZWZhdWx0IiwicmVzdWx0SXNBbGxvd2VkIiwicmVzdWx0IiwicHJvdG9BY2Nlc3NDb250cm9sIiwicHJvcGVydHlOYW1lIiwiY2hlY2tXaGl0ZUxpc3QiLCJwcm90b0FjY2Vzc0NvbnRyb2xGb3JUeXBlIiwibG9nVW5leHBlY2VkUHJvcGVydHlBY2Nlc3NPbmNlIiwicmVzZXRMb2dnZWRQcm9wZXJ0aWVzIiwid3JhcEhlbHBlciIsImhlbHBlciIsInRyYW5zZm9ybU9wdGlvbnNGbiIsIndyYXBwZXIiLCJhcHBseSIsIm1ldGhvZE1hcCIsImxvb2t1cExldmVsIiwibGV2ZWxNYXAiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlSW50IiwiY29uc29sZSIsIm1ldGhvZCIsIkhhbmRsZWJhcnMiLCJyb290Iiwid2luZG93IiwiJEhhbmRsZWJhcnMiLCJub0NvbmZsaWN0IiwiY2hlY2tSZXZpc2lvbiIsImNvbXBpbGVySW5mbyIsImNvbXBpbGVyUmV2aXNpb24iLCJjdXJyZW50UmV2aXNpb24iLCJydW50aW1lVmVyc2lvbnMiLCJfYmFzZSIsImNvbXBpbGVyVmVyc2lvbnMiLCJ0ZW1wbGF0ZVNwZWMiLCJlbnYiLCJtYWluIiwiZGVjb3JhdG9yIiwibWFpbl9kIiwiY29tcGlsZXIiLCJ0ZW1wbGF0ZVdhc1ByZWNvbXBpbGVkV2l0aENvbXBpbGVyVjciLCJpbnZva2VQYXJ0aWFsV3JhcHBlciIsInJlc29sdmVQYXJ0aWFsIiwiZXh0ZW5kZWRPcHRpb25zIiwiaW52b2tlUGFydGlhbCIsImNvbXBpbGUiLCJjb21waWxlck9wdGlvbnMiLCJpbmRlbnQiLCJsaW5lcyIsInNwbGl0IiwibCIsImpvaW4iLCJzdHJpY3QiLCJwYXJlbnQiLCJoYXNPd25Qcm9wZXJ0eSIsImxvb2t1cCIsImRlcHRocyIsImxlbiIsImxhbWJkYSIsImN1cnJlbnQiLCJwcm9ncmFtcyIsInByb2dyYW0iLCJkZWNsYXJlZEJsb2NrUGFyYW1zIiwicHJvZ3JhbVdyYXBwZXIiLCJ3cmFwUHJvZ3JhbSIsImRlcHRoIiwiX3BhcmVudCIsIm1lcmdlSWZOZWVkZWQiLCJwYXJhbSIsImNvbW1vbiIsIm51bGxDb250ZXh0Iiwic2VhbCIsIm5vb3AiLCJfc2V0dXAiLCJ1c2VEYXRhIiwiaW5pdERhdGEiLCJ1c2VCbG9ja1BhcmFtcyIsInVzZURlcHRocyIsImNvbmNhdCIsImV4ZWN1dGVEZWNvcmF0b3JzIiwiaXNUb3AiLCJtZXJnZWRIZWxwZXJzIiwid3JhcEhlbHBlcnNUb1Bhc3NMb29rdXBQcm9wZXJ0eSIsInVzZVBhcnRpYWwiLCJ1c2VEZWNvcmF0b3JzIiwia2VlcEhlbHBlckluSGVscGVycyIsImFsbG93Q2FsbHNUb0hlbHBlck1pc3NpbmciLCJfY2hpbGQiLCJwcm9nIiwiY3VycmVudERlcHRocyIsImN1cnJlbnRQYXJ0aWFsQmxvY2siLCJwYXJ0aWFsQmxvY2siLCJwYXJ0aWFsQmxvY2tXcmFwcGVyIiwiRnVuY3Rpb24iLCJwYXNzTG9va3VwUHJvcGVydHlPcHRpb24iLCJfaW50ZXJuYWxXcmFwSGVscGVyIiwic3RyaW5nIiwidG9TdHJpbmciLCJ0b0hUTUwiLCJlc2NhcGUiLCJiYWRDaGFycyIsInBvc3NpYmxlIiwiZXNjYXBlQ2hhciIsImNociIsImlzRnVuY3Rpb24iLCJleHBvcnRzIiwiaXNBcnJheSIsIkFycmF5IiwiaW5kZXhPZiIsImFycmF5IiwidGVzdCIsInJlcGxhY2UiLCJpc0VtcHR5Iiwib2JqZWN0IiwiZnJhbWUiLCJwYXJhbXMiLCJwYXRoIiwiYXBwZW5kQ29udGV4dFBhdGgiLCJpZCIsIm1vZHVsZSIsInJlcXVpcmUiLCJlIiwidCIsImRlZmluZSIsImFtZCIsIlBhcGEiLCJzIiwiZiIsInNlbGYiLCJuIiwiZG9jdW1lbnQiLCJwb3N0TWVzc2FnZSIsIm8iLCJsb2NhdGlvbiIsInByb3RvY29sIiwiYSIsImgiLCJiIiwicGFyc2UiLCJkeW5hbWljVHlwaW5nIiwiTSIsImR5bmFtaWNUeXBpbmdGdW5jdGlvbiIsInRyYW5zZm9ybSIsIndvcmtlciIsIldPUktFUlNfU1VQUE9SVEVEIiwiciIsIlVSTCIsIndlYmtpdFVSTCIsIkJMT0JfVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiQmxvYiIsInR5cGUiLCJXb3JrZXIiLCJvbm1lc3NhZ2UiLCJfIiwidXNlclN0ZXAiLCJzdGVwIiwidXNlckNodW5rIiwiY2h1bmsiLCJ1c2VyQ29tcGxldGUiLCJjb21wbGV0ZSIsInVzZXJFcnJvciIsImVycm9yIiwiaW5wdXQiLCJjb25maWciLCJ3b3JrZXJJZCIsIk5PREVfU1RSRUFNX0lOUFVUIiwiZG93bmxvYWQiLCJwIiwicmVhZGFibGUiLCJyZWFkIiwib24iLCJnIiwiRmlsZSIsImMiLCJzdHJlYW0iLCJ1bnBhcnNlIiwibSIsInkiLCJkZWxpbWl0ZXIiLCJCQURfREVMSU1JVEVSUyIsImZpbHRlciIsInF1b3RlcyIsInNraXBFbXB0eUxpbmVzIiwibmV3bGluZSIsInF1b3RlQ2hhciIsImhlYWRlciIsImNvbHVtbnMiLCJlc2NhcGVGb3JtdWxhZSIsIlJlZ0V4cCIsIkpTT04iLCJ1IiwiZmllbGRzIiwibWV0YSIsInYiLCJ0cmltIiwiZCIsIkRhdGUiLCJzdHJpbmdpZnkiLCJzbGljZSIsImNoYXJBdCIsIlJFQ09SRF9TRVAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTklUX1NFUCIsIkJZVEVfT1JERVJfTUFSSyIsIkxvY2FsQ2h1bmtTaXplIiwiUmVtb3RlQ2h1bmtTaXplIiwiRGVmYXVsdERlbGltaXRlciIsIlBhcnNlciIsIkUiLCJQYXJzZXJIYW5kbGUiLCJOZXR3b3JrU3RyZWFtZXIiLCJGaWxlU3RyZWFtZXIiLCJTdHJpbmdTdHJlYW1lciIsIlJlYWRhYmxlU3RyZWFtU3RyZWFtZXIiLCJqUXVlcnkiLCJwcm9wIiwidG9VcHBlckNhc2UiLCJhdHRyIiwiRmlsZVJlYWRlciIsImZpbGVzIiwiZmlsZSIsImlucHV0RWxlbSIsImluc3RhbmNlQ29uZmlnIiwiYmVmb3JlIiwiYWN0aW9uIiwicmVhc29uIiwic3BsaWNlIiwiX2hhbmRsZSIsIl9maW5pc2hlZCIsIl9jb21wbGV0ZWQiLCJfaGFsdGVkIiwiX2lucHV0IiwiX2Jhc2VJbmRleCIsIl9wYXJ0aWFsTGluZSIsIl9yb3dDb3VudCIsIl9zdGFydCIsIl9uZXh0Q2h1bmsiLCJpc0ZpcnN0Q2h1bmsiLCJfY29tcGxldGVSZXN1bHRzIiwiZXJyb3JzIiwidyIsImNodW5rU2l6ZSIsInN0cmVhbWVyIiwiX2NvbmZpZyIsInBhcnNlQ2h1bmsiLCJiZWZvcmVGaXJzdENodW5rIiwicGF1c2VkIiwiYWJvcnRlZCIsImN1cnNvciIsInN1YnN0cmluZyIsInByZXZpZXciLCJyZXN1bHRzIiwiV09SS0VSX0lEIiwiZmluaXNoZWQiLCJfc2VuZEVycm9yIiwiX3JlYWRDaHVuayIsIl9jaHVua0xvYWRlZCIsIlhNTEh0dHBSZXF1ZXN0Iiwid2l0aENyZWRlbnRpYWxzIiwib25sb2FkIiwib25lcnJvciIsIl9jaHVua0Vycm9yIiwib3BlbiIsImRvd25sb2FkUmVxdWVzdEJvZHkiLCJkb3dubG9hZFJlcXVlc3RIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsInNlbmQiLCJzdGF0dXMiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VUZXh0IiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJsYXN0SW5kZXhPZiIsInN0YXR1c1RleHQiLCJ3ZWJraXRTbGljZSIsIm1velNsaWNlIiwiRmlsZVJlYWRlclN5bmMiLCJNYXRoIiwibWluIiwic2l6ZSIsInJlYWRBc1RleHQiLCJlbmNvZGluZyIsInRhcmdldCIsInBhdXNlIiwicmVzdW1lIiwiX3N0cmVhbURhdGEiLCJfc3RyZWFtRW5kIiwiX3N0cmVhbUVycm9yIiwiX2NoZWNrSXNGaW5pc2hlZCIsInNoaWZ0IiwiX3N0cmVhbUNsZWFuVXAiLCJyZW1vdmVMaXN0ZW5lciIsInBvdyIsImFib3J0IiwiayIsInRyYW5zZm9ybUhlYWRlciIsIm1hcCIsInBhcnNlRmxvYXQiLCJjb2RlIiwicm93IiwiY29tbWVudHMiLCJhYnMiLCJzdWNjZXNzZnVsIiwiYmVzdERlbGltaXRlciIsImRlbGltaXRlcnNUb0d1ZXNzIiwiZ2V0Q2hhckluZGV4Iiwic2V0VGltZW91dCIsIlMiLCJPIiwieCIsIkkiLCJUIiwiRCIsIkEiLCJmYXN0TW9kZSIsIkwiLCJGIiwieiIsIkMiLCJSIiwic3Vic3RyIiwibGluZWJyZWFrIiwidHJ1bmNhdGVkIiwidGVybWluYXRlIiwiQ29tcG9uZW50IiwiZ2V0REJNYW5hZ2VyIiwiZGF0ZVRvU3RyIiwiZGF0ZVRvRGlmZlRpbWVTdHIiLCJlbXB0eUVsZW1lbnQiLCJyb3dUZW1wbGF0ZSIsImZvcm1Ub0pTT04iLCJDMVRhYmxlIiwiZGJNYW5hZ2VyIiwiX2luaXQiLCJsYWJlbHMiLCJnZXRBdHRyaWJ1dGUiLCJmaWx0ZXJLZXkiLCJ0aXRsZSIsInJvd3NLZXkiLCJlZGl0RW5hYmxlZCIsImFjdGlvbkRpc2FibGVkIiwib3JkZXJCeSIsIm9yZGVyRGlyIiwiZ2V0Um93cyIsInJvd3MiLCJyb3dzSHRtbHMiLCJfZ2VuZXJhdGVSb3dzIiwicGFyc2VyIiwiRE9NUGFyc2VyIiwiaHRtbERvYyIsInBhcnNlRnJvbVN0cmluZyIsImFwcGVuZENoaWxkIiwiYm9keSIsImZpcnN0RWxlbWVudENoaWxkIiwidGFibGVCb2R5IiwiX3JlZiIsIl9hZGRMaXN0ZW5lcnMiLCJfYWRkTGlzdGVuZXIiLCJldmVudCIsIm1hdGNoZXMiLCJ0ciIsImNsb3Nlc3QiLCJkYXRhc2V0IiwiZGVsZXRlUm93Iiwib2siLCJyZW1vdmUiLCJpbm5lckhUTUwiLCJlZGl0Um93IiwicHJldmVudERlZmF1bHQiLCJjdXJyZW50RmlsdGVyIiwicm93c0h0bWxzSm9pbiIsIml0ZW0iLCJyZXMiLCJmaW5hbFJvd3MiLCJyZWdleCIsInNvcnQiLCJvbmUiLCJ0d28iLCJfcm93TWFwIiwibWFwcGVkUm93IiwidW5zaGlmdCIsImluc2VydEJlZm9yZSIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRTdG9yZU1hbmFnZXIiLCJDMk5hdiIsIl9hZGRTdG9yZUxpc3RlbmVyIiwicmVsb2FkIiwic2VsZWN0ZWRSYWNlIiwiZ2V0IiwicmFjZUlkIiwicmFjZSIsImdldEFsbFBTIiwicHMiLCJidXR0b24iLCJjdXJyZW50VGFyZ2V0IiwiX2VtaXQiLCJkZXN0aW5hdGlvbiIsImNoZWNrQWN0aXZlTWVudSIsInNlbGVjdGVkUGFnZSIsIm1lbnVJdGVtcyIsImNsYXNzTGlzdCIsImFkZCIsIkwxQXBwIiwiY29udGVudCIsIkwyTWFpbiIsInN0b3JlTWFuYWdlciIsIl9hZGRTdG9yZUxpc3RlbmVycyIsImRhc2hib2FyZENvbnRlbnQiLCJfZ2V0TG9jYXRpb24iLCJkYXNoYm9hcmRUaXRsZSIsImN1cnJlbnRQYWdlIiwiY2xvc2UiLCJtZW51QnRuIiwiZHJhd2VyTWVudSIsIm5hdiIsImNvbnRhaW5zIiwic3RhcnRzV2l0aCIsIk0wUmFjZXIiLCJnZXRBbGxSYWNlIiwiaW1nIiwiZm9ybUNyZWF0ZSIsImZvcm1TZWxlY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsInJhY2VOYW1lIiwiY3JlYXRlUmFjZSIsImpzb25Ub0Zvcm0iLCJNMURhc2hib2FyZCIsIl9uZXdUaW1lIiwiZGV0YWlsIiwidGltZSIsInRpbWVUYWJsZSIsInRha2VUYWJsZSIsImFzc2lnblRpbWUiLCJfYXNzaWduVGltZSIsImdldEFsbFRha2VKb2luIiwiZ2V0QWxsVGltZUpvaW4iLCJnZXRUaW1lSm9pbiIsImFzc2lnbmVkIiwid2FybiIsImRlbGV0ZVRpbWUiLCJkZWxldGVUYWtlIiwiZ2V0VGltZSIsIl9zZXRUaW1lIiwiYWRkUm93IiwiYWN0aXZlRWxlbWVudCIsInRpbWVTdHIiLCJmb2N1cyIsImpzb24iLCJnZXRQU0J5IiwicHNOYW1lIiwiZ2V0UnVubmVyQnkiLCJudW1iZXIiLCJydW5uZXJOdW0iLCJydW5uZXIiLCJnZXRUYWtlQnkiLCJ0YWtlIiwiY3JlYXRlVGFrZSIsInJlc2V0IiwicmVhZEZpbGVBc3luYyIsIk0yUmFjZSIsInRhYmxlIiwiX2NyZWF0ZVBzIiwiX3VwbG9hZFBzIiwiX2Rvd25sb2FkIiwiZm9ybSIsImNyZWF0ZU9yVXBkYXRlUFMiLCJjbGVhblBTIiwiYXJyYXlCdWZmZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJjc3YiLCJkZWNvZGUiLCJkZWxldGVQUyIsImNzdkNvbnRlbnQiLCJlbmNvZGVVUkkiLCJNM1J1bm5lcnMiLCJfY3JlYXRlUnVubmVyIiwiX3VwbG9hZFJ1bm5lciIsImNyZWF0ZU9yVXBkYXRlUnVubmVyIiwiY2xlYW5SdW5uZXIiLCJnZXRBbGxSdW5uZXIiLCJkZWxldGVSdW5uZXIiLCJNNFNjb3JlIiwicHNJZCIsImdldFNjb3JlIiwic2V0QXR0cmlidXRlIiwibGlzdGVuZXJzIiwic3RvcmVMaXN0ZW5lcnMiLCJfcmVtb3ZlQWxsTGlzdGVuZXJzIiwiX3JlbW92ZUFsbFN0b3JlTGlzdGVuZXJzIiwiZXYiLCJjYiIsImVsIiwic3RhcnRGcm9tIiwiZXZlbnRzIiwiZWxlbWVudHMiLCJFbGVtZW50IiwiRG9jdW1lbnQiLCJXaW5kb3ciLCJkZWJ1ZyIsImVsZW1lbnQiLCJfYWRkTGlzdGVuZXJUbyIsImNhbGxiYWNrIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibWVyZ2UiLCJlbWl0IiwibWF0Y2giLCJhZGRMaXN0ZW5lciIsImFsbCIsInN0YXJ0RWwiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsInBhcmVudEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIkRleGllIiwiREJNYW5hZ2VyIiwiZGIiLCJ2ZXJzaW9uIiwic3RvcmVzIiwidG9BcnJheSIsIndoZXJlIiwiZXF1YWxzIiwiZ2FwIiwib3JkZXIiLCJ1cGRhdGUiLCJidWxrRGVsZXRlIiwiY2F0ZWdvcnkiLCJmb3VuZCIsImFzc2lnbmVkTmFtZSIsIm9ubHlOb3RBc3NpZ25lZCIsImdldEFsbFRpbWUiLCJ0aW1lcyIsIlByb21pc2UiLCJhc3NpZ25lZFBzIiwiZ2V0QWxsVGFrZSIsInRha2VzIiwiYXNzaWduZWRJZFRpbWUiLCJhc3NpZ25lZFRpbWUiLCJydW5uZXJzIiwiZGlyZWN0aW9uIiwiZGlmZiIsInRhYmxlcyIsImNsZWFyIiwicmNEYk1hbmFnZXIiLCJFdmVudFNlcnZpY2UiLCJFdmVudFNvdXJjZSIsInNvdXJjZSIsImluaXREYXRlIiwiaW5pdE1pbGxpcyIsIl9hZGRTb3VyY2VMaXN0ZW5lcnMiLCJfYWRkRmFrZUxpc3RlbmVycyIsIk9QRU4iLCJfaW5pdEV2ZW50IiwiX3Rha2VFdmVudCIsIl9zZW5kRXZlbnQiLCJuZXdEYXRlTWlsbGlzIiwiY3VycmVudERhdGUiLCJ0YWtlZERhdGUiLCJhZGRUaW1lIiwidGltZURhdGEiLCJjdXN0b20iLCJDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJnZXRFdmVudFNlcnZpY2UiLCJyY0V2ZW50U2VydmljZSIsImlzVmFsaWRFbGVtZW50IiwiaGFzVmFsdWUiLCJpc1ZhbGlkVmFsdWUiLCJpbmNsdWRlcyIsImNoZWNrZWQiLCJpc0NoZWNrYm94IiwiaXNSYWRpbyIsImlzTXVsdGlTZWxlY3QiLCJtdWx0aXBsZSIsImdldFNlbGVjdFZhbHVlcyIsInJlZHVjZSIsInZhbHVlcyIsIm9wdGlvbiIsInNlbGVjdGVkIiwiaW5jbHVkZUVtcHR5IiwiaWdub3JlIiwiU3RvcmVNYW5hZ2VyIiwicm9vdEVsIiwiZG9jdW1lbnRFbGVtZW50IiwiY2JzIiwiaW5pdGlhbFN0b3JlIiwic3QiLCJmRm4iLCJwYXRoQ2hhbmdlZCIsIm5ld0RhdGEiLCJvbGREYXRhIiwib2xkVmFsdWUiLCJfcmVjTG9va3VwIiwibmV3VmFsdWUiLCJfcmVjU2V0dXAiLCJwYXJ0cyIsIm5PYmoiLCJpT2JqIiwicmNTdG9yZU1hbmFnZXIiLCJidWlsZFdhaXRGb3JFdmVudCIsImV2ZW50TmFtZSIsImZ1bmMiLCJyZXNvbHZlIiwicmVqZWN0IiwiU1ZHRWxlbWVudCIsImhhbmRsZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhbmltYXRpb25FbmQiLCJ0cmFuc2l0aW9uRW5kIiwiZGVsYXkiLCJtcyIsImdldE5leHRTaWJsaW5nIiwiZWxlbSIsInNlbGVjdG9yIiwic2libGluZyIsIm5leHRFbGVtZW50U2libGluZyIsImdldFByZXZTaWJsaW5nIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImdldE5leHRTaWJsaW5nQWxsIiwiZ2V0UHJldlNpYmxpbmdBbGwiLCJnZXRGaXJzdENoaWxkIiwibm9kZXMiLCJjaGlsZHJlbiIsImdldExhc3RDaGlsZCIsImdldENsb3Nlc3RBbGwiLCJjbG9zZXN0T25lIiwiYXJyIiwiY2xvIiwiYnVpbGRRdWVyeSIsImVudHJpZXMiLCJwYWlyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaHRtbFRvRWxlbWVudCIsImh0bWwiLCJjcmVhdGVFbGVtZW50IiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwibGFzdENoaWxkIiwiaXNQb3NpdGl2ZSIsImlzT2JqZWN0RW1wdHkiLCJnZXRQcm90b3R5cGVPZiIsImRlYm91bmNlIiwidGltZW91dElkIiwiY2xlYXJUaW1lb3V0IiwibWFrZWlkIiwiY2hhcmFjdGVycyIsImNoYXJhY3RlcnNMZW5ndGgiLCJmbG9vciIsInJhbmRvbSIsInRpbWVJbnN0YW50IiwiZm9ybWF0dGVkSG91ciIsInQwIiwidDBzcGxpdCIsInNldEhvdXJzIiwic2V0TWludXRlcyIsInRvVXJsRnJpZW5kbHkiLCJ0ZXh0Iiwibm9ybWFsaXplIiwicmVwbGFjZUFsbCIsImlzUmVmZXJyZXJDdXJyZW50RG9tYWluIiwicmVmZXJyZXIiLCJvcmlnaW4iLCJpbmZvIiwiaXNJblZpZXdwb3J0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsImxlZnQiLCJib3R0b20iLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsInJpZ2h0IiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwiY2FsY1RvcCIsIm9mZnNldCIsInBvcEhlaWdodCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiaGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiY2FsY0xlZnQiLCJwb3BXaWR0aCIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFdpZHRoIiwiaXNPYmplY3QiLCJtZXJnZURlZXAiLCJhc3NpZ24iLCJyZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIndpdGhNcyIsImRhdGUiLCJzdHIiLCJ0b0xvY2FsZVN0cmluZyIsImdldE1pbGxpc2Vjb25kcyIsInBhZFN0YXJ0IiwiZ2V0VVRDSG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImN1c3RvbUVsZW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==